<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>

</head>
<body style="background-color:white;">
<div id="htmlwidget_container">
  <div id="htmlwidget-7411" style="width:960px;height:500px;" class="profvis"></div>
</div>
<script type="application/json" data-for="htmlwidget-7411">{"x":{"message":{"prof":{},"interval":10,"files":[{"filename":"/R/conditions.R","content":"#' Stack trace manipulation functions\n#'\n#' Advanced (borderline internal) functions for capturing, printing, and\n#' manipulating stack traces.\n#'\n#' @return \\code{printError} and \\code{printStackTrace} return\n#'   \\code{invisible()}. The other functions pass through the results of\n#'   \\code{expr}.\n#'\n#' @examples\n#' # Keeps tryCatch and withVisible related calls off the\n#' # pretty-printed stack trace\n#'\n#' visibleFunction1 <- function() {\n#'   stop(\"Kaboom!\")\n#' }\n#'\n#' visibleFunction2 <- function() {\n#'   visibleFunction1()\n#' }\n#'\n#' hiddenFunction <- function(expr) {\n#'   expr\n#' }\n#'\n#' # An example without ..stacktraceon/off.. manipulation.\n#' # The outer \"try\" is just to prevent example() from stopping.\n#' try({\n#'   # The withLogErrors call ensures that stack traces are captured\n#'   # and that errors that bubble up are logged using warning().\n#'   withLogErrors({\n#'     # tryCatch and withVisible are just here to add some noise to\n#'     # the stack trace.\n#'     tryCatch(\n#'       withVisible({\n#'         hiddenFunction(visibleFunction2())\n#'       })\n#'     )\n#'   })\n#' })\n#'\n#' # Now the same example, but with ..stacktraceon/off.. to hide some\n#' # of the less-interesting bits (tryCatch and withVisible).\n#' ..stacktraceoff..({\n#'   try({\n#'     withLogErrors({\n#'       tryCatch(\n#'         withVisible(\n#'           hiddenFunction(\n#'             ..stacktraceon..(visibleFunction2())\n#'           )\n#'         )\n#'       )\n#'     })\n#'   })\n#' })\n#'\n#'\n#' @name stacktrace\n#' @rdname stacktrace\n#' @keywords internal\nNULL\n\ngetCallNames <- function(calls) {\n  sapply(calls, function(call) {\n    if (is.function(call[[1]])) {\n      \"<Anonymous>\"\n    } else if (inherits(call[[1]], \"call\")) {\n      paste0(format(call[[1]]), collapse = \" \")\n    } else if (typeof(call[[1]]) == \"promise\") {\n      \"<Promise>\"\n    } else {\n      paste0(as.character(call[[1]]), collapse = \" \")\n    }\n  })\n}\n\ngetLocs <- function(calls) {\n  sapply(calls, function(call) {\n    srcref <- attr(call, \"srcref\", exact = TRUE)\n    if (!is.null(srcref)) {\n      srcfile <- attr(srcref, \"srcfile\", exact = TRUE)\n      if (!is.null(srcfile) && !is.null(srcfile$filename)) {\n        loc <- paste0(srcfile$filename, \"#\", srcref[[1]])\n        return(paste0(\" [\", loc, \"]\"))\n      }\n    }\n    return(\"\")\n  })\n}\n\n#' @details \\code{captureStackTraces} runs the given \\code{expr} and if any\n#'   \\emph{uncaught} errors occur, annotates them with stack trace info for use\n#'   by \\code{printError} and \\code{printStackTrace}. It is not necessary to use\n#'   \\code{captureStackTraces} around the same expression as\n#'   \\code{withLogErrors}, as the latter includes a call to the former. Note\n#'   that if \\code{expr} contains calls (either directly or indirectly) to\n#'   \\code{try}, or \\code{tryCatch} with an error handler, stack traces therein\n#'   cannot be captured unless another \\code{captureStackTraces} call is\n#'   inserted in the interior of the \\code{try} or \\code{tryCatch}. This is\n#'   because these calls catch the error and prevent it from traveling up to the\n#'   condition handler installed by \\code{captureStackTraces}.\n#'\n#' @param expr The expression to wrap.\n#' @rdname stacktrace\n#' @export\ncaptureStackTraces <- function(expr) {\n  withCallingHandlers(expr,\n    error = function(e) {\n      if (is.null(attr(e, \"stack.trace\", exact = TRUE))) {\n        calls <- sys.calls()\n        attr(e, \"stack.trace\") <- calls\n        stop(e)\n      }\n    }\n  )\n}\n\n#' @details \\code{withLogErrors} captures stack traces and logs errors that\n#'   occur in \\code{expr}, but does allow errors to propagate beyond this point\n#'   (i.e. it doesn't catch the error). The same caveats that apply to\n#'   \\code{captureStackTraces} with regard to \\code{try}/\\code{tryCatch} apply\n#'   to \\code{withLogErrors}.\n#' @rdname stacktrace\n#' @export\nwithLogErrors <- function(expr,\n  full = getOption(\"shiny.fullstacktrace\", FALSE),\n  offset = getOption(\"shiny.stacktraceoffset\", TRUE)) {\n\n  withCallingHandlers(\n    captureStackTraces(expr),\n    error = function(cond) {\n      # Don't print shiny.silent.error (i.e. validation errors)\n      if (inherits(cond, \"shiny.silent.error\"))\n        return()\n      printError(cond, full = full, offset = offset)\n    }\n  )\n}\n\n#' @details \\code{printError} prints the error and stack trace (if any) using\n#'   \\code{warning(immediate.=TRUE)}. \\code{printStackTrace} prints the stack\n#'   trace only.\n#'\n#' @param cond An condition object (generally, an error).\n#' @param full If \\code{TRUE}, then every element of \\code{sys.calls()} will be\n#'   included in the stack trace. By default (\\code{FALSE}), calls that Shiny\n#'   deems uninteresting will be hidden.\n#' @param offset If \\code{TRUE} (the default), srcrefs will be reassigned from\n#'   the calls they originated from, to the destinations of those calls. If\n#'   you're used to stack traces from other languages, this feels more\n#'   intuitive, as the definition of the function indicated in the call and the\n#'   location specified by the srcref match up. If \\code{FALSE}, srcrefs will be\n#'   left alone (traditional R treatment where the srcref is of the callsite).\n#' @rdname stacktrace\n#' @export\nprintError <- function(cond,\n  full = getOption(\"shiny.fullstacktrace\", FALSE),\n  offset = getOption(\"shiny.stacktraceoffset\", TRUE)) {\n\n  warning(call. = FALSE, immediate. = TRUE, sprintf(\"Error in %s: %s\",\n    getCallNames(list(conditionCall(cond))), conditionMessage(cond)))\n  printStackTrace(cond, full = full, offset = offset)\n  invisible()\n}\n\n#' @rdname stacktrace\n#' @export\nprintStackTrace <- function(cond,\n  full = getOption(\"shiny.fullstacktrace\", FALSE),\n  offset = getOption(\"shiny.stacktraceoffset\", TRUE)) {\n\n  stackTrace <- attr(cond, \"stack.trace\", exact = TRUE)\n  tryCatch(\n    if (!is.null(stackTrace)) {\n      message(paste0(\n        \"Stack trace (innermost first):\\n\",\n        paste0(collapse = \"\\n\",\n          formatStackTrace(stackTrace, full = full, offset = offset,\n            indent = \"    \")\n        )\n      ))\n    } else {\n      message(\"No stack trace available\")\n    },\n\n    error = function(cond) {\n      warning(\"Failed to write stack trace: \", cond)\n    }\n  )\n  invisible()\n}\n\n#' @details \\code{extractStackTrace} takes a list of calls (e.g. as returned\n#'   from \\code{conditionStackTrace(cond)}) and returns a data frame with one\n#'   row for each stack frame and the columns \\code{num} (stack frame number),\n#'   \\code{call} (a function name or similar), and \\code{loc} (source file path\n#'   and line number, if available).\n#' @rdname stacktrace\n#' @export\nextractStackTrace <- function(calls,\n  full = getOption(\"shiny.fullstacktrace\", FALSE),\n  offset = getOption(\"shiny.stacktraceoffset\", TRUE)) {\n\n  srcrefs <- getSrcRefs(calls)\n  if (offset) {\n    # Offset calls vs. srcrefs by 1 to make them more intuitive.\n    # E.g. for \"foo [bar.R:10]\", line 10 of bar.R will be part of\n    # the definition of foo().\n    srcrefs <- c(utils::tail(srcrefs, -1), list(NULL))\n  }\n  calls <- setSrcRefs(calls, srcrefs)\n\n  callnames <- getCallNames(calls)\n\n  # Hide and show parts of the callstack based on ..stacktrace(on|off)..\n  if (full) {\n    toShow <- rep.int(TRUE, length(calls))\n  } else {\n    # Remove stop(), .handleSimpleError(), and h() calls from the end of\n    # the calls--they don't add any helpful information. But only remove\n    # the last *contiguous* block of them, and then, only if they are the\n    # last thing in the calls list.\n    hideable <- callnames %in% c(\"stop\", \".handleSimpleError\", \"h\")\n    # What's the last that *didn't* match stop/.handleSimpleError/h?\n    lastGoodCall <- max(which(!hideable))\n    toRemove <- length(calls) - lastGoodCall\n    # But don't remove more than 5 levels--that's an indication we might\n    # have gotten it wrong, I guess\n    if (toRemove > 0 && toRemove < 5) {\n      calls <- utils::head(calls, -toRemove)\n      callnames <- utils::head(callnames, -toRemove)\n    }\n\n    # This uses a ref-counting scheme. It might make sense to switch this\n    # to a toggling scheme, so the most recent ..stacktrace(on|off)..\n    # directive wins, regardless of what came before it.\n    # Also explicitly remove ..stacktraceon.. because it can appear with\n    # score > 0 but still should never be shown.\n    score <- rep.int(0, length(callnames))\n    score[callnames == \"..stacktraceoff..\"] <- -1\n    score[callnames == \"..stacktraceon..\"] <- 1\n    toShow <- (1 + cumsum(score)) > 0 & !(callnames %in% c(\"..stacktraceon..\", \"..stacktraceoff..\"))\n  }\n  calls <- calls[toShow]\n\n  calls <- rev(calls) # Show in traceback() order\n  index <- rev(which(toShow))\n  width <- floor(log10(max(index))) + 1\n\n  data.frame(\n    num = index,\n    call = getCallNames(calls),\n    loc = getLocs(calls),\n    stringsAsFactors = FALSE\n  )\n}\n\n#' @details \\code{formatStackTrace} is similar to \\code{extractStackTrace}, but\n#'   it returns a preformatted character vector instead of a data frame.\n#' @param indent A string to prefix every line of the stack trace.\n#' @rdname stacktrace\n#' @export\nformatStackTrace <- function(calls, indent = \"    \",\n  full = getOption(\"shiny.fullstacktrace\", FALSE),\n  offset = getOption(\"shiny.stacktraceoffset\", TRUE)) {\n\n  st <- extractStackTrace(calls, full = full, offset = offset)\n  if (nrow(st) == 0) {\n    return(character(0))\n  }\n\n  width <- floor(log10(max(st$num))) + 1\n  paste0(\n    indent,\n    formatC(st$num, width = width),\n    \": \",\n    st$call,\n    st$loc\n  )\n}\n\ngetSrcRefs <- function(calls) {\n  lapply(calls, function(call) {\n    attr(call, \"srcref\", exact = TRUE)\n  })\n}\n\nsetSrcRefs <- function(calls, srcrefs) {\n  mapply(function(call, srcref) {\n    structure(call, srcref = srcref)\n  }, calls, srcrefs)\n}\n\nstripStackTrace <- function(cond) {\n  conditionStackTrace(cond) <- NULL\n}\n\n#' @details \\code{conditionStackTrace} and \\code{conditionStackTrace<-} are\n#'   accessor functions for getting/setting stack traces on conditions.\n#'\n#' @param cond A condition that may have previously been annotated by\n#'   \\code{captureStackTraces} (or \\code{withLogErrors}).\n#' @rdname stacktrace\n#' @export\nconditionStackTrace <- function(cond) {\n  attr(cond, \"stack.trace\", exact = TRUE)\n}\n\n#' @param value The stack trace value to assign to the condition.\n#' @rdname stacktrace\n#' @export\n`conditionStackTrace<-` <- function(cond, value) {\n  attr(cond, \"stack.trace\") <- value\n  invisible(cond)\n}\n\n#' @details The two functions \\code{..stacktraceon..} and\n#'   \\code{..stacktraceoff..} have no runtime behavior during normal execution;\n#'   they exist only to create artifacts on the stack trace (sys.call()) that\n#'   instruct the stack trace pretty printer what parts of the stack trace are\n#'   interesting or not. The initial state is 1 and we walk from the outermost\n#'   call inwards. Each ..stacktraceoff.. decrements the state by one, and each\n#'   ..stacktraceon.. increments the state by one. Any stack trace frame whose\n#'   value is less than 1 is hidden, and finally, the ..stacktraceon.. and\n#'   ..stacktraceoff.. calls themselves are hidden too.\n#'\n#' @rdname stacktrace\n#' @export\n..stacktraceon.. <- function(expr) expr\n#' @rdname stacktrace\n#' @export\n..stacktraceoff.. <- function(expr) expr\n"},{"filename":"/R/shinyui.R","content":"#' @include globals.R\nNULL\n\n#' Load the MathJax library and typeset math expressions\n#'\n#' This function adds MathJax to the page and typeset the math expressions (if\n#' found) in the content \\code{...}. It only needs to be called once in an app\n#' unless the content is rendered \\emph{after} the page is loaded, e.g. via\n#' \\code{\\link{renderUI}}, in which case we have to call it explicitly every\n#' time we write math expressions to the output.\n#' @param ... any HTML elements to apply MathJax to\n#' @export\n#' @examples withMathJax(helpText(\"Some math here $$\\\\alpha+\\\\beta$$\"))\n#' # now we can just write \"static\" content without withMathJax()\n#' div(\"more math here $$\\\\sqrt{2}$$\")\nwithMathJax <- function(...) {\n  path <- 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'\n  tagList(\n    tags$head(\n      singleton(tags$script(src = path, type = 'text/javascript'))\n    ),\n    ...,\n    tags$script(HTML('MathJax.Hub.Queue([\"Typeset\", MathJax.Hub]);'))\n  )\n}\n\nrenderPage <- function(ui, connection, showcase=0) {\n  # If the ui is a NOT complete document (created by htmlTemplate()), then do some\n  # preprocessing and make sure it's a complete document.\n  if (!inherits(ui, \"html_document\")) {\n    if (showcase > 0)\n      ui <- showcaseUI(ui)\n\n    # Wrap ui in body tag if it doesn't already have a single top-level body tag.\n    if (!(inherits(ui, \"shiny.tag\") && ui$name == \"body\"))\n      ui <- tags$body(ui)\n\n    # Put the body into the default template\n    ui <- htmlTemplate(\n      system.file(\"template\", \"default.html\", package = \"shiny\"),\n      body = ui\n    )\n  }\n\n  shiny_deps <- list(\n    htmlDependency(\"json2\", \"2014.02.04\", c(href=\"shared\"), script = \"json2-min.js\"),\n    htmlDependency(\"jquery\", \"1.11.3\", c(href=\"shared\"), script = \"jquery.min.js\"),\n    htmlDependency(\"shiny\", utils::packageVersion(\"shiny\"), c(href=\"shared\"),\n      script = if (getOption(\"shiny.minified\", TRUE)) \"shiny.min.js\" else \"shiny.js\",\n      stylesheet = \"shiny.css\")\n  )\n  html <- renderDocument(ui, shiny_deps, processDep = createWebDependency)\n  writeUTF8(html, con = connection)\n}\n\n#' Create a Shiny UI handler\n#'\n#' Historically this function was used in ui.R files to register a user\n#' interface with Shiny. It is no longer required as of Shiny 0.10; simply\n#' ensure that the last expression to be returned from ui.R is a user interface.\n#' This function is kept for backwards compatibility with older applications. It\n#' returns the value that is passed to it.\n#'\n#' @param ui A user interace definition\n#' @return The user interface definition, without modifications or side effects.\n#'\n#' @export\nshinyUI <- function(ui) {\n  .globals$ui <- list(ui)\n  ui\n}\n\nuiHttpHandler <- function(ui, uiPattern = \"^/$\") {\n\n  force(ui)\n\n  function(req) {\n    if (!identical(req$REQUEST_METHOD, 'GET'))\n      return(NULL)\n\n    if (!isTRUE(grepl(uiPattern, req$PATH_INFO)))\n      return(NULL)\n\n    textConn <- file(open = \"w+\")\n    on.exit(close(textConn))\n\n    showcaseMode <- .globals$showcaseDefault\n    if (.globals$showcaseOverride) {\n      mode <- showcaseModeOfReq(req)\n      if (!is.null(mode))\n        showcaseMode <- mode\n    }\n    uiValue <- if (is.function(ui)) {\n      if (length(formals(ui)) > 0) {\n        # No corresponding ..stacktraceoff.., this is pure user code\n        ..stacktraceon..(ui(req))\n      } else {\n        # No corresponding ..stacktraceoff.., this is pure user code\n        ..stacktraceon..(ui())\n      }\n    } else {\n      ui\n    }\n    if (is.null(uiValue))\n      return(NULL)\n\n    renderPage(uiValue, textConn, showcaseMode)\n    html <- paste(readLines(textConn, encoding = 'UTF-8'), collapse='\\n')\n    return(httpResponse(200, content=enc2utf8(html)))\n  }\n}\n"},{"filename":"/R/middleware.R","content":"# This file contains a general toolkit for routing and combining bits of\n# HTTP-handling logic. It is similar in spirit to Rook (and Rack, and WSGI, and\n# Connect, and...) but adds cascading and routing.\n#\n# This file is called \"middleware\" because that's the term used for these bits\n# of logic in these other frameworks. However, our code uses the word \"handler\"\n# so we'll stick to that for the rest of this document; just know that they're\n# basically the same concept.\n#\n# ## Intro to handlers\n#\n# A **handler** (or sometimes, **httpHandler**) is a function that takes a\n# `req` parameter--a request object as described in the Rook specification--and\n# returns `NULL`, or an `httpResponse`.\n#\n## ------------------------------------------------------------------------\nhttpResponse <- function(status = 200,\n                         content_type = \"text/html; charset=UTF-8\",\n                         content = \"\",\n                         headers = list()) {\n  # Make sure it's a list, not a vector\n  headers <- as.list(headers)\n  if (is.null(headers$`X-UA-Compatible`))\n    headers$`X-UA-Compatible` <- \"IE=edge,chrome=1\"\n  resp <- list(status = status, content_type = content_type, content = content,\n               headers = headers)\n  class(resp) <- 'httpResponse'\n  return(resp)\n}\n\n#\n# You can think of a web application as being simply an aggregation of these\n# functions, each of which performs one kind of duty. Each handler in turn gets\n# a look at the request and can decide whether it knows how to handle it. If\n# so, it returns an `httpResponse` and processing terminates; if not, it\n# returns `NULL` and the next handler gets to execute. If the final handler\n# returns `NULL`, a 404 response should be returned.\n#\n# We have a similar construct for websockets: **websocket handlers** or\n# **wsHandlers**. These take a single `ws` argument which is the websocket\n# connection that was just opened, and they can either return `TRUE` if they\n# are handling the connection, and `NULL` to pass responsibility on to the next\n# wsHandler.\n#\n# ### Combining handlers\n#\n# Since it's so common for httpHandlers to be invoked in this \"cascading\"\n# fashion, we'll introduce a function that takes zero or more handlers and\n# returns a single handler. And while we're at it, making a directory of static\n# content available is such a common thing to do, we'll allow strings\n# representing paths to be used instead of handlers; any such strings we\n# encounter will be converted into `staticHandler` objects.\n#\n## ------------------------------------------------------------------------\njoinHandlers <- function(handlers) {\n  # Zero handlers; return a null handler\n  if (length(handlers) == 0)\n    return(function(req) NULL)\n\n  # Just one handler (function)? Return it.\n  if (is.function(handlers))\n    return(handlers)\n\n  handlers <- lapply(handlers, function(h) {\n    if (is.character(h))\n      return(staticHandler(h))\n    else\n      return(h)\n  })\n\n  # Filter out NULL\n  handlers <- handlers[!sapply(handlers, is.null)]\n\n  if (length(handlers) == 0)\n    return(function(req) NULL)\n  if (length(handlers) == 1)\n    return(handlers[[1]])\n\n  function(req) {\n    for (handler in handlers) {\n      response <- handler(req)\n      if (!is.null(response))\n        return(response)\n    }\n    return(NULL)\n  }\n}\n\n#\n# Note that we don't have an equivalent of `joinHandlers` for wsHandlers. It's\n# easy to imagine it, we just haven't needed one.\n#\n# ### Handler routing\n#\n# Handlers do not have a built-in notion of routing. Conceptually, given a list\n# of handlers, all the handlers are peers and they all get to see every request\n# (well, up until the point that a handler returns a response).\n#\n# You could implement routing in each handler by checking the request's\n# `PATH_INFO` field, but since it's such a common need, let's make it simple by\n# introducing a `routeHandler` function. This is a handler\n# [decorator](http://en.wikipedia.org/wiki/Decorator_pattern) and it's\n# responsible for 1) filtering out requests that don't match the given route,\n# and 2) temporarily modifying the request object to take the matched part of\n# the route off of the `PATH_INFO` (and add it to the end of `SCRIPT_NAME`).\n# This way, the handler doesn't need to figure out about what part of its URL\n# path has already been matched via routing.\n#\n# (BTW, it's safe for `routeHandler` calls to nest.)\n#\n## ------------------------------------------------------------------------\nrouteHandler <- function(prefix, handler) {\n  force(prefix)\n  force(handler)\n\n  if (identical(\"\", prefix))\n    return(handler)\n\n  if (length(prefix) != 1 || !isTRUE(grepl(\"^/[^\\\\]+$\", prefix))) {\n    stop(\"Invalid URL prefix \\\"\", prefix, \"\\\"\")\n  }\n\n  pathPattern <- paste(\"^\\\\Q\", prefix, \"\\\\E/\", sep = \"\")\n  function(req) {\n    if (isTRUE(grepl(pathPattern, req$PATH_INFO))) {\n      origScript <- req$SCRIPT_NAME\n      origPath <- req$PATH_INFO\n      on.exit({\n        req$SCRIPT_NAME <- origScript\n        req$PATH_INFO <- origPath\n      }, add = TRUE)\n      pathInfo <- substr(req$PATH_INFO, nchar(prefix)+1, nchar(req$PATH_INFO))\n      req$SCRIPT_NAME <- paste(req$SCRIPT_NAME, prefix, sep = \"\")\n      req$PATH_INFO <- pathInfo\n      return(handler(req))\n    } else {\n      return(NULL)\n    }\n  }\n}\n\n#\n# We have a version for websocket handlers as well. Pity about the copy/paste\n# job.\n#\n## ------------------------------------------------------------------------\nrouteWSHandler <- function(prefix, wshandler) {\n  force(prefix)\n  force(wshandler)\n\n  if (identical(\"\", prefix))\n    return(wshandler)\n\n  if (length(prefix) != 1 || !isTRUE(grepl(\"^/[^\\\\]+$\", prefix))) {\n    stop(\"Invalid URL prefix \\\"\", prefix, \"\\\"\")\n  }\n\n  pathPattern <- paste(\"^\\\\Q\", prefix, \"\\\\E/\", sep = \"\")\n  function(ws) {\n    req <- ws$request\n    if (isTRUE(grepl(pathPattern, req$PATH_INFO))) {\n      origScript <- req$SCRIPT_NAME\n      origPath <- req$PATH_INFO\n      on.exit({\n        req$SCRIPT_NAME <- origScript\n        req$PATH_INFO <- origPath\n      }, add = TRUE)\n      pathInfo <- substr(req$PATH_INFO, nchar(prefix)+1, nchar(req$PATH_INFO))\n      req$SCRIPT_NAME <- paste(req$SCRIPT_NAME, prefix, sep = \"\")\n      req$PATH_INFO <- pathInfo\n      return(wshandler(ws))\n    } else {\n      return(NULL)\n    }\n  }\n}\n\n#\n# ### Handler implementations\n#\n# Now let's actually write some handlers. Note that these functions aren't\n# *themselves* handlers, you call them and they *return* a handler. Handler\n# factory functions, if you will.\n#\n# Here's one that serves up static assets from a directory.\n#\n## ------------------------------------------------------------------------\nstaticHandler <- function(root) {\n  force(root)\n  return(function(req) {\n    if (!identical(req$REQUEST_METHOD, 'GET'))\n      return(NULL)\n\n    path <- req$PATH_INFO\n\n    if (is.null(path))\n      return(httpResponse(400, content=\"<h1>Bad Request\u003c/h1>\"))\n\n    if (path == '/')\n      path <- '/index.html'\n\n    abs.path <- resolve(root, path)\n    if (is.null(abs.path))\n      return(NULL)\n\n    content.type <- getContentType(abs.path)\n    response.content <- readBin(abs.path, 'raw', n=file.info(abs.path)$size)\n    return(httpResponse(200, content.type, response.content))\n  })\n}\n\n#\n# ## Handler manager\n#\n# The handler manager gives you a place to register handlers (of both http and\n# websocket varieties) and provides an httpuv-compatible set of callbacks for\n# invoking them.\n#\n# Create one of these, make zero or more calls to `addHandler` and\n# `addWSHandler` methods (order matters--first one wins!), and then pass the\n# return value of `createHttpuvApp` to httpuv's `startServer` function.\n#\n## ------------------------------------------------------------------------\nHandlerList <- R6Class(\"HandlerList\",\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    handlers = list(),\n\n    add = function(handler, key, tail = FALSE) {\n      if (!is.null(handlers[[key]]))\n        stop(\"Key \", key, \" already in use\")\n      newList <- structure(names=key, list(handler))\n\n      if (length(handlers) == 0)\n        handlers <<- newList\n      else if (tail)\n        handlers <<- c(handlers, newList)\n      else\n        handlers <<- c(newList, handlers)\n    },\n    remove = function(key) {\n      handlers[key] <<- NULL\n    },\n    clear = function() {\n      handlers <<- list()\n    },\n    invoke = function(...) {\n      for (handler in handlers) {\n        result <- handler(...)\n        if (!is.null(result))\n          return(result)\n      }\n      return(NULL)\n    }\n  )\n)\n\nHandlerManager <- R6Class(\"HandlerManager\",\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    handlers = \"HandlerList\",\n    wsHandlers = \"HandlerList\",\n\n    initialize = function() {\n      handlers <<- HandlerList$new()\n      wsHandlers <<- HandlerList$new()\n    },\n\n    addHandler = function(handler, key, tail = FALSE) {\n      handlers$add(handler, key, tail)\n    },\n    removeHandler = function(key) {\n      handlers$remove(key)\n    },\n    addWSHandler = function(wsHandler, key, tail = FALSE) {\n      wsHandlers$add(wsHandler, key, tail)\n    },\n    removeWSHandler = function(key) {\n      wsHandlers$remove(key)\n    },\n    clear = function() {\n      handlers$clear()\n      wsHandlers$clear()\n    },\n    createHttpuvApp = function() {\n      list(\n        onHeaders = function(req) {\n          maxSize <- getOption('shiny.maxRequestSize') %OR% (5 * 1024 * 1024)\n          if (maxSize <= 0)\n            return(NULL)\n\n          reqSize <- 0\n          if (length(req$CONTENT_LENGTH) > 0)\n            reqSize <- as.numeric(req$CONTENT_LENGTH)\n          else if (length(req$HTTP_TRANSFER_ENCODING) > 0)\n            reqSize <- Inf\n\n          if (reqSize > maxSize) {\n            return(list(status = 413L,\n              headers = list(\n                'Content-Type' = 'text/plain'\n              ),\n              body = 'Maximum upload size exceeded'))\n          }\n          else {\n            return(NULL)\n          }\n        },\n        call = .httpServer(\n          function (req) {\n            withLogErrors(handlers$invoke(req))\n          },\n          getOption('shiny.sharedSecret')\n        ),\n        onWSOpen = function(ws) {\n          return(wsHandlers$invoke(ws))\n        }\n      )\n    },\n    .httpServer = function(handler, sharedSecret) {\n      filter <- getOption('shiny.http.response.filter')\n      if (is.null(filter))\n        filter <- function(req, response) response\n\n      function(req) {\n        if (!is.null(sharedSecret)\n          && !identical(sharedSecret, req$HTTP_SHINY_SHARED_SECRET)) {\n          return(list(status=403,\n            body='<h1>403 Forbidden\u003c/h1><p>Shared secret mismatch\u003c/p>',\n            headers=list('Content-Type' = 'text/html')))\n        }\n\n        # Catch HEAD requests. For the purposes of handler functions, they\n        # should be treated like GET. The difference is that  they shouldn't\n        # return a body in the http response.\n        head_request <- FALSE\n        if (identical(req$REQUEST_METHOD, \"HEAD\")) {\n          head_request <- TRUE\n          req$REQUEST_METHOD <- \"GET\"\n        }\n\n        response <- handler(req)\n        if (is.null(response))\n          response <- httpResponse(404, content=\"<h1>Not Found\u003c/h1>\")\n\n        if (inherits(response, \"httpResponse\")) {\n          headers <- as.list(response$headers)\n          headers$'Content-Type' <- response$content_type\n\n          response <- filter(req, response)\n          if (head_request) {\n            headers$`Content-Length` <- nchar(response$content, type = \"bytes\")\n            return(list(\n              status = response$status,\n              body = \"\",\n              headers = headers\n            ))\n          } else {\n            return(list(\n              status = response$status,\n              body = response$content,\n              headers = headers\n            ))\n          }\n\n        } else {\n          # Assume it's a Rook-compatible response\n          return(response)\n        }\n      }\n    }\n  )\n)\n\n#\n# ## Next steps\n#\n# See server.R and middleware-shiny.R to see actual implementation and usage of\n# handlers in the context of Shiny.\n"},{"filename":"htmltools/R/template.R","content":"#' Process an HTML template\n#'\n#' Process an HTML template and return a tagList object. If the template is a\n#' complete HTML document, then the returned object will also have class\n#' \\code{html_document}, and can be passed to the function\n#' \\code{\\link{renderDocument}} to get the final HTML text.\n#'\n#' @param filename Path to an HTML template file. Incompatible with\n#'   \\code{text_}.\n#' @param ... Variable values to use when processing the template.\n#' @param text_ A string to use as the template, instead of a file. Incompatible\n#'   with \\code{filename}.\n#' @param document_ Is this template a complete HTML document (\\code{TRUE}), or\n#'   a fragment of HTML that is to be inserted into an HTML document\n#'   (\\code{FALSE})? With \\code{\"auto\"} (the default), auto-detect by searching\n#'   for the string \\code{\"<HTML>\"} within the template.\n#'\n#' @seealso \\code{\\link{renderDocument}}\n#' @export\n#' @useDynLib htmltools\n#' @importFrom Rcpp sourceCpp\nhtmlTemplate <- function(filename = NULL, ..., text_ = NULL, document_ = \"auto\") {\n  if (!xor(is.null(filename), is.null(text_))) {\n    stop(\"htmlTemplate requires either `filename` or `text_`.\")\n  }\n\n  if (!is.null(filename)) {\n    html <- readChar(filename, file.info(filename)$size, useBytes = TRUE)\n    Encoding(html) <- \"UTF-8\"\n  } else if(!is.null(text_)) {\n    text_ <- paste(text_, collapse = \"\\n\")\n    html <- enc2utf8(text_)\n  }\n\n  pieces <- template_dfa(html)\n\n  # Create environment to evaluate code, as a child of the global env. This\n  # environment gets the ... arguments assigned as variables.\n  vars <- list(...)\n  if (\"headContent\" %in% names(vars)) {\n    stop(\"Can't use reserved argument name 'headContent'.\")\n  }\n  vars$headContent <- function() HTML(\"<!-- HEAD_CONTENT -->\")\n  env <- list2env(vars, parent = globalenv())\n\n  # All the odd-numbered pieces are HTML; all the even-numbered pieces are code\n  pieces <- mapply(\n    pieces,\n    rep_len(c(FALSE, TRUE), length.out = length(pieces)),\n    FUN = function(piece, isCode) {\n      if (isCode) {\n        eval(parse(text = piece), env)\n      } else if (piece == \"\") {\n        # Don't add leading/trailing '\\n' if empty HTML string.\n        NULL\n      } else {\n        HTML(piece)\n      }\n    },\n    SIMPLIFY = FALSE\n  )\n\n\n  result <- tagList(pieces)\n\n  if (document_ == \"auto\") {\n    document_ = grepl(\"<HTML(\\\\s[^<]*)?>\", html, ignore.case = TRUE)\n  }\n  if (document_) {\n    # The html.document class indicates that it's a complete document, and not\n    # just a set of tags.\n    class(result) <- c(\"html_document\", class(result))\n  }\n\n  result\n}\n\n\n#' Render an html_document object\n#'\n#' This function renders \\code{html_document} objects, and returns a string with\n#' the final HTML content. It calls the \\code{\\link{renderTags}} function to\n#' convert any shiny.tag objects to HTML. It also finds any any web dependencies\n#' (created by \\code{\\link{htmlDependency}}) that are attached to the tags, and\n#' inserts those. To do the insertion, this function finds the string\n#' \\code{\"<!-- HEAD_CONTENT -->\"} in the document, and replaces it with the web\n#' dependencies.\n#'\n#' @param x An object of class \\code{html_document}, typically generated by the\n#'   \\code{\\link{htmlTemplate}} function.\n#' @param deps Any extra web dependencies to add to the html document. This can\n#'   be an object created by \\code{\\link{htmlDependency}}, or a list of such\n#'   objects. These dependencies will be added first, before other dependencies.\n#' @param processDep A function that takes a \"raw\" html_dependency object and\n#'   does further processing on it. For example, when \\code{renderDocument} is\n#'   called from Shiny, the function \\code{\\link[shiny]{createWebDependency}} is\n#'   used; it modifies the href and tells Shiny to serve a particular path on\n#'   the filesystem.\n#'\n#' @export\nrenderDocument <- function(x, deps = NULL, processDep = identity) {\n  if (!inherits(x, \"html_document\")) {\n    stop(\"Object must be an object of class html_document\")\n  }\n  if (inherits(deps, \"html_dependency\")) {\n    deps <- list(deps)\n  }\n\n  result <- renderTags(x)\n\n  # Figure out dependencies\n  deps <- c(deps, result$dependencies)\n  deps <- resolveDependencies(deps)\n  deps <- lapply(deps, processDep)\n  depStr <- paste(sapply(deps, function(dep) {\n    sprintf(\"%s[%s]\", dep$name, dep$version)\n  }), collapse = \";\")\n  depHtml <- renderDependencies(deps, \"href\")\n\n  # Put content in the <head> section\n  head_content <- paste0(\n    '  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>',\n    sprintf('  <script type=\"application/shiny-singletons\">%s\u003c/script>',\n            paste(result$singletons, collapse = ',')\n    ),\n    sprintf('  <script type=\"application/html-dependencies\">%s\u003c/script>',\n            depStr\n    ),\n    depHtml,\n    c(result$head, recursive = TRUE)\n  )\n  sub(\"<!-- HEAD_CONTENT -->\", head_content, result$html, fixed = TRUE)\n}\n"},{"filename":"htmltools/R/tags.R","content":"#' @import utils digest\nNULL\n\n# Like base::paste, but converts all string args to UTF-8 first.\npaste8 <- function(..., sep = \" \", collapse = NULL) {\n  args <- c(\n    lapply(list(...), enc2utf8),\n    list(\n      sep = if (is.null(sep)) sep else enc2utf8(sep),\n      collapse = if (is.null(collapse)) collapse else enc2utf8(collapse)\n    )\n  )\n\n  do.call(paste, args)\n}\n\n# Reusable function for registering a set of methods with S3 manually. The\n# methods argument is a list of character vectors, each of which has the form\n# c(package, genname, class).\nregisterMethods <- function(methods) {\n  lapply(methods, function(method) {\n    pkg <- method[[1]]\n    generic <- method[[2]]\n    class <- method[[3]]\n    func <- get(paste(generic, class, sep=\".\"))\n    if (pkg %in% loadedNamespaces()) {\n      registerS3method(generic, class, func, envir = asNamespace(pkg))\n    }\n    setHook(\n      packageEvent(pkg, \"onLoad\"),\n      function(...) {\n        registerS3method(generic, class, func, envir = asNamespace(pkg))\n      }\n    )\n  })\n}\n\n.onLoad <- function(...) {\n  # htmltools provides methods for knitr::knit_print, but knitr isn't a Depends or\n  # Imports of htmltools, only an Enhances. Therefore, the NAMESPACE file has to\n  # declare it as an export, not an S3method. That means that R will only know to\n  # use our methods if htmltools is actually attached, i.e., you have to use\n  # library(htmltools) in a knitr document or else you'll get escaped HTML in your\n  # document. This code snippet manually registers our methods with S3 once both\n  # htmltools and knitr are loaded.\n  registerMethods(list(\n    # c(package, genname, class)\n    c(\"knitr\", \"knit_print\", \"html\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag.list\")\n  ))\n}\n\ndepListToNamedDepList <- function(dependencies) {\n  if (inherits(dependencies, \"html_dependency\"))\n    dependencies <- list(dependencies)\n\n  if (is.null(names(dependencies))) {\n    names(dependencies) <- sapply(dependencies, `[[`, \"name\")\n  }\n  return(dependencies)\n}\n\n#' Resolve a list of dependencies\n#'\n#' Given a list of dependencies, removes any redundant dependencies (based on\n#' name equality). If multiple versions of a dependency are found, the copy with\n#' the latest version number is used.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects.\n#' @return dependencies A list of \\code{\\link{htmlDependency}} objects with\n#'   redundancies removed.\n#'\n#' @export\nresolveDependencies <- function(dependencies) {\n  # Remove nulls\n  deps <- dependencies[!sapply(dependencies, is.null)]\n\n  # Get names and numeric versions in vector/list form\n  depnames <- sapply(deps, `[[`, \"name\")\n  depvers <- numeric_version(sapply(deps, `[[`, \"version\"))\n\n  # Get latest version of each dependency. `unique` uses the first occurrence of\n  # each dependency name, which is important for inter-dependent libraries.\n  return(lapply(unique(depnames), function(depname) {\n    # Sort by depname equality, then by version. Since na.last=NA, all elements\n    # whose names do not match will not be included in the sorted vector.\n    sorted <- order(ifelse(depnames == depname, TRUE, NA), depvers,\n      na.last = NA, decreasing = TRUE)\n    # The first element in the list is the one with the largest version.\n    deps[[sorted[[1]]]]\n  }))\n}\n\n# Remove `remove` from `dependencies` if the name matches.\n# dependencies is a named list of dependencies.\n# remove is a named list of dependencies that take priority.\n# If warnOnConflict, then warn when a dependency is being removed because of an\n# older version already being loaded.\n\n#' Subtract dependencies\n#'\n#' Remove a set of dependencies from another list of dependencies. The set of\n#' dependencies to remove can be expressed as either a character vector or a\n#' list; if the latter, a warning can be emitted if the version of the\n#' dependency being removed is later than the version of the dependency object\n#' that is causing the removal.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects from which\n#'   dependencies should be removed.\n#' @param remove A list of \\code{\\link{htmlDependency}} objects indicating which\n#'   dependencies should be removed, or a character vector indicating dependency\n#'   names.\n#' @param warnOnConflict If \\code{TRUE}, a warning is emitted for each\n#'   dependency that is removed if the corresponding dependency in \\code{remove}\n#'   has a lower version number. Has no effect if \\code{remove} is provided as a\n#'   character vector.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects that don't intersect\n#'   with \\code{remove}.\n#'\n#' @export\nsubtractDependencies <- function(dependencies, remove, warnOnConflict = TRUE) {\n  depnames <- sapply(dependencies, `[[`, \"name\")\n  rmnames <- if (is.character(remove))\n    remove\n  else\n    sapply(remove, `[[`, \"name\")\n\n  matches <- depnames %in% rmnames\n  if (warnOnConflict && !is.character(remove)) {\n    for (loser in dependencies[matches]) {\n      winner <- remove[[head(rmnames == loser$name, 1)]]\n      if (compareVersion(loser$version, winner$version) > 0) {\n        warning(sprintf(paste(\"The dependency %s %s conflicts with\",\n          \"version %s\"), loser$name, loser$version, winner$version\n        ))\n      }\n    }\n  }\n\n  # Return only deps that weren't in remove\n  return(dependencies[!matches])\n}\n\n\n# Given a vector or list, drop all the NULL items in it\ndropNulls <- function(x) {\n  x[!vapply(x, is.null, FUN.VALUE=logical(1))]\n}\n\nnullOrEmpty <- function(x) {\n  is.null(x) || length(x) == 0\n}\n# Given a vector or list, drop all the NULL items in it\ndropNullsOrEmpty <- function(x) {\n  x[!vapply(x, nullOrEmpty, FUN.VALUE=logical(1))]\n}\n\nisTag <- function(x) {\n  inherits(x, \"shiny.tag\")\n}\n\n#' @rdname print.html\n#' @export\nprint.shiny.tag <- function(x, browse = is.browsable(x), ...) {\n  if (browse)\n    html_print(x)\n  else\n    print(as.character(x), ...)\n  invisible(x)\n}\n\n# indent can be numeric to indicate an initial indent level,\n# or FALSE to suppress\n#' @export\nformat.shiny.tag <- function(x, ..., singletons = character(0), indent = 0) {\n  as.character(renderTags(x, singletons = singletons, indent = indent)$html)\n}\n\n#' @export\nas.character.shiny.tag <- function(x, ...) {\n  as.character(renderTags(x)$html)\n}\n\n#' @export\nas.character.html <- function(x, ...) {\n  as.vector(enc2utf8(x))\n}\n\n#' @export\nprint.shiny.tag.list <- print.shiny.tag\n\n#' @export\nformat.shiny.tag.list <- format.shiny.tag\n\n#' @export\nas.character.shiny.tag.list <- as.character.shiny.tag\n\n#' Print method for HTML/tags\n#'\n#' S3 method for printing HTML that prints markup or renders HTML in a web\n#' browser.\n#'\n#' @param x The value to print.\n#' @param browse If \\code{TRUE}, the HTML will be rendered and displayed in a\n#'   browser (or possibly another HTML viewer supplied by the environment via\n#'   the \\code{viewer} option). If \\code{FALSE} then the HTML object's markup\n#'   will be rendered at the console.\n#' @param ... Additional arguments passed to print.\n#'\n#' @export\nprint.html <- function(x, ..., browse = is.browsable(x)) {\n  if (browse)\n    html_print(HTML(x))\n  else\n    cat(x, \"\\n\")\n  invisible(x)\n}\n\n#' @export\nformat.html <- function(x, ...) {\n  as.character(x)\n}\n\nnormalizeText <- function(text) {\n  if (!is.null(attr(text, \"html\", TRUE)))\n    text\n  else\n    htmlEscape(text, attribute=FALSE)\n\n}\n\n#' @name tag\n#' @rdname tag\n#' @export\ntagList <- function(...) {\n  lst <- list(...)\n  class(lst) <- c(\"shiny.tag.list\", \"list\")\n  return(lst)\n}\n\n#' @rdname tag\n#' @export\ntagAppendAttributes <- function(tag, ...) {\n  tag$attribs <- c(tag$attribs, list(...))\n  tag\n}\n\n#' @param attr The name of an attribute.\n#' @rdname tag\n#' @export\ntagHasAttribute <- function(tag, attr) {\n  result <- attr %in% names(tag$attribs)\n  result\n}\n\n#' @rdname tag\n#' @export\ntagGetAttribute <- function(tag, attr) {\n  # Find out which positions in the attributes list correspond to the given attr\n  attribs <- tag$attribs\n  attrIdx <- which(attr == names(attribs))\n\n  if (length(attrIdx) == 0) {\n    return (NULL)\n  }\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  result <- lapply(attribs[attrIdx], as.character)\n  # Separate multiple attributes with the same name\n  result <- paste(result, collapse  = \" \")\n  result\n}\n\n#' @rdname tag\n#' @export\ntagAppendChild <- function(tag, child) {\n  tag$children[[length(tag$children)+1]] <- child\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagAppendChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(tag$children, c(list(...), list))\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagSetChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(list(...), list)\n  tag\n}\n\n#' HTML Tag Object\n#'\n#' \\code{tag()} creates an HTML tag definition. Note that all of the valid HTML5\n#' tags are already defined in the \\code{\\link{tags}} environment so these\n#' functions should only be used to generate additional tags.\n#' \\code{tagAppendChild()} and \\code{tagList()} are for supporting package\n#' authors who wish to create their own sets of tags; see the contents of\n#' bootstrap.R for examples.\n#' @param _tag_name HTML tag name\n#' @param varArgs List of attributes and children of the element. Named list\n#'   items become attributes, and unnamed list items become children. Valid\n#'   children are tags, single-character character vectors (which become text\n#'   nodes), and raw HTML (see \\code{\\link{HTML}}). You can also pass lists that\n#'   contain tags, text nodes, and HTML.\n#' @param tag A tag to append child elements to.\n#' @param child A child element to append to a parent tag.\n#' @param ...  Unnamed items that comprise this list of tags.\n#' @param list An optional list of elements. Can be used with or instead of the\n#'   \\code{...} items.\n#' @return An HTML tag object that can be rendered as HTML using\n#'   \\code{\\link{as.character}()}.\n#' @export\n#' @examples\n#' tagList(tags$h1(\"Title\"),\n#'         tags$h2(\"Header text\"),\n#'         tags$p(\"Text here\"))\n#'\n#' # Can also convert a regular list to a tagList (internal data structure isn't\n#' # exactly the same, but when rendered to HTML, the output is the same).\n#' x <- list(tags$h1(\"Title\"),\n#'           tags$h2(\"Header text\"),\n#'           tags$p(\"Text here\"))\n#' tagList(x)\ntag <- function(`_tag_name`, varArgs) {\n  # Get arg names; if not a named list, use vector of empty strings\n  varArgsNames <- names(varArgs)\n  if (is.null(varArgsNames))\n    varArgsNames <- character(length=length(varArgs))\n\n  # Named arguments become attribs, dropping NULL values\n  named_idx <- nzchar(varArgsNames)\n  attribs <- dropNulls(varArgs[named_idx])\n\n  # Unnamed arguments are flattened and added as children.\n  # Use unname() to remove the names attribute from the list, which would\n  # consist of empty strings anyway.\n  children <- unname(varArgs[!named_idx])\n\n  # Return tag data structure\n  structure(\n    list(name = `_tag_name`,\n      attribs = attribs,\n      children = children),\n    class = \"shiny.tag\"\n  )\n}\n\nisTagList <- function(x) {\n  is.list(x) && (inherits(x, \"shiny.tag.list\") || identical(class(x), \"list\"))\n}\n\ntagWrite <- function(tag, textWriter, indent=0, eol = \"\\n\") {\n\n  if (length(tag) == 0)\n    return (NULL)\n\n  # optionally process a list of tags\n  if (!isTag(tag) && isTagList(tag)) {\n    tag <- dropNullsOrEmpty(flattenTags(tag))\n    lapply(tag, tagWrite, textWriter, indent)\n    return (NULL)\n  }\n\n  nextIndent <- if (is.numeric(indent)) indent + 1 else indent\n  indent <- if (is.numeric(indent)) indent else 0\n\n  # compute indent text\n  indentText <- paste(rep(\" \", indent*2), collapse=\"\")\n\n  # Check if it's just text (may either be plain-text or HTML)\n  if (is.character(tag)) {\n    textWriter(indentText)\n    textWriter(normalizeText(tag))\n    textWriter(eol)\n    return (NULL)\n  }\n\n  # write tag name\n  textWriter(paste8(indentText, \"<\", tag$name, sep=\"\"))\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  attribs <- lapply(tag$attribs, as.character)\n  # concatenate attributes\n  # split() is very slow, so avoid it if possible\n  if (anyDuplicated(names(attribs)))\n    attribs <- lapply(split(attribs, names(attribs)), paste, collapse = \" \")\n\n  # write attributes\n  for (attrib in names(attribs)) {\n    attribValue <- attribs[[attrib]]\n    if (!is.na(attribValue)) {\n      if (is.logical(attribValue))\n        attribValue <- tolower(attribValue)\n      text <- htmlEscape(attribValue, attribute=TRUE)\n      textWriter(paste8(\" \", attrib,\"=\\\"\", text, \"\\\"\", sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\" \", attrib, sep=\"\"))\n    }\n  }\n\n  # write any children\n  children <- dropNullsOrEmpty(flattenTags(tag$children))\n  if (length(children) > 0) {\n    textWriter(\">\")\n\n    # special case for a single child text node (skip newlines and indentation)\n    if ((length(children) == 1) && is.character(children[[1]]) ) {\n      textWriter(paste8(normalizeText(children[[1]]), \"\u003c/\", tag$name, \">\", eol,\n        sep=\"\"))\n    }\n    else {\n      textWriter(\"\\n\")\n      for (child in children)\n        tagWrite(child, textWriter, nextIndent)\n      textWriter(paste8(indentText, \"\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n  else {\n    # only self-close void elements\n    # (see: http://dev.w3.org/html5/spec/single-page.html#void-elements)\n    if (tag$name %in% c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\",\n      \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n      \"source\", \"track\", \"wbr\")) {\n      textWriter(paste8(\"/>\", eol, sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\">\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n}\n\n#' Render tags into HTML\n#'\n#' Renders tags (and objects that can be converted into tags using\n#' \\code{\\link{as.tags}}) into HTML. (Generally intended to be called from web\n#' framework libraries, not directly by most users--see\n#' \\code{\\link{print.html}(browse=TRUE)} for higher level rendering.)\n#'\n#' @param x Tag object(s) to render\n#' @param singletons A list of \\link{singleton} signatures to consider already\n#'   rendered; any matching singletons will be dropped instead of rendered.\n#'   (This is useful (only?) for incremental rendering.)\n#' @param indent Initial indent level, or \\code{FALSE} if no indentation should\n#'   be used.\n#'\n#' @return \\code{renderTags} returns a list with the following variables:\n#' \\describe{\n#'   \\item{\\code{head}}{An \\code{\\link{HTML}} string that should be included in\n#'     \\code{<head>}.\n#'   }\n#'   \\item{\\code{singletons}}{Character vector of singleton signatures that are\n#'     known after rendering.\n#'   }\n#'   \\item{\\code{dependencies}}{A list of \\link[=resolveDependencies]{resolved}\n#'     \\code{\\link{htmlDependency}} objects.\n#'   }\n#'   \\item{\\code{html}}{An \\code{\\link{HTML}} string that represents the main\n#'     HTML that was rendered.\n#'   }\n#' }\n#'\n#' @export\nrenderTags <- function(x, singletons = character(0), indent = 0) {\n  x <- tagify(x)\n  # Do singleton and head processing before rendering\n  singletonInfo <- takeSingletons(x, singletons)\n  headInfo <- takeHeads(singletonInfo$ui)\n  deps <- resolveDependencies(findDependencies(singletonInfo$ui))\n\n  headIndent <- if (is.numeric(indent)) indent + 1 else indent\n  headHtml <- doRenderTags(headInfo$head, indent = headIndent)\n  bodyHtml <- doRenderTags(headInfo$ui, indent = indent)\n\n  return(list(head = headHtml,\n    singletons = singletonInfo$singletons,\n    dependencies = deps,\n    html = bodyHtml))\n}\n\n#' @details \\code{doRenderTags} is intended for very low-level use; it ignores\n#'   singleton, head, and dependency handling, and simply renders the given tag\n#'   objects as HTML.\n#' @return \\code{doRenderTags} returns a simple \\code{\\link{HTML}} string.\n#' @rdname renderTags\n#' @export\ndoRenderTags <- function(x, indent = 0) {\n  # The text that is written to this connWriter will be converted to\n  # UTF-8 using enc2utf8. The rendered output will always be UTF-8\n  # encoded.\n  #\n  # We use a file() here instead of textConnection() or paste/c to\n  # avoid the overhead of copying, which is huge for moderately\n  # large numbers of calls to connWriter(). Generally when you want\n  # to incrementally build up a long string out of immutable ones,\n  # you want to use a mutable/growable string buffer of some kind;\n  # since R doesn't have something like that (that I know of),\n  # file() is the next best thing.\n  conn <- file(open=\"w+b\", encoding = \"UTF-8\")\n  connWriter <- function(text) {\n    text <- enc2utf8(text)\n    # This is actually writing UTF-8 bytes, not chars\n    writeBin(charToRaw(text), conn)\n  }\n  htmlResult <- tryCatch({\n    tagWrite(x, connWriter, indent)\n    flush(conn)\n    readLines(conn, encoding = \"UTF-8\")\n  },\n    finally = close(conn)\n  )\n  return(HTML(paste(htmlResult, collapse = \"\\n\")))\n}\n\n# Walk a tree of tag objects, rewriting objects according to func.\n# preorder=TRUE means preorder tree traversal, that is, an object\n# should be rewritten before its children.\nrewriteTags <- function(ui, func, preorder) {\n  if (preorder)\n    ui <- func(ui)\n\n  if (isTag(ui)) {\n    ui$children[] <- lapply(ui$children, rewriteTags, func, preorder)\n  } else if (isTagList(ui)) {\n    ui[] <- lapply(ui, rewriteTags, func, preorder)\n  }\n\n  if (!preorder)\n    ui <- func(ui)\n\n  return(ui)\n}\n\n#' Singleton manipulation functions\n#'\n#' Functions for manipulating \\code{\\link{singleton}} objects in tag\n#' hierarchies. Intended for framework authors.\n#'\n#' @rdname singleton_tools\n#' @name singleton_tools\nNULL\n\n#' @param ui Tag object or lists of tag objects. See \\link{builder} topic.\n#' @return \\code{surroundSingletons} preprocesses a tag object by changing any\n#'   singleton X into <!--SHINY.SINGLETON[sig]-->X'<!--/SHINY.SINGLETON[sig]-->\n#'   where sig is the sha1 of X, and X' is X minus the singleton attribute.\n#' @rdname singleton_tools\n#' @export\nsurroundSingletons <- local({\n  # In the case of nested singletons, outer singletons are processed\n  # before inner singletons (otherwise the processing of inner\n  # singletons would cause the sha1 of the outer singletons to be\n  # different).\n  surroundSingleton <- function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      uiObj <- singleton(uiObj, FALSE)\n      return(tagList(\n        HTML(sprintf(\"<!--SHINY.SINGLETON[%s]-->\", sig)),\n        uiObj,\n        HTML(sprintf(\"<!--/SHINY.SINGLETON[%s]-->\", sig))\n      ))\n    } else {\n      uiObj\n    }\n  }\n\n  function(ui) {\n    rewriteTags(ui, surroundSingleton, TRUE)\n  }\n})\n\n#' @param singletons Character vector of singleton signatures that have already\n#'   been encountered (i.e. returned from previous calls to\n#'   \\code{takeSingletons}).\n#' @param desingleton Logical value indicating whether singletons that are\n#'   encountered should have the singleton attribute removed.\n#' @return \\code{takeSingletons} returns a list with the elements \\code{ui} (the\n#'   processed tag objects with any duplicate singleton objects removed) and\n#'   \\code{singletons} (the list of known singleton signatures).\n#' @rdname singleton_tools\n#' @export\ntakeSingletons <- function(ui, singletons=character(0), desingleton=TRUE) {\n  result <- rewriteTags(ui, function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      if (sig %in% singletons)\n        return(NULL)\n      singletons <<- append(singletons, sig)\n      if (desingleton)\n        uiObj <- singleton(uiObj, FALSE)\n      return(uiObj)\n    } else {\n      return(uiObj)\n    }\n  }, TRUE)\n\n  return(list(ui=result, singletons=singletons))\n}\n\n# Given a tag object, extract out any children of tags$head\n# and return them separate from the body.\ntakeHeads <- function(ui) {\n  headItems <- list()\n  result <- rewriteTags(ui, function(uiObj) {\n    if (isTag(uiObj) && tolower(uiObj$name) == \"head\") {\n      headItems <<- append(headItems, uiObj$children)\n      return(NULL)\n    }\n    return(uiObj)\n  }, FALSE)\n\n  return(list(ui=result, head=headItems))\n}\n\n#' Collect attached dependencies from HTML tag object\n#'\n#' Walks a hierarchy of tags looking for attached dependencies.\n#'\n#' @param tags A tag-like object to search for dependencies.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects.\n#'\n#' @export\nfindDependencies <- function(tags) {\n  dep <- htmlDependencies(tags)\n  if (!is.null(dep) && inherits(dep, \"html_dependency\"))\n    dep <- list(dep)\n  children <- if (is.list(tags)) {\n    if (isTag(tags)) {\n      tags$children\n    } else {\n      tags\n    }\n  }\n  childDeps <- unlist(lapply(children, findDependencies), recursive = FALSE)\n  c(childDeps, if (!is.null(dep)) dep)\n}\n\n#' HTML Builder Functions\n#'\n#' Simple functions for constructing HTML documents.\n#'\n#' The \\code{tags} environment contains convenience functions for all valid\n#' HTML5 tags. To generate tags that are not part of the HTML5 specification,\n#' you can use the \\code{\\link{tag}()} function.\n#'\n#' Dedicated functions are available for the most common HTML tags that do not\n#' conflict with common R functions.\n#'\n#' The result from these functions is a tag object, which can be converted using\n#' \\code{\\link{as.character}()}.\n#'\n#' @name builder\n#' @param ... Attributes and children of the element. Named arguments become\n#'   attributes, and positional arguments become children. Valid children are\n#'   tags, single-character character vectors (which become text nodes), and raw\n#'   HTML (see \\code{\\link{HTML}}). You can also pass lists that contain tags,\n#'   text nodes, and HTML.\n#' @export tags\n#' @examples\n#' doc <- tags$html(\n#'   tags$head(\n#'     tags$title('My first page')\n#'   ),\n#'   tags$body(\n#'     h1('My first heading'),\n#'     p('My first paragraph, with some ',\n#'       strong('bold'),\n#'       ' text.'),\n#'     div(id='myDiv', class='simpleDiv',\n#'         'Here is a div with some attributes.')\n#'   )\n#' )\n#' cat(as.character(doc))\nNULL\n\n#' @rdname builder\n#' @format NULL\n#' @docType NULL\n#' @keywords NULL\ntags <- list(\n  a = function(...) tag(\"a\", list(...)),\n  abbr = function(...) tag(\"abbr\", list(...)),\n  address = function(...) tag(\"address\", list(...)),\n  area = function(...) tag(\"area\", list(...)),\n  article = function(...) tag(\"article\", list(...)),\n  aside = function(...) tag(\"aside\", list(...)),\n  audio = function(...) tag(\"audio\", list(...)),\n  b = function(...) tag(\"b\", list(...)),\n  base = function(...) tag(\"base\", list(...)),\n  bdi = function(...) tag(\"bdi\", list(...)),\n  bdo = function(...) tag(\"bdo\", list(...)),\n  blockquote = function(...) tag(\"blockquote\", list(...)),\n  body = function(...) tag(\"body\", list(...)),\n  br = function(...) tag(\"br\", list(...)),\n  button = function(...) tag(\"button\", list(...)),\n  canvas = function(...) tag(\"canvas\", list(...)),\n  caption = function(...) tag(\"caption\", list(...)),\n  cite = function(...) tag(\"cite\", list(...)),\n  code = function(...) tag(\"code\", list(...)),\n  col = function(...) tag(\"col\", list(...)),\n  colgroup = function(...) tag(\"colgroup\", list(...)),\n  command = function(...) tag(\"command\", list(...)),\n  data = function(...) tag(\"data\", list(...)),\n  datalist = function(...) tag(\"datalist\", list(...)),\n  dd = function(...) tag(\"dd\", list(...)),\n  del = function(...) tag(\"del\", list(...)),\n  details = function(...) tag(\"details\", list(...)),\n  dfn = function(...) tag(\"dfn\", list(...)),\n  div = function(...) tag(\"div\", list(...)),\n  dl = function(...) tag(\"dl\", list(...)),\n  dt = function(...) tag(\"dt\", list(...)),\n  em = function(...) tag(\"em\", list(...)),\n  embed = function(...) tag(\"embed\", list(...)),\n  eventsource = function(...) tag(\"eventsource\", list(...)),\n  fieldset = function(...) tag(\"fieldset\", list(...)),\n  figcaption = function(...) tag(\"figcaption\", list(...)),\n  figure = function(...) tag(\"figure\", list(...)),\n  footer = function(...) tag(\"footer\", list(...)),\n  form = function(...) tag(\"form\", list(...)),\n  h1 = function(...) tag(\"h1\", list(...)),\n  h2 = function(...) tag(\"h2\", list(...)),\n  h3 = function(...) tag(\"h3\", list(...)),\n  h4 = function(...) tag(\"h4\", list(...)),\n  h5 = function(...) tag(\"h5\", list(...)),\n  h6 = function(...) tag(\"h6\", list(...)),\n  head = function(...) tag(\"head\", list(...)),\n  header = function(...) tag(\"header\", list(...)),\n  hgroup = function(...) tag(\"hgroup\", list(...)),\n  hr = function(...) tag(\"hr\", list(...)),\n  html = function(...) tag(\"html\", list(...)),\n  i = function(...) tag(\"i\", list(...)),\n  iframe = function(...) tag(\"iframe\", list(...)),\n  img = function(...) tag(\"img\", list(...)),\n  input = function(...) tag(\"input\", list(...)),\n  ins = function(...) tag(\"ins\", list(...)),\n  kbd = function(...) tag(\"kbd\", list(...)),\n  keygen = function(...) tag(\"keygen\", list(...)),\n  label = function(...) tag(\"label\", list(...)),\n  legend = function(...) tag(\"legend\", list(...)),\n  li = function(...) tag(\"li\", list(...)),\n  link = function(...) tag(\"link\", list(...)),\n  mark = function(...) tag(\"mark\", list(...)),\n  map = function(...) tag(\"map\", list(...)),\n  menu = function(...) tag(\"menu\", list(...)),\n  meta = function(...) tag(\"meta\", list(...)),\n  meter = function(...) tag(\"meter\", list(...)),\n  nav = function(...) tag(\"nav\", list(...)),\n  noscript = function(...) tag(\"noscript\", list(...)),\n  object = function(...) tag(\"object\", list(...)),\n  ol = function(...) tag(\"ol\", list(...)),\n  optgroup = function(...) tag(\"optgroup\", list(...)),\n  option = function(...) tag(\"option\", list(...)),\n  output = function(...) tag(\"output\", list(...)),\n  p = function(...) tag(\"p\", list(...)),\n  param = function(...) tag(\"param\", list(...)),\n  pre = function(...) tag(\"pre\", list(...)),\n  progress = function(...) tag(\"progress\", list(...)),\n  q = function(...) tag(\"q\", list(...)),\n  ruby = function(...) tag(\"ruby\", list(...)),\n  rp = function(...) tag(\"rp\", list(...)),\n  rt = function(...) tag(\"rt\", list(...)),\n  s = function(...) tag(\"s\", list(...)),\n  samp = function(...) tag(\"samp\", list(...)),\n  script = function(...) tag(\"script\", list(...)),\n  section = function(...) tag(\"section\", list(...)),\n  select = function(...) tag(\"select\", list(...)),\n  small = function(...) tag(\"small\", list(...)),\n  source = function(...) tag(\"source\", list(...)),\n  span = function(...) tag(\"span\", list(...)),\n  strong = function(...) tag(\"strong\", list(...)),\n  style = function(...) tag(\"style\", list(...)),\n  sub = function(...) tag(\"sub\", list(...)),\n  summary = function(...) tag(\"summary\", list(...)),\n  sup = function(...) tag(\"sup\", list(...)),\n  table = function(...) tag(\"table\", list(...)),\n  tbody = function(...) tag(\"tbody\", list(...)),\n  td = function(...) tag(\"td\", list(...)),\n  textarea = function(...) tag(\"textarea\", list(...)),\n  tfoot = function(...) tag(\"tfoot\", list(...)),\n  th = function(...) tag(\"th\", list(...)),\n  thead = function(...) tag(\"thead\", list(...)),\n  time = function(...) tag(\"time\", list(...)),\n  title = function(...) tag(\"title\", list(...)),\n  tr = function(...) tag(\"tr\", list(...)),\n  track = function(...) tag(\"track\", list(...)),\n  u = function(...) tag(\"u\", list(...)),\n  ul = function(...) tag(\"ul\", list(...)),\n  var = function(...) tag(\"var\", list(...)),\n  video = function(...) tag(\"video\", list(...)),\n  wbr = function(...) tag(\"wbr\", list(...))\n)\n\n#' Mark Characters as HTML\n#'\n#' Marks the given text as HTML, which means the \\link{tag} functions will know\n#' not to perform HTML escaping on it.\n#'\n#' @param text The text value to mark with HTML\n#' @param ... Any additional values to be converted to character and\n#'   concatenated together\n#' @return The same value, but marked as HTML.\n#'\n#' @examples\n#' el <- div(HTML(\"I like <u>turtles\u003c/u>\"))\n#' cat(as.character(el))\n#'\n#' @export\nHTML <- function(text, ...) {\n  htmlText <- c(text, as.character(list(...)))\n  htmlText <- paste8(htmlText, collapse=\" \")\n  attr(htmlText, \"html\") <- TRUE\n  class(htmlText) <- c(\"html\", \"character\")\n  htmlText\n}\n\n#' Evaluate an expression using \\code{tags}\n#'\n#' This function makes it simpler to write HTML-generating code. Instead of\n#' needing to specify \\code{tags} each time a tag function is used, as in\n#' \\code{tags$div()} and \\code{tags$p()}, code inside \\code{withTags} is\n#' evaluated with \\code{tags} searched first, so you can simply use\n#' \\code{div()} and \\code{p()}.\n#'\n#' If your code uses an object which happens to have the same name as an\n#' HTML tag function, such as \\code{source()} or \\code{summary()}, it will call\n#' the tag function. To call the intended (non-tags function), specify the\n#' namespace, as in \\code{base::source()} or \\code{base::summary()}.\n#'\n#' @param code A set of tags.\n#'\n#' @examples\n#' # Using tags$ each time\n#' tags$div(class = \"myclass\",\n#'   tags$h3(\"header\"),\n#'   tags$p(\"text\")\n#' )\n#'\n#' # Equivalent to above, but using withTags\n#' withTags(\n#'   div(class = \"myclass\",\n#'     h3(\"header\"),\n#'     p(\"text\")\n#'   )\n#' )\n#'\n#'\n#' @export\nwithTags <- function(code) {\n  eval(substitute(code), envir = as.list(tags), enclos = parent.frame())\n}\n\n# Make sure any objects in the tree that can be converted to tags, have been\ntagify <- function(x) {\n  rewriteTags(x, function(uiObj) {\n    if (isTag(uiObj) || isTagList(uiObj) || is.character(uiObj))\n      return(uiObj)\n    else\n      return(tagify(as.tags(uiObj)))\n  }, FALSE)\n}\n\n# Given a list of tags, lists, and other items, return a flat list, where the\n# items from the inner, nested lists are pulled to the top level, recursively.\nflattenTags <- function(x) {\n  if (isTag(x)) {\n    # For tags, wrap them into a list (which will be unwrapped by caller)\n    list(x)\n  } else if (isTagList(x)) {\n    if (length(x) == 0) {\n      # Empty lists are simply returned\n      x\n    } else {\n      # For items that are lists (but not tags), recurse\n      unlist(lapply(x, flattenTags), recursive = FALSE)\n    }\n\n  } else if (is.character(x)){\n    # This will preserve attributes if x is a character with attribute,\n    # like what HTML() produces\n    list(x)\n\n  } else {\n    # For other items, coerce to character and wrap them into a list (which\n    # will be unwrapped by caller). Note that this will strip attributes.\n    flattenTags(as.tags(x))\n  }\n}\n\n#' Convert a value to tags\n#'\n#' An S3 method for converting arbitrary values to a value that can be used as\n#' the child of a tag or \\code{tagList}. The default implementation simply calls\n#' \\code{\\link[base]{as.character}}.\n#'\n#' @param x Object to be converted.\n#' @param ... Any additional parameters.\n#'\n#' @export\nas.tags <- function(x, ...) {\n  UseMethod(\"as.tags\")\n}\n\n#' @export\nas.tags.default <- function(x, ...) {\n  if (is.list(x) && !isTagList(x))\n    unclass(x)\n  else\n    tagList(as.character(x))\n}\n\n#' @export\nas.tags.html <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag.list <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.character <- function(x, ...) {\n  # For printing as.tags(\"<strong>\") directly at console, without dropping any\n  # attached dependencies\n  tagList(x)\n}\n\n#' Preserve HTML regions\n#'\n#' Use \"magic\" HTML comments to protect regions of HTML from being modified by\n#' text processing tools.\n#'\n#' Text processing tools like markdown and pandoc are designed to turn\n#' human-friendly markup into common output formats like HTML. This works well\n#' for most prose, but components that generate their own HTML may break if\n#' their markup is interpreted as the input language. The \\code{htmlPreserve}\n#' function is used to mark regions of an input document as containing pure HTML\n#' that must not be modified. This is achieved by substituting each such region\n#' with a benign but unique string before processing, and undoing those\n#' substitutions after processing.\n#'\n#' @param x A character vector of HTML to be preserved.\n#'\n#' @return \\code{htmlPreserve} returns a single-element character vector with\n#'   \"magic\" HTML comments surrounding the original text (unless the original\n#'   text was empty, in which case an empty string is returned).\n#'\n#' @examples\n#' # htmlPreserve will prevent \"<script>alert(10*2*3);\u003c/script>\"\n#' # from getting an <em> tag inserted in the middle\n#' markup <- paste(sep = \"\\n\",\n#'   \"This is *emphasized* text in markdown.\",\n#'   htmlPreserve(\"<script>alert(10*2*3);\u003c/script>\"),\n#'   \"Here is some more *emphasized text*.\"\n#' )\n#' extracted <- extractPreserveChunks(markup)\n#' markup <- extracted$value\n#' # Just think of this next line as Markdown processing\n#' output <- gsub(\"\\\\*(.*?)\\\\*\", \"<em>\\\\1\u003c/em>\", markup)\n#' output <- restorePreserveChunks(output, extracted$chunks)\n#' output\n#'\n#' @export\nhtmlPreserve <- function(x) {\n  x <- paste(x, collapse = \"\\r\\n\")\n  if (nzchar(x))\n    sprintf(\"<!--html_preserve-->%s<!--/html_preserve-->\", x)\n  else\n    x\n}\n\n# Temporarily set x in env to value, evaluate expr, and\n# then restore x to its original state\nwithTemporary <- function(env, x, value, expr, unset = FALSE) {\n\n  if (exists(x, envir = env, inherits = FALSE)) {\n    oldValue <- get(x, envir = env, inherits = FALSE)\n    on.exit(\n      assign(x, oldValue, envir = env, inherits = FALSE),\n      add = TRUE)\n  } else {\n    on.exit(\n      rm(list = x, envir = env, inherits = FALSE),\n      add = TRUE\n    )\n  }\n\n  if (!missing(value) && !isTRUE(unset))\n    assign(x, value, envir = env, inherits = FALSE)\n  else {\n    if (exists(x, envir = env, inherits = FALSE))\n      rm(list = x, envir = env, inherits = FALSE)\n  }\n  force(expr)\n}\n\n# Evaluate an expression using Shiny's own private stream of\n# randomness (not affected by set.seed).\nwithPrivateSeed <- local({\n  ownSeed <- NULL\n  function(expr) {\n    withTemporary(.GlobalEnv, \".Random.seed\",\n      ownSeed, unset=is.null(ownSeed), {\n        tryCatch({\n          expr\n        }, finally = {ownSeed <<- .Random.seed})\n      }\n    )\n  }\n})\n\n# extract_preserve_chunks looks for regions in strval marked by\n# <!--html_preserve-->...<!--/html_preserve--> and replaces each such region\n# with a long unique ID. The return value is a list with $value as the string\n# with the regions replaced, and $chunks as a named character vector where the\n# names are the IDs and the values are the regions that were extracted.\n#\n# Nested regions are handled appropriately; the outermost region is what's used\n# and any inner regions simply have their boundaries removed before the values\n# are stashed in $chunks.\n\n#' @return \\code{extractPreserveChunks} returns a list with two named elements:\n#'   \\code{value} is the string with the regions replaced, and \\code{chunks} is\n#'   a named character vector where the names are the IDs and the values are the\n#'   regions that were extracted.\n#' @rdname htmlPreserve\n#' @export\nextractPreserveChunks <- function(strval) {\n\n  # Literal start/end marker text. Case sensitive.\n  startmarker <- \"<!--html_preserve-->\"\n  endmarker <- \"<!--/html_preserve-->\"\n  # Start and end marker length MUST be different, it's how we tell them apart\n  startmarker_len <- nchar(startmarker)\n  endmarker_len <- nchar(endmarker)\n  # Pattern must match both start and end markers\n  pattern <- \"<!--/?html_preserve-->\"\n\n  # It simplifies string handling greatly to collapse multiple char elements\n  if (length(strval) != 1)\n    strval <- paste(strval, collapse = \"\\n\")\n\n  # matches contains the index of all the start and end markers\n  matches <- gregexpr(pattern, strval)[[1]]\n  lengths <- attr(matches, \"match.length\", TRUE)\n\n  # No markers? Just return.\n  if (matches[[1]] == -1)\n    return(list(value = strval, chunks = character(0)))\n\n  # If TRUE, it's a start; if FALSE, it's an end\n  boundary_type <- lengths == startmarker_len\n\n  # Positive number means we're inside a region, zero means we just exited to\n  # the top-level, negative number means error (an end without matching start).\n  # For example:\n  # boundary_type - TRUE TRUE FALSE FALSE TRUE FALSE\n  # preserve_level - 1 2 1 0 1 0\n  preserve_level <- cumsum(ifelse(boundary_type, 1, -1))\n\n  # Sanity check.\n  if (any(preserve_level < 0) || tail(preserve_level, 1) != 0) {\n    stop(\"Invalid nesting of html_preserve directives\")\n  }\n\n  # Identify all the top-level boundary markers. We want to find all of the\n  # elements of preserve_level whose value is 0 and preceding value is 1, or\n  # whose value is 1 and preceding value is 0. Since we know that preserve_level\n  # values can only go up or down by 1, we can simply shift preserve_level by\n  # one element and add it to preserve_level; in the result, any value of 1 is a\n  # match.\n  is_top_level <- 1 == (preserve_level + c(0, preserve_level[-length(preserve_level)]))\n\n  preserved <- character(0)\n\n  top_level_matches <- matches[is_top_level]\n  # Iterate backwards so string mutation doesn't screw up positions for future\n  # iterations\n  for (i in seq.int(length(top_level_matches) - 1, 1, by = -2)) {\n    start_outer <- top_level_matches[[i]]\n    start_inner <- start_outer + startmarker_len\n    end_inner <- top_level_matches[[i+1]]\n    end_outer <- end_inner + endmarker_len\n\n    id <- withPrivateSeed(\n      paste(\"preserve\", paste(\n        format(as.hexmode(sample(256, 8, replace = TRUE)-1), width=2),\n        collapse = \"\"),\n        sep = \"\")\n    )\n\n    preserved[id] <- gsub(pattern, \"\", substr(strval, start_inner, end_inner-1))\n\n    strval <- paste(\n      substr(strval, 1, start_outer - 1),\n      id,\n      substr(strval, end_outer, nchar(strval)),\n      sep=\"\")\n    substr(strval, start_outer, end_outer-1) <- id\n  }\n\n  list(value = strval, chunks = preserved)\n}\n\n#' @param strval Input string from which to extract/restore chunks.\n#' @param chunks The \\code{chunks} element of the return value of\n#'   \\code{extractPreserveChunks}.\n#' @return \\code{restorePreserveChunks} returns a character vector with the\n#'   chunk IDs replaced with their original values.\n#' @rdname htmlPreserve\n#' @export\nrestorePreserveChunks <- function(strval, chunks) {\n  for (id in names(chunks))\n    strval <- gsub(id, chunks[[id]], strval, fixed = TRUE, useBytes = TRUE)\n  strval\n}\n\n#' Knitr S3 methods\n#'\n#' These S3 methods are necessary to allow HTML tags to print themselves in\n#' knitr/rmarkdown documents.\n#'\n#' @name knitr_methods\n#' @param x Object to knit_print\n#' @param ... Additional knit_print arguments\nNULL\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag <- function(x, ...) {\n  x <- tagify(x)\n  output <- surroundSingletons(x)\n  deps <- resolveDependencies(findDependencies(x))\n  content <- takeHeads(output)\n  head_content <- doRenderTags(tagList(content$head))\n\n  meta <- if (length(head_content) > 1 || head_content != \"\") {\n    list(structure(head_content, class = \"shiny_head\"))\n  }\n  meta <- c(meta, deps)\n\n  knitr::asis_output(\n    htmlPreserve(format(content$ui, indent=FALSE)),\n    meta = meta)\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.html <- function(x, ...) {\n  deps <- resolveDependencies(findDependencies(x))\n  knitr::asis_output(htmlPreserve(as.character(x)),\n    meta = if (length(deps)) list(deps))\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag.list <- knit_print.shiny.tag\n\n\n\n#' @rdname builder\n#' @export\np <- function(...) tags$p(...)\n\n#' @rdname builder\n#' @export\nh1 <- function(...) tags$h1(...)\n\n#' @rdname builder\n#' @export\nh2 <- function(...) tags$h2(...)\n\n#' @rdname builder\n#' @export\nh3 <- function(...) tags$h3(...)\n\n#' @rdname builder\n#' @export\nh4 <- function(...) tags$h4(...)\n\n#' @rdname builder\n#' @export\nh5 <- function(...) tags$h5(...)\n\n#' @rdname builder\n#' @export\nh6 <- function(...) tags$h6(...)\n\n#' @rdname builder\n#' @export\na <- function(...) tags$a(...)\n\n#' @rdname builder\n#' @export\nbr <- function(...) tags$br(...)\n\n#' @rdname builder\n#' @export\ndiv <- function(...) tags$div(...)\n\n#' @rdname builder\n#' @export\nspan <- function(...) tags$span(...)\n\n#' @rdname builder\n#' @export\npre <- function(...) tags$pre(...)\n\n#' @rdname builder\n#' @export\ncode <- function(...) tags$code(...)\n\n#' @rdname builder\n#' @export\nimg <- function(...) tags$img(...)\n\n#' @rdname builder\n#' @export\nstrong <- function(...) tags$strong(...)\n\n#' @rdname builder\n#' @export\nem <- function(...) tags$em(...)\n\n#' @rdname builder\n#' @export\nhr <- function(...) tags$hr(...)\n\n#' Include Content From a File\n#'\n#' Load HTML, text, or rendered Markdown from a file and turn into HTML.\n#'\n#' These functions provide a convenient way to include an extensive amount of\n#' HTML, textual, Markdown, CSS, or JavaScript content, rather than using a\n#' large literal R string.\n#'\n#' @param path The path of the file to be included. It is highly recommended to\n#'   use a relative path (the base path being the Shiny application directory),\n#'   not an absolute path.\n#'\n#' @rdname include\n#' @name include\n#' @aliases includeHTML\n#' @export\nincludeHTML <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(HTML(paste8(lines, collapse='\\r\\n')))\n}\n\n#' @note \\code{includeText} escapes its contents, but does no other processing.\n#'   This means that hard breaks and multiple spaces will be rendered as they\n#'   usually are in HTML: as a single space character. If you are looking for\n#'   preformatted text, wrap the call with \\code{\\link{pre}}, or consider using\n#'   \\code{includeMarkdown} instead.\n#'\n#' @rdname include\n#' @export\nincludeText <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(paste8(lines, collapse='\\r\\n'))\n}\n\n#' @note The \\code{includeMarkdown} function requires the \\code{markdown}\n#'   package.\n#' @rdname include\n#' @export\nincludeMarkdown <- function(path) {\n  html <- markdown::markdownToHTML(path, fragment.only=TRUE)\n  Encoding(html) <- 'UTF-8'\n  return(HTML(html))\n}\n\n#' @param ... Any additional attributes to be applied to the generated tag.\n#' @rdname include\n#' @export\nincludeCSS <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  args <- list(...)\n  if (is.null(args$type))\n    args$type <- 'text/css'\n  return(do.call(tags$style,\n    c(list(HTML(paste8(lines, collapse='\\r\\n'))), args)))\n}\n\n#' @rdname include\n#' @export\nincludeScript <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(tags$script(HTML(paste8(lines, collapse='\\r\\n')), ...))\n}\n\n#' Include content only once\n#'\n#' Use \\code{singleton} to wrap contents (tag, text, HTML, or lists) that should\n#' be included in the generated document only once, yet may appear in the\n#' document-generating code more than once. Only the first appearance of the\n#' content (in document order) will be used.\n#'\n#' @param x A \\code{\\link{tag}}, text, \\code{\\link{HTML}}, or list.\n#' @param value Whether the object should be a singleton.\n#'\n#' @export\nsingleton <- function(x, value = TRUE) {\n  attr(x, \"htmltools.singleton\") <- if (isTRUE(value)) TRUE else NULL\n  return(x)\n}\n\n#' @rdname singleton\n#' @export\nis.singleton <- function(x) {\n  isTRUE(attr(x, \"htmltools.singleton\"))\n}\n\n\n#' Validate proper CSS formatting of a unit\n#'\n#' Checks that the argument is valid for use as a CSS unit of length.\n#'\n#' \\code{NULL} and \\code{NA} are returned unchanged.\n#'\n#' Single element numeric vectors are returned as a character vector with the\n#' number plus a suffix of \\code{\"px\"}.\n#'\n#' Single element character vectors must be \\code{\"auto\"} or \\code{\"inherit\"},\n#' or a number. If the number has a suffix, it must be valid: \\code{px},\n#' \\code{\\%}, \\code{em}, \\code{pt}, \\code{in}, \\code{cm}, \\code{mm}, \\code{ex},\n#' or \\code{pc}. If the number has no suffix, the suffix \\code{\"px\"} is\n#' appended.\n#'\n#' Any other value will cause an error to be thrown.\n#'\n#' @param x The unit to validate. Will be treated as a number of pixels if a\n#'   unit is not specified.\n#' @return A properly formatted CSS unit of length, if possible. Otherwise, will\n#'   throw an error.\n#' @examples\n#' validateCssUnit(\"10%\")\n#' validateCssUnit(400)  #treated as '400px'\n#' @export\nvalidateCssUnit <- function(x) {\n  if (is.null(x) || is.na(x))\n    return(x)\n\n  if (length(x) > 1 || (!is.character(x) && !is.numeric(x)))\n    stop('CSS units must be a single-element numeric or character vector')\n\n  # if the input is a character vector consisting only of digits (e.g. \"960\"),\n  # coerce it to a numeric value\n  if (is.character(x) && nchar(x) > 0 && gsub(\"\\\\d*\", \"\", x) == \"\")\n    x <- as.numeric(x)\n\n  pattern <-\n    \"^(auto|inherit|((\\\\.\\\\d+)|(\\\\d+(\\\\.\\\\d+)?))(%|in|cm|mm|em|ex|pt|pc|px))$\"\n\n  if (is.character(x) &&\n      !grepl(pattern, x)) {\n    stop('\"', x, '\" is not a valid CSS unit (e.g., \"100%\", \"400px\", \"auto\")')\n  } else if (is.numeric(x)) {\n    x <- paste(x, \"px\", sep = \"\")\n  }\n  x\n}\n\n#' CSS string helper\n#'\n#' Convenience function for building CSS style declarations (i.e. the string\n#' that goes into a style attribute, or the parts that go inside curly braces in\n#' a full stylesheet).\n#'\n#' CSS uses \\code{'-'} (minus) as a separator character in property names, but\n#' this is an inconvenient character to use in an R function argument name.\n#' Instead, you can use \\code{'.'} (period) and/or \\code{'_'} (underscore) as\n#' separator characters. For example, \\code{css(font.size = \"12px\")} yields\n#' \\code{\"font-size:12px;\"}.\n#'\n#' To mark a property as \\code{!important}, add a \\code{'!'} character to the end\n#' of the property name. (Since \\code{'!'} is not normally a character that can be\n#' used in an identifier in R, you'll need to put the name in double quotes or\n#' backticks.)\n#'\n#' Argument values will be converted to strings using\n#' \\code{paste(collapse = \" \")}. Any property with a value of \\code{NULL} or\n#' \\code{\"\"} (after paste) will be dropped.\n#'\n#' @param ... Named style properties, where the name is the property name and\n#'   the argument is the property value. See Details for conversion rules.\n#' @param collapse_ (Note that the parameter name has a trailing underscore\n#'   character.) Character to use to collapse properties into a single string;\n#'   likely \\code{\"\"} (the default) for style attributes, and either \\code{\"\\n\"}\n#'   or \\code{NULL} for style blocks.\n#'\n#' @examples\n#' padding <- 6\n#' css(\n#'   font.family = \"Helvetica, sans-serif\",\n#'   margin = paste0(c(10, 20, 10, 20), \"px\"),\n#'   \"padding!\" = if (!is.null(padding)) padding\n#' )\n#'\n#' @export\ncss <- function(..., collapse_ = \"\") {\n  props <- list(...)\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  if (is.null(names(props)) || any(names(props) == \"\")) {\n    stop(\"cssList expects all arguments to be named\")\n  }\n\n  # Necessary to make factors show up as level names, not numbers\n  props[] <- lapply(props, paste, collapse = \" \")\n\n  # Drop null args\n  props <- props[!sapply(props, empty)]\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  # Replace all '.' and '_' in property names to '-'\n  names(props) <- gsub(\"[._]\", \"-\", tolower(gsub(\"([A-Z])\", \"-\\\\1\", names(props))))\n\n  # Create \"!important\" suffix for each property whose name ends with !, then\n  # remove the ! from the property name\n  important <- ifelse(grepl(\"!$\", names(props), perl = TRUE), \" !important\", \"\")\n  names(props) <- sub(\"!$\", \"\", names(props), perl = TRUE)\n\n  paste0(names(props), \":\", props, important, \";\", collapse = collapse_)\n}\n\nempty <- function(x) {\n  length(x) == 0 || (is.character(x) && !any(nzchar(x)))\n}\n"},{"filename":"/R/shiny.R","content":"#' @include utils.R stack.R\nNULL\n\n#' Web Application Framework for R\n#'\n#' Shiny makes it incredibly easy to build interactive web applications with R.\n#' Automatic \"reactive\" binding between inputs and outputs and extensive\n#' pre-built widgets make it possible to build beautiful, responsive, and\n#' powerful applications with minimal effort.\n#'\n#' The Shiny tutorial at \\url{http://shiny.rstudio.com/tutorial/} explains\n#' the framework in depth, walks you through building a simple application, and\n#' includes extensive annotated examples.\n#'\n#' @seealso \\link{shiny-options} for documentation about global options.\n#'\n#' @name shiny-package\n#' @aliases shiny\n#' @docType package\n#' @import htmltools httpuv xtable digest R6 mime\nNULL\n\n# It's necessary to Depend on methods so Rscript doesn't fail. It's necessary\n# to import(methods) in NAMESPACE so R CMD check doesn't complain. This\n# approach isn't foolproof because Rscript -e pkgname::func() doesn't actually\n# cause methods to be attached, but it's not a problem for shiny::runApp()\n# since we call require(shiny) as part of loading the app.\n#' @import methods\nNULL\n\n\n#' Global options for Shiny\n#'\n#' There are a number of global options that affect Shiny's behavior. These can\n#' be set with (for example) \\code{options(shiny.trace=TRUE)}.\n#'\n#' \\describe{\n#'   \\item{shiny.launch.browser}{A boolean which controls the default behavior\n#'     when an app is run. See \\code{\\link{runApp}} for more information.}\n#'   \\item{shiny.port}{A port number that Shiny will listen on. See\n#'     \\code{\\link{runApp}} for more information.}\n#'   \\item{shiny.trace}{If \\code{TRUE}, all of the messages sent between the R\n#'     server and the web browser client will be printed on the console. This\n#'     is useful for debugging.}\n#'   \\item{shiny.autoreload}{If \\code{TRUE} when a Shiny app is launched, the\n#'     app directory will be continually monitored for changes to files that\n#'     have the extensions: r, htm, html, js, css, png, jpg, jpeg, gif. If any\n#'     changes are detected, all connected Shiny sessions are reloaded. This\n#'     allows for fast feedback loops when tweaking Shiny UI.\n#'\n#'     Since monitoring for changes is expensive (we simply poll for last\n#'     modified times), this feature is intended only for development.\n#'\n#'     You can customize the file patterns Shiny will monitor by setting the\n#'     shiny.autoreload.pattern option. For example, to monitor only ui.R:\n#'     \\code{option(shiny.autoreload.pattern = glob2rx(\"ui.R\"))}\n#'\n#'     The default polling interval is 500 milliseconds. You can change this\n#'     by setting e.g. \\code{option(shiny.autoreload.interval = 2000)} (every\n#'     two seconds).}\n#'   \\item{shiny.reactlog}{If \\code{TRUE}, enable logging of reactive events,\n#'     which can be viewed later with the \\code{\\link{showReactLog}} function.\n#'     This incurs a substantial performance penalty and should not be used in\n#'     production.}\n#'   \\item{shiny.usecairo}{This is used to disable graphical rendering by the\n#'     Cairo package, if it is installed. See \\code{\\link{plotPNG}} for more\n#'     information.}\n#'   \\item{shiny.maxRequestSize}{This is a number which specifies the maximum\n#'     web request size, which serves as a size limit for file uploads. If\n#'     unset, the maximum request size defaults to 5MB.}\n#'   \\item{shiny.suppressMissingContextError}{Normally, invoking a reactive\n#'     outside of a reactive context (or \\code{\\link{isolate}()}) results in\n#'     an error. If this is \\code{TRUE}, don't error in these cases. This\n#'     should only be used for debugging or demonstrations of reactivity at the\n#'     console.}\n#'   \\item{shiny.host}{The IP address that Shiny should listen on. See\n#'     \\code{\\link{runApp}} for more information.}\n#'   \\item{shiny.json.digits}{The number of digits to use when converting\n#'     numbers to JSON format to send to the client web browser.}\n#'   \\item{shiny.minified}{If this is \\code{TRUE} or unset (the default), then\n#'     Shiny will use minified JavaScript (\\code{shiny.min.js}). If\n#'     \\code{FALSE}, then Shiny will use the un-minified JavaScript\n#'     (\\code{shiny.js}); this can be useful during development.}\n#'   \\item{shiny.error}{This can be a function which is called when an error\n#'     occurs. For example, \\code{options(shiny.error=recover)} will result a\n#'     the debugger prompt when an error occurs.}\n#'   \\item{shiny.table.class}{CSS class names to use for tables.}\n#'   \\item{shiny.deprecation.messages}{This controls whether messages for\n#'     deprecated functions in Shiny will be printed. See\n#'     \\code{\\link{shinyDeprecated}} for more information.}\n#'   \\item{shiny.fullstacktrace}{Controls whether \"pretty\" or full stack traces\n#'     are dumped to the console when errors occur during Shiny app execution.\n#'     The default is \\code{FALSE} (pretty stack traces).}\n#'   \\item{shiny.stacktraceoffset}{If \\code{TRUE}, then Shiny's printed stack\n#'     traces will display srcrefs one line above their usual location. This is\n#'     an arguably more intuitive arrangement for casual R users, as the name\n#'     of a function appears next to the srcref where it is defined, rather than\n#'     where it is currently being called from.}\n#' }\n#' @name shiny-options\nNULL\ncreateUniqueId <- function(bytes, prefix = \"\", suffix = \"\") {\n  withPrivateSeed({\n    paste(\n      prefix,\n      paste(\n        format(as.hexmode(sample(256, bytes, replace = TRUE)-1), width=2),\n        collapse = \"\"),\n      suffix,\n      sep = \"\"\n    )\n  })\n}\n\ntoJSON <- function(x, ...,  dataframe = \"columns\", null = \"null\", na = \"null\",\n  auto_unbox = TRUE, digits = getOption(\"shiny.json.digits\", 16),\n  use_signif = TRUE, force = TRUE, POSIXt = \"ISO8601\", UTC = TRUE,\n  rownames = FALSE, keep_vec_names = TRUE) {\n\n  # I(x) is so that length-1 atomic vectors get put in [].\n  jsonlite::toJSON(I(x), dataframe = dataframe, null = null, na = na,\n   auto_unbox = auto_unbox, digits = digits, use_signif = use_signif,\n   force = force, POSIXt = POSIXt, UTC = UTC, rownames = rownames,\n   keep_vec_names = keep_vec_names, json_verbatim = TRUE, ...)\n}\n\n# Call the workerId func with no args to get the worker id, and with an arg to\n# set it.\n#\n# A worker ID is an opaque string that is passed in by the caller. The ID is\n# added as a URL parameter (?w=<worker_id>) to any URLs that need to refer back\n# to the app. This can be used as a hint for load balancers to direct requests\n# to this particular process. Since the worker refers to a process, it's\n# inherently global, and should never need to change.\nworkerId <- local({\n  .workerId <- NULL\n  function(value) {\n    if (missing(value)) {\n      .workerId\n    } else {\n      if (!is.null(.workerId)) {\n        if (!identical(value, .workerId)) {\n          warning(\"Ignoring workerId value--\",\n            \"it's already been set to a different value\")\n        }\n      } else {\n        .workerId <<- value\n      }\n    }\n  }\n})\n\n#' Session object\n#'\n#' Shiny server functions can optionally include \\code{session} as a parameter\n#' (e.g. \\code{function(input, output, session)}). The session object is an\n#' environment that can be used to access information and functionality\n#' relating to the session. The following list describes the items available\n#' in the environment; they can be accessed using the \\code{$} operator (for\n#' example, \\code{session$clientData$url_search}).\n#'\n#' @return\n#' \\item{clientData}{\n#'   A \\code{\\link{reactiveValues}} object that contains information about the client.\n#'   \\itemize{\n#'     \\item{\\code{allowDataUriScheme} is a logical value that indicates whether\n#'       the browser is able to handle URIs that use the \\code{data:} scheme.\n#'     }\n#'     \\item{\\code{pixelratio} reports the \"device pixel ratio\" from the web browser,\n#'       or 1 if none is reported. The value is 2 for Apple Retina displays.\n#'     }\n#'     \\item{\\code{singletons} - for internal use}\n#'     \\item{\\code{url_protocol}, \\code{url_hostname}, \\code{url_port},\n#'       \\code{url_pathname}, \\code{url_search}, and \\code{url_hash_initial}\n#'       can be used to get the components of the URL that was requested by the\n#'       browser to load the Shiny app page. These values are from the\n#'       browser's perspective, so neither HTTP proxies nor Shiny Server will\n#'       affect these values. The \\code{url_search} value may be used with\n#'       \\code{\\link{parseQueryString}} to access query string parameters.\n#'     }\n#'   }\n#'   \\code{clientData} also contains information about each output.\n#'   \\code{output_\\var{outputId}_width} and \\code{output_\\var{outputId}_height}\n#'   give the dimensions (using \\code{offsetWidth} and \\code{offsetHeight}) of\n#'   the DOM element that is bound to \\code{\\var{outputId}}, and\n#'   \\code{output_\\var{outputId}_hidden} is a logical that indicates whether\n#'   the element is hidden. These values may be \\code{NULL} if the output is\n#'   not bound.\n#' }\n#' \\item{input}{\n#'   The session's \\code{input} object (the same as is passed into the Shiny\n#'   server function as an argument).\n#' }\n#' \\item{isClosed()}{A function that returns \\code{TRUE} if the client has\n#'   disconnected.\n#' }\n#' \\item{onEnded(callback)}{\n#'   Synonym for \\code{onSessionEnded}.\n#' }\n#' \\item{onFlush(func, once=TRUE)}{\n#'   Registers a function to be called before the next time (if \\code{once=TRUE})\n#'   or every time (if \\code{once=FALSE}) Shiny flushes the reactive system.\n#'   Returns a function that can be called with no arguments to cancel the\n#'   registration.\n#' }\n#' \\item{onFlushed(func, once=TRUE)}{\n#'   Registers a function to be called after the next time (if \\code{once=TRUE})\n#'   or every time (if \\code{once=FALSE}) Shiny flushes the reactive system.\n#'   Returns a function that can be called with no arguments to cancel the\n#'   registration.\n#' }\n#' \\item{onSessionEnded(callback)}{\n#'   Registers a function to be called after the client has disconnected.\n#'   Returns a function that can be called with no arguments to cancel the\n#'   registration.\n#' }\n#' \\item{output}{\n#'   The session's \\code{output} object (the same as is passed into the Shiny\n#'   server function as an argument).\n#' }\n#' \\item{reactlog}{\n#'   For internal use.\n#' }\n#' \\item{registerDataObj(name, data, filterFunc)}{\n#'   Publishes any R object as a URL endpoint that is unique to this session.\n#'   \\code{name} must be a single element character vector; it will be used\n#'   to form part of the URL. \\code{filterFunc} must be a function that takes\n#'   two arguments: \\code{data} (the value that was passed into\n#'   \\code{registerDataObj}) and \\code{req} (an environment that implements\n#'   the Rook specification for HTTP requests). \\code{filterFunc} will be\n#'   called with these values whenever an HTTP request is made to the URL\n#'   endpoint. The return value of \\code{filterFunc} should be a Rook-style\n#'   response.\n#' }\n#' \\item{reload()}{\n#'   The equivalent of hitting the browser's Reload button. Only works if the\n#'   session is actually connected.\n#' }\n#' \\item{request}{\n#'   An environment that implements the Rook specification for HTTP requests.\n#'   This is the request that was used to initiate the websocket connection\n#'   (as opposed to the request that downloaded the web page for the app).\n#' }\n#' \\item{sendCustomMessage(type, message)}{\n#'   Sends a custom message to the web page. \\code{type} must be a\n#'   single-element character vector giving the type of message, while\n#'   \\code{message} can be any jsonlite-encodable value. Custom messages\n#'   have no meaning to Shiny itself; they are used soley to convey information\n#'   to custom JavaScript logic in the browser. You can do this by adding\n#'   JavaScript code to the browser that calls\n#'   \\code{Shiny.addCustomMessageHandler(type, function(message){...})}\n#'   as the page loads; the function you provide to\n#'   \\code{addCustomMessageHandler} will be invoked each time\n#'   \\code{sendCustomMessage} is called on the server.\n#' }\n#' \\item{sendInputMessage(inputId, message)}{\n#'   Sends a message to an input on the session's client web page; if the input\n#'   is present and bound on the page at the time the message is received, then\n#'   the input binding object's \\code{receiveMessage(el, message)} method will\n#'   be called. \\code{sendInputMessage} should generally not be called directly\n#'   from Shiny apps, but through friendlier wrapper functions like\n#'   \\code{\\link{updateTextInput}}.\n#' }\n#' \\item{ns(id)}{\n#'   Server-side version of \\code{ns <- \\link{NS}(id)}. If bare IDs need to be\n#'   explicitly namespaced for the current module, \\code{session$ns(\"name\")}\n#'   will return the fully-qualified ID.\n#' }\n#'\n#' @name session\nNULL\n\n#' Namespaced IDs for inputs/outputs\n#'\n#' The \\code{NS} function creates namespaced IDs out of bare IDs, by joining\n#' them using \\code{ns.sep} as the delimiter. It is intended for use in Shiny\n#' modules. See \\url{http://shiny.rstudio.com/articles/modules.html}.\n#'\n#' Shiny applications use IDs to identify inputs and outputs. These IDs must be\n#' unique within an application, as accidentally using the same input/output ID\n#' more than once will result in unexpected behavior. The traditional solution\n#' for preventing name collisions is \\emph{namespaces}; a namespace is to an ID\n#' as a directory is to a file. Use the \\code{NS} function to turn a bare ID\n#' into a namespaced one, by combining them with \\code{ns.sep} in between.\n#'\n#' @param namespace The character vector to use for the namespace. This can have\n#'   any length, though a single element is most common. Length 0 will cause the\n#'   \\code{id} to be returned without a namespace, and length 2 will be\n#'   interpreted as multiple namespaces, in increasing order of specificity\n#'   (i.e. starting with the top-level namespace).\n#' @param id The id string to be namespaced (optional).\n#' @return If \\code{id} is missing, returns a function that expects an id string\n#'   as its only argument and returns that id with the namespace prepended.\n#' @seealso \\url{http://shiny.rstudio.com/articles/modules.html}\n#'\n#' @export\nNS <- function(namespace, id = NULL) {\n  if (missing(id)) {\n    function(id) {\n      paste(c(namespace, id), collapse = ns.sep)\n    }\n  } else {\n    paste(c(namespace, id), collapse = ns.sep)\n  }\n}\n\n#' @rdname NS\n#' @export\nns.sep <- \"-\"\n\n#' @include utils.R\nShinySession <- R6Class(\n  'ShinySession',\n  private = list(\n    # There are some private items with a leading \".\"; except for the dot, these\n    # items share a name with a public item.\n    websocket = 'ANY',\n    invalidatedOutputValues = 'Map',\n    invalidatedOutputErrors = 'Map',\n    inputMessageQueue = list(), # A list of inputMessages to send when flushed\n    .outputs = list(),          # Keeps track of all the output observer objects\n    .outputOptions = list(),     # Options for each of the output observer objects\n    progressKeys = 'character',\n    showcase   = 'ANY',\n    fileUploadContext = 'FileUploadContext',\n    .input      = 'ANY', # Internal ReactiveValues object for normal input sent from client\n    .clientData = 'ANY', # Internal ReactiveValues object for other data sent from the client\n    busyCount = 0L, # Number of observer callbacks that are pending. When 0, we are idle\n    closedCallbacks = 'Callbacks',\n    flushCallbacks = 'Callbacks',\n    flushedCallbacks = 'Callbacks',\n    inputReceivedCallbacks = 'Callbacks',\n    sendResponse = function(requestMsg, value) {\n      if (is.null(requestMsg$tag)) {\n        warning(\"Tried to send response for untagged message; method: \",\n                requestMsg$method)\n        return()\n      }\n      private$sendMessage(\n        response = list(tag = requestMsg$tag, value = value)\n      )\n    },\n    sendErrorResponse = function(requestMsg, error) {\n      if (is.null(requestMsg$tag))\n        return()\n      private$sendMessage(\n        response = list(tag = requestMsg$tag, error = error)\n      )\n    },\n    write = function(json) {\n      if (self$closed){\n        return()\n      }\n      if (isTRUE(getOption('shiny.trace')))\n        message('SEND ',\n           gsub('(?m)base64,[a-zA-Z0-9+/=]+','[base64 data]',json,perl=TRUE))\n      private$websocket$send(json)\n    },\n    sendMessage = function(...) {\n      # This function is a wrapper for $write\n      msg <- list(...)\n      if (anyUnnamed(msg)) {\n        stop(\"All arguments to sendMessage must be named.\")\n      }\n      private$write(toJSON(msg))\n    },\n    getOutputOption = function(outputName, propertyName, defaultValue) {\n      opts <- private$.outputOptions[[outputName]]\n      if (is.null(opts))\n        return(defaultValue)\n      result <- opts[[propertyName]]\n      if (is.null(result))\n        return(defaultValue)\n      return(result)\n    },\n    shouldSuspend = function(name) {\n      # Find corresponding hidden state clientData variable, with the format\n      # \"output_foo_hidden\". (It comes from .clientdata_output_foo_hidden\n      # on the JS side)\n      # Some tricky stuff: instead of accessing names using input$names(),\n      # get the names directly via input$.values, to avoid triggering reactivity.\n      # Need to handle cases where the output object isn't actually used\n      # in the web page; in these cases, there's no output_foo_hidden flag,\n      # and hidden should be TRUE. In other words, NULL and TRUE should map to\n      # TRUE, FALSE should map to FALSE.\n      hidden <- private$.clientData$.values[[paste(\"output_\", name, \"_hidden\",\n                                           sep=\"\")]]\n      if (is.null(hidden)) hidden <- TRUE\n\n      return(hidden && private$getOutputOption(name, 'suspendWhenHidden', TRUE))\n    },\n\n    registerSessionEndCallbacks = function() {\n      # This is to be called from the initialization. It registers functions\n      # that are called when a session ends.\n\n      # Clear file upload directories, if present\n      self$onSessionEnded(private$fileUploadContext$rmUploadDirs)\n    }\n  ),\n  public = list(\n    progressStack = 'Stack', # Stack of progress objects\n    input       = 'reactivevalues', # Externally-usable S3 wrapper object for .input\n    output      = 'ANY',    # Externally-usable S3 wrapper object for .outputs\n    clientData  = 'reactivevalues', # Externally-usable S3 wrapper object for .clientData\n    token = 'character',  # Used to identify this instance in URLs\n    files = 'Map',        # For keeping track of files sent to client\n    downloads = 'Map',\n    closed = logical(0),\n    request = 'ANY',      # Websocket request object\n    singletons = character(0),  # Tracks singleton HTML fragments sent to the page\n    user = NULL,\n    groups = NULL,\n\n    initialize = function(websocket) {\n      private$websocket <- websocket\n      self$closed <- FALSE\n      # TODO: Put file upload context in user/app-specific dir if possible\n\n      private$invalidatedOutputValues <- Map$new()\n      private$invalidatedOutputErrors <- Map$new()\n      private$fileUploadContext <- FileUploadContext$new()\n      private$closedCallbacks <- Callbacks$new()\n      private$flushCallbacks <- Callbacks$new()\n      private$flushedCallbacks <- Callbacks$new()\n      private$inputReceivedCallbacks <- Callbacks$new()\n      private$.input      <- ReactiveValues$new()\n      private$.clientData <- ReactiveValues$new()\n      self$progressStack <- Stack$new()\n      self$files <- Map$new()\n      self$downloads <- Map$new()\n\n      self$input <- .createReactiveValues(private$.input, readonly=TRUE)\n      .setLabel(self$input, 'input')\n      self$clientData <- .createReactiveValues(private$.clientData, readonly=TRUE)\n      .setLabel(self$clientData, 'clientData')\n\n      self$output <- .createOutputWriter(self)\n\n      self$token <- createUniqueId(16)\n      private$.outputs <- list()\n      private$.outputOptions <- list()\n\n      private$registerSessionEndCallbacks()\n\n      if (!is.null(websocket$request$HTTP_SHINY_SERVER_CREDENTIALS)) {\n        try({\n          creds <- jsonlite::fromJSON(websocket$request$HTTP_SHINY_SERVER_CREDENTIALS)\n          self$user <- creds$user\n          self$groups <- creds$groups\n        }, silent=FALSE)\n      }\n\n      # session$request should throw an error if httpuv doesn't have\n      # websocket$request, but don't throw it until a caller actually\n      # tries to access session$request\n      delayedAssign('request', websocket$request, assign.env = self)\n\n      private$sendMessage(\n        config = list(\n          workerId = workerId(),\n          sessionId = self$token\n        )\n      )\n    },\n    makeScope = function(namespace) {\n      ns <- NS(namespace)\n\n      createSessionProxy(self,\n        input = .createReactiveValues(private$.input, readonly = TRUE, ns = ns),\n        output = .createOutputWriter(self, ns = ns),\n        sendInputMessage = function(inputId, message) {\n          .subset2(self, \"sendInputMessage\")(ns(inputId), message)\n        },\n        registerDataObj = function(name, data, filterFunc) {\n          .subset2(self, \"registerDataObj\")(ns(name), data, filterFunc)\n        },\n        ns = ns,\n        makeScope = function(namespace) {\n          self$makeScope(ns(namespace))\n        }\n      )\n    },\n    ns = function(id) {\n      NS(NULL, id)\n    },\n    onSessionEnded = function(sessionEndedCallback) {\n      \"Registers the given callback to be invoked when the session is closed\n      (i.e. the connection to the client has been severed). The return value\n      is a function which unregisters the callback. If multiple callbacks are\n      registered, the order in which they are invoked is not guaranteed.\"\n      return(private$closedCallbacks$register(sessionEndedCallback))\n    },\n    onEnded = function(endedCallback) {\n      \"Synonym for onSessionEnded\"\n      return(self$onSessionEnded(endedCallback))\n    },\n    onInputReceived = function(callback) {\n      \"Registers the given callback to be invoked when the session receives\n      new data from the client.\"\n      return(private$inputReceivedCallbacks$register(callback))\n    },\n    unhandledError = function(e) {\n      self$close()\n    },\n    close = function() {\n      if (!self$closed) {\n        private$websocket$close()\n      }\n    },\n    wsClosed = function() {\n      self$closed <- TRUE\n      for (output in private$.outputs) {\n        output$suspend()\n      }\n      # ..stacktraceon matches with the top-level ..stacktraceoff..\n      private$closedCallbacks$invoke(onError = printError, ..stacktraceon = TRUE)\n      flushReact()\n      lapply(appsByToken$values(), function(shinysession) {\n        shinysession$flushOutput()\n        NULL\n      })\n    },\n    isClosed = function() {\n      return(self$closed)\n    },\n    isEnded = function() {\n      return(self$isClosed())\n    },\n    setShowcase = function(value) {\n      private$showcase <- !is.null(value) && as.logical(value)\n    },\n    defineOutput = function(name, func, label) {\n      \"Binds an output generating function to this name. The function can either\n      take no parameters, or have named parameters for \\\\code{name} and\n      \\\\code{shinysession} (in the future this list may expand, so it is a good idea\n      to also include \\\\code{...} in your function signature).\"\n\n      # jcheng 08/31/2012: User submitted an example of a dynamically calculated\n      # name not working unless name was eagerly evaluated. Yikes!\n      force(name)\n\n      # If overwriting an output object, suspend the previous copy of it\n      if (!is.null(private$.outputs[[name]])) {\n        private$.outputs[[name]]$suspend()\n      }\n\n      if (is.function(func)) {\n        funcFormals <- formals(func)\n        # ..stacktraceon matches with the top-level ..stacktraceoff.., because\n        # the observer we set up below has ..stacktraceon=FALSE\n        func <- wrapFunctionLabel(func, paste0(\"output$\", name), ..stacktraceon = TRUE)\n        if (length(funcFormals) != 0) {\n          orig <- func\n          func <- function() {\n            orig(name=name, shinysession=self)\n          }\n        }\n\n        # Preserve source reference and file information when formatting the\n        # label for display in the reactive graph\n        srcref <- attr(label, \"srcref\")\n        srcfile <- attr(label, \"srcfile\")\n        label <- sprintf('output$%s', name)\n        attr(label, \"srcref\") <- srcref\n        attr(label, \"srcfile\") <- srcfile\n\n        obs <- observe(..stacktraceon = FALSE, {\n\n          private$sendMessage(recalculating = list(\n            name = name, status = 'recalculating'\n          ))\n\n          value <- tryCatch(\n            shinyCallingHandlers(func()),\n            shiny.silent.error = function(cond) {\n              # Don't let shiny.silent.error go through the normal stop\n              # path of try, because we don't want it to print. But we\n              # do want to try to return the same looking result so that\n              # the code below can send the error to the browser.\n              structure(\n                NULL,\n                class = \"try-error\",\n                condition = cond\n              )\n            },\n            error = function(cond) {\n              msg <- paste0(\"Error in output$\", name, \": \", conditionMessage(cond), \"\\n\")\n              if (isTRUE(getOption(\"show.error.messages\"))) {\n                printError(cond)\n              }\n              invisible(structure(msg, class = \"try-error\", condition = cond))\n            }\n          )\n\n          private$sendMessage(recalculating = list(\n            name = name, status = 'recalculated'\n          ))\n\n          private$invalidatedOutputErrors$remove(name)\n          private$invalidatedOutputValues$remove(name)\n\n          if (inherits(value, 'try-error')) {\n            cond <- attr(value, 'condition')\n            type <- setdiff(class(cond), c('simpleError', 'error', 'condition'))\n            private$invalidatedOutputErrors$set(\n              name,\n              list(message = cond$message,\n                   call = utils::capture.output(print(cond$call)),\n                   type = if (length(type)) type))\n          }\n          else\n            private$invalidatedOutputValues$set(name, value)\n        }, suspended=private$shouldSuspend(name), label=label)\n\n        obs$onInvalidate(function() {\n          self$showProgress(name)\n        })\n\n        private$.outputs[[name]] <- obs\n        if (is.null(private$.outputOptions[[name]]))\n          private$.outputOptions[[name]] <- list()\n      }\n      else {\n        stop(paste(\"Unexpected\", class(func), \"output for\", name))\n      }\n    },\n    flushOutput = function() {\n\n      # ..stacktraceon matches with the top-level ..stacktraceoff..\n      private$flushCallbacks$invoke(..stacktraceon = TRUE)\n      # ..stacktraceon matches with the top-level ..stacktraceoff..\n      on.exit(private$flushedCallbacks$invoke(..stacktraceon = TRUE))\n\n      if (length(private$progressKeys) == 0\n          && length(private$invalidatedOutputValues) == 0\n          && length(private$invalidatedOutputErrors) == 0\n          && length(private$inputMessageQueue) == 0) {\n        return(invisible())\n      }\n\n      private$progressKeys <- character(0)\n\n      values <- private$invalidatedOutputValues\n      private$invalidatedOutputValues <- Map$new()\n      errors <- private$invalidatedOutputErrors\n      private$invalidatedOutputErrors <- Map$new()\n      inputMessages <- private$inputMessageQueue\n      private$inputMessageQueue <- list()\n\n      private$sendMessage(\n        errors = as.list(errors),\n        values = as.list(values),\n        inputMessages = inputMessages\n      )\n    },\n    showProgress = function(id) {\n      'Send a message to the client that recalculation of the output identified\n      by \\\\code{id} is in progress. There is currently no mechanism for\n      explicitly turning off progress for an output component; instead, all\n      progress is implicitly turned off when flushOutput is next called.'\n\n      # If app is already closed, be sure not to show progress, otherwise we\n      # will get an error because of the closed websocket\n      if (self$closed)\n        return()\n\n      if (id %in% private$progressKeys)\n        return()\n\n      private$progressKeys <- c(private$progressKeys, id)\n\n      self$sendProgress('binding', list(id = id))\n    },\n    sendProgress = function(type, message) {\n      private$sendMessage(\n        progress = list(type = type, message = message)\n      )\n    },\n    dispatch = function(msg) {\n      method <- paste('@', msg$method, sep='')\n      func <- try(self[[method]], silent = TRUE)\n      if (inherits(func, 'try-error')) {\n        private$sendErrorResponse(msg, paste('Unknown method', msg$method))\n      }\n\n      value <- try(do.call(func, as.list(append(msg$args, msg$blobs))),\n                   silent=TRUE)\n      if (inherits(value, 'try-error')) {\n        private$sendErrorResponse(msg, conditionMessage(attr(value, 'condition')))\n      }\n      else {\n        private$sendResponse(msg, value)\n      }\n    },\n    sendCustomMessage = function(type, message) {\n      data <- list()\n      data[[type]] <- message\n      private$sendMessage(custom = data)\n    },\n    sendInputMessage = function(inputId, message) {\n      data <- list(id = inputId, message = message)\n\n      # Add to input message queue\n      private$inputMessageQueue[[length(private$inputMessageQueue) + 1]] <- data\n    },\n    onFlush = function(flushCallback, once = TRUE) {\n      if (!isTRUE(once)) {\n        return(private$flushCallbacks$register(flushCallback))\n      } else {\n        dereg <- private$flushCallbacks$register(function() {\n          dereg()\n          flushCallback()\n        })\n        return(dereg)\n      }\n    },\n    onFlushed = function(flushedCallback, once = TRUE) {\n      if (!isTRUE(once)) {\n        return(private$flushedCallbacks$register(flushedCallback))\n      } else {\n        dereg <- private$flushedCallbacks$register(function() {\n          dereg()\n          flushedCallback()\n        })\n        return(dereg)\n      }\n    },\n    reactlog = function(logEntry) {\n      if (private$showcase)\n        private$sendMessage(reactlog = logEntry)\n    },\n    reload = function() {\n      private$sendMessage(reload = TRUE)\n    },\n\n    # Public RPC methods\n    `@uploadieFinish` = function() {\n      # Do nothing; just want the side effect of flushReact, output flush, etc.\n    },\n    `@uploadInit` = function(fileInfos) {\n      maxSize <- getOption('shiny.maxRequestSize', 5 * 1024 * 1024)\n      fileInfos <- lapply(fileInfos, function(fi) {\n        if (is.null(fi$type))\n          fi$type <- getContentType(fi$name)\n        fi\n      })\n      sizes <- sapply(fileInfos, function(fi){ fi$size })\n      if (maxSize > 0 && any(sizes > maxSize)) {\n        stop(\"Maximum upload size exceeded\")\n      }\n\n      jobId <- private$fileUploadContext$createUploadOperation(fileInfos)\n      return(list(jobId=jobId,\n                  uploadUrl=paste('session', self$token, 'upload',\n                                  paste(jobId, \"?w=\", workerId(), sep=\"\"),\n                                  sep='/')))\n    },\n    `@uploadEnd` = function(jobId, inputId) {\n      fileData <- private$fileUploadContext$getUploadOperation(jobId)$finish()\n      private$.input$set(inputId, fileData)\n      invisible()\n    },\n    # Provides a mechanism for handling direct HTTP requests that are posted\n    # to the session (rather than going through the websocket)\n    handleRequest = function(req) {\n      # TODO: Turn off caching for the response\n      subpath <- req$PATH_INFO\n\n      matches <- regmatches(subpath,\n                            regexec(\"^/([a-z]+)/([^?]*)\",\n                                    subpath,\n                                    ignore.case=TRUE))[[1]]\n      if (length(matches) == 0)\n        return(httpResponse(400, 'text/html', '<h1>Bad Request\u003c/h1>'))\n\n      if (matches[2] == 'file') {\n        savedFile <- self$files$get(URLdecode(matches[3]))\n        if (is.null(savedFile))\n          return(httpResponse(404, 'text/html', '<h1>Not Found\u003c/h1>'))\n\n        return(httpResponse(200, savedFile$contentType, savedFile$data))\n      }\n\n      if (matches[2] == 'upload' && identical(req$REQUEST_METHOD, \"POST\")) {\n        job <- private$fileUploadContext$getUploadOperation(matches[3])\n        if (!is.null(job)) {\n          fileName <- req$HTTP_SHINY_FILE_NAME\n          fileType <- req$HTTP_SHINY_FILE_TYPE\n          fileSize <- req$CONTENT_LENGTH\n          job$fileBegin()\n\n          reqInput <- req$rook.input\n          while (length(buf <- reqInput$read(2^16)) > 0)\n            job$fileChunk(buf)\n\n          job$fileEnd()\n\n          return(httpResponse(200, 'text/plain', 'OK'))\n        }\n      }\n\n      if (matches[2] == 'uploadie' && identical(req$REQUEST_METHOD, \"POST\")) {\n        id <- URLdecode(matches[3])\n        res <- mime::parse_multipart(req)\n        private$.input$set(id, res[[id]])\n        return(httpResponse(200, 'text/plain', 'OK'))\n      }\n\n      if (matches[2] == 'download') {\n\n        # A bunch of ugliness here. Filenames can be dynamically generated by\n        # the user code, so we don't know what they'll be in advance. But the\n        # most reliable way to use non-ASCII filenames for downloads is to\n        # put the actual filename in the URL. So we will start with URLs in\n        # the form:\n        #\n        #   /session/$TOKEN/download/$NAME\n        #\n        # When a request matching that pattern is received, we will calculate\n        # the filename and see if it's non-ASCII; if so, we'll redirect to\n        #\n        #   /session/$TOKEN/download/$NAME/$FILENAME\n        #\n        # And when that pattern is received, we will actually return the file.\n        # Note that this means the filename and contents could be determined\n        # a few moments apart from each other (an HTTP roundtrip basically),\n        # hopefully that won't be enough to matter for anyone.\n\n        dlmatches <- regmatches(matches[3],\n                                regexec(\"^([^/]+)(/[^/]+)?$\",\n                                        matches[3]))[[1]]\n        dlname <- URLdecode(dlmatches[2])\n        download <- self$downloads$get(dlname)\n        if (is.null(download))\n          return(httpResponse(404, 'text/html', '<h1>Not Found\u003c/h1>'))\n\n        filename <- ifelse(is.function(download$filename),\n          Context$new(getDefaultReactiveDomain(), '[download]')$run(\n            download$filename\n          ),\n          download$filename)\n\n        # If the URL does not contain the filename, and the desired filename\n        # contains non-ASCII characters, then do a redirect with the desired\n        # name tacked on the end.\n        if (dlmatches[3] == '' && grepl('[^ -~]', filename)) {\n\n          return(httpResponse(302, 'text/html', '<h1>Found\u003c/h1>', c(\n            'Location' = sprintf('%s/%s',\n                                 URLencode(dlname, TRUE),\n                                 URLencode(filename, TRUE)),\n            'Cache-Control' = 'no-cache')))\n        }\n\n        # Make temp file with the same extension as the user-visible filename.\n        # If the extension is not used, some functions such as pdf() and zip()\n        # may append the extension they expect, meaning the data we want will\n        # be written to a file other than our temp file (e.g. file1231.zip\n        # instead of file1231.zip).\n        ext <- tools::file_ext(filename)\n        if (nzchar(ext))\n          ext <- paste(\".\", ext, sep = \"\")\n        tmpdata <- tempfile(fileext = ext)\n        # ..stacktraceon matches with the top-level ..stacktraceoff..\n        result <- try(shinyCallingHandlers(Context$new(getDefaultReactiveDomain(), '[download]')$run(\n          function() { ..stacktraceon..(download$func(tmpdata)) }\n        )))\n        if (inherits(result, 'try-error')) {\n          cond <- attr(result, 'condition', exact = TRUE)\n          printError(cond)\n          unlink(tmpdata)\n          return(httpResponse(500, 'text/plain; charset=UTF-8',\n                              enc2utf8(conditionMessage(cond))))\n        }\n        return(httpResponse(\n          200,\n          download$contentType %OR% getContentType(filename),\n          # owned=TRUE means tmpdata will be deleted after response completes\n          list(file=tmpdata, owned=TRUE),\n          c(\n            'Content-Disposition' = ifelse(\n              dlmatches[3] == '',\n              'attachment; filename=\"' %.%\n                gsub('([\"\\\\\\\\])', '\\\\\\\\\\\\1', filename) %.%  # yes, that many \\'s\n                '\"',\n              'attachment'\n            ),\n            'Cache-Control'='no-cache')))\n      }\n\n      if (matches[2] == 'dataobj') {\n        # /session/$TOKEN/dataobj/$NAME\n        dlmatches <- regmatches(matches[3],\n                                regexec(\"^([^/]+)(/[^/]+)?$\",\n                                        matches[3]))[[1]]\n        dlname <- URLdecode(dlmatches[2])\n        download <- self$downloads$get(dlname)\n        return(download$filter(download$data, req))\n      }\n\n      return(httpResponse(404, 'text/html', '<h1>Not Found\u003c/h1>'))\n    },\n    saveFileUrl = function(name, data, contentType, extra=list()) {\n      \"Creates an entry in the file map for the data, and returns a URL pointing\n      to the file.\"\n      self$files$set(name, list(data=data, contentType=contentType))\n      return(sprintf('session/%s/file/%s?w=%s&r=%s',\n                     URLencode(self$token, TRUE),\n                     URLencode(name, TRUE),\n                     workerId(),\n                     createUniqueId(8)))\n    },\n    # Send a file to the client\n    fileUrl = function(name, file, contentType='application/octet-stream') {\n      \"Return a URL for a file to be sent to the client. If allowDataUriScheme\n      is TRUE, then the file will be base64 encoded and embedded in the URL.\n      Otherwise, a URL pointing to the file will be returned.\"\n      bytes <- file.info(file)$size\n      if (is.na(bytes))\n        return(NULL)\n\n      fileData <- readBin(file, 'raw', n=bytes)\n\n      if (isTRUE(private$.clientData$.values$allowDataUriScheme)) {\n        b64 <- rawToBase64(fileData)\n        return(paste('data:', contentType, ';base64,', b64, sep=''))\n      } else {\n        return(self$saveFileUrl(name, fileData, contentType))\n      }\n    },\n    registerDownload = function(name, filename, contentType, func) {\n\n      self$downloads$set(name, list(filename = filename,\n                               contentType = contentType,\n                               func = func))\n      return(sprintf('session/%s/download/%s?w=%s',\n                     URLencode(self$token, TRUE),\n                     URLencode(name, TRUE),\n                     workerId()))\n    },\n    # register a data object on the server side (for datatable or selectize, etc)\n    registerDataObj = function(name, data, filterFunc) {\n      # abusing downloads at the moment\n      self$downloads$set(name, list(data = data, filter = filterFunc))\n      return(sprintf('session/%s/dataobj/%s?w=%s',\n                     URLencode(self$token, TRUE),\n                     URLencode(name, TRUE),\n                     workerId()))\n    },\n    # This function suspends observers for hidden outputs and resumes observers\n    # for un-hidden outputs.\n    manageHiddenOutputs = function() {\n      # Find hidden state for each output, and suspend/resume accordingly\n      for (outputName in names(private$.outputs)) {\n        if (private$shouldSuspend(outputName)) {\n          private$.outputs[[outputName]]$suspend()\n        } else {\n          private$.outputs[[outputName]]$resume()\n        }\n      }\n    },\n    # Set the normal and client data input variables\n    manageInputs = function(data) {\n\n      private$inputReceivedCallbacks$invoke(data)\n\n      data_names <- names(data)\n\n      # Separate normal input variables from client data input variables\n      clientdata_idx <- grepl(\"^.clientdata_\", data_names)\n\n      # Set normal (non-clientData) input values\n      private$.input$mset(data[data_names[!clientdata_idx]])\n\n      # Strip off .clientdata_ from clientdata input names, and set values\n      input_clientdata <- data[data_names[clientdata_idx]]\n      names(input_clientdata) <- sub(\"^.clientdata_\", \"\",\n                                     names(input_clientdata))\n      private$.clientData$mset(input_clientdata)\n    },\n    outputOptions = function(name, ...) {\n      # If no name supplied, return the list of options for all outputs\n      if (is.null(name))\n        return(private$.outputOptions)\n      if (! name %in% names(private$.outputs))\n        stop(name, \" is not in list of output objects\")\n\n      opts <- list(...)\n      # If no options are set, return the options for the specified output\n      if (length(opts) == 0)\n        return(private$.outputOptions[[name]])\n\n      # Set the appropriate option\n      validOpts <- c(\"suspendWhenHidden\", \"priority\")\n      for (optname in names(opts)) {\n        if (! optname %in% validOpts)\n          stop(optname, \" is not a valid option\")\n\n        private$.outputOptions[[name]][[optname]] <- opts[[optname]]\n      }\n\n      # If any changes to suspendWhenHidden, need to re-run manageHiddenOutputs\n      if (\"suspendWhenHidden\" %in% names(opts)) {\n        self$manageHiddenOutputs()\n      }\n\n      if (\"priority\" %in% names(opts)) {\n        private$.outputs[[name]]$setPriority(opts[['priority']])\n      }\n\n      invisible()\n    },\n    incrementBusyCount = function() {\n      if (private$busyCount == 0L) {\n        private$sendMessage(busy = \"busy\")\n      }\n      private$busyCount <- private$busyCount + 1L\n    },\n    decrementBusyCount = function() {\n      private$busyCount <- private$busyCount - 1L\n      if (private$busyCount == 0L) {\n        private$sendMessage(busy = \"idle\")\n      }\n    }\n  ),\n  active = list(\n    session = function() {\n      shinyDeprecated(\n        msg = paste(\"Attempted to access deprecated shinysession$session object.\",\n                    \"Please just access the shinysession object directly.\"),\n        version = \"0.11.1\"\n      )\n      self\n    }\n  )\n)\n\n.createOutputWriter <- function(shinysession, ns = identity) {\n  structure(list(impl=shinysession, ns=ns), class='shinyoutput')\n}\n\n#' @export\n`$<-.shinyoutput` <- function(x, name, value) {\n  name <- .subset2(x, 'ns')(name)\n\n  label <- deparse(substitute(value))\n  if (length(substitute(value)) > 1) {\n    # value is an object consisting of a call and its arguments. Here we want\n    # to find the source references for the first argument (if there are\n    # arguments), which generally corresponds to the reactive expression--\n    # e.g. in renderTable({ x }), { x } is the expression to trace.\n    attr(label, \"srcref\") <- srcrefFromShinyCall(substitute(value)[[2]])\n    srcref <- attr(substitute(value)[[2]], \"srcref\")\n    if (length(srcref) > 0)\n      attr(label, \"srcfile\") <- srcFileOfRef(srcref[[1]])\n  }\n  .subset2(x, 'impl')$defineOutput(name, value, label)\n  return(invisible(x))\n}\n\n#' @export\n`[[<-.shinyoutput` <- `$<-.shinyoutput`\n\n#' @export\n`$.shinyoutput` <- function(x, name) {\n  stop(\"Reading objects from shinyoutput object not allowed.\")\n}\n\n#' @export\n`[[.shinyoutput` <- `$.shinyoutput`\n\n#' @export\n`[.shinyoutput` <- function(values, name) {\n  stop(\"Single-bracket indexing of shinyoutput object is not allowed.\")\n}\n\n#' @export\n`[<-.shinyoutput` <- function(values, name, value) {\n  stop(\"Single-bracket indexing of shinyoutput object is not allowed.\")\n}\n\n#' Set options for an output object.\n#'\n#' These are the available options for an output object:\n#' \\itemize{\n#'   \\item suspendWhenHidden. When \\code{TRUE} (the default), the output object\n#'     will be suspended (not execute) when it is hidden on the web page. When\n#'     \\code{FALSE}, the output object will not suspend when hidden, and if it\n#'     was already hidden and suspended, then it will resume immediately.\n#'   \\item priority. The priority level of the output object. Queued outputs\n#'     with higher priority values will execute before those with lower values.\n#' }\n#'\n#' @examples\n#' \\dontrun{\n#' # Get the list of options for all observers within output\n#' outputOptions(output)\n#'\n#' # Disable suspend for output$myplot\n#' outputOptions(output, \"myplot\", suspendWhenHidden = FALSE)\n#'\n#' # Change priority for output$myplot\n#' outputOptions(output, \"myplot\", priority = 10)\n#'\n#' # Get the list of options for output$myplot\n#' outputOptions(output, \"myplot\")\n#' }\n#'\n#' @param x A shinyoutput object (typically \\code{output}).\n#' @param name The name of an output observer in the shinyoutput object.\n#' @param ... Options to set for the output observer.\n#' @export\noutputOptions <- function(x, name, ...) {\n  if (!inherits(x, \"shinyoutput\"))\n    stop(\"x must be a shinyoutput object.\")\n\n  name <- .subset2(x, 'ns')(name)\n\n  .subset2(x, 'impl')$outputOptions(name, ...)\n}\n"},{"filename":"/R/utils.R","content":"#' @include globals.R\n#' @include map.R\nNULL\n\n#' Make a random number generator repeatable\n#'\n#' Given a function that generates random data, returns a wrapped version of\n#' that function that always uses the same seed when called. The seed to use can\n#' be passed in explicitly if desired; otherwise, a random number is used.\n#'\n#' @param rngfunc The function that is affected by the R session's seed.\n#' @param seed The seed to set every time the resulting function is called.\n#' @return A repeatable version of the function that was passed in.\n#'\n#' @note When called, the returned function attempts to preserve the R session's\n#'   current seed by snapshotting and restoring\n#'   \\code{\\link[base]{.Random.seed}}.\n#'\n#' @examples\n#' rnormA <- repeatable(rnorm)\n#' rnormB <- repeatable(rnorm)\n#' rnormA(3)  # [1]  1.8285879 -0.7468041 -0.4639111\n#' rnormA(3)  # [1]  1.8285879 -0.7468041 -0.4639111\n#' rnormA(5)  # [1]  1.8285879 -0.7468041 -0.4639111 -1.6510126 -1.4686924\n#' rnormB(5)  # [1] -0.7946034  0.2568374 -0.6567597  1.2451387 -0.8375699\n#'\n#' @export\nrepeatable <- function(rngfunc, seed = stats::runif(1, 0, .Machine$integer.max)) {\n  force(seed)\n\n  function(...) {\n    # When we exit, restore the seed to its original state\n    if (exists('.Random.seed', where=globalenv())) {\n      currentSeed <- get('.Random.seed', pos=globalenv())\n      on.exit(assign('.Random.seed', currentSeed, pos=globalenv()))\n    }\n    else {\n      on.exit(rm('.Random.seed', pos=globalenv()))\n    }\n\n    set.seed(seed)\n\n    rngfunc(...)\n  }\n}\n\n# Temporarily set x in env to value, evaluate expr, and\n# then restore x to its original state\nwithTemporary <- function(env, x, value, expr, unset = FALSE) {\n\n  if (exists(x, envir = env, inherits = FALSE)) {\n    oldValue <- get(x, envir = env, inherits = FALSE)\n    on.exit(\n      assign(x, oldValue, envir = env, inherits = FALSE),\n      add = TRUE)\n  } else {\n    on.exit(\n      rm(list = x, envir = env, inherits = FALSE),\n      add = TRUE\n    )\n  }\n\n  if (!missing(value) && !isTRUE(unset))\n    assign(x, value, envir = env, inherits = FALSE)\n  else {\n    if (exists(x, envir = env, inherits = FALSE))\n      rm(list = x, envir = env, inherits = FALSE)\n  }\n  force(expr)\n}\n\n.globals$ownSeed <- NULL\n# Evaluate an expression using Shiny's own private stream of\n# randomness (not affected by set.seed).\nwithPrivateSeed <- function(expr) {\n  withTemporary(.GlobalEnv, \".Random.seed\",\n    .globals$ownSeed, unset=is.null(.globals$ownSeed), {\n      tryCatch({\n        expr\n      }, finally = {\n        .globals$ownSeed <- getExists('.Random.seed', 'numeric', globalenv())\n      })\n    }\n  )\n}\n\n# a homemade version of set.seed(NULL) for backward compatibility with R 2.15.x\nreinitializeSeed <- if (getRversion() >= '3.0.0') {\n  function() set.seed(NULL)\n} else function() {\n  if (exists('.Random.seed', globalenv()))\n    rm(list = '.Random.seed', pos = globalenv())\n  stats::runif(1)  # generate any random numbers so R can reinitialize the seed\n}\n\n# Version of runif that runs with private seed\np_runif <- function(...) {\n  withPrivateSeed(stats::runif(...))\n}\n\n# Version of sample that runs with private seed\np_sample <- function(...) {\n  withPrivateSeed(sample(...))\n}\n\n# Return a random integral value in the range [min, max).\n# If only one argument is passed, then min=0 and max=argument.\nrandomInt <- function(min, max) {\n  if (missing(max)) {\n    max <- min\n    min <- 0\n  }\n  if (min < 0 || max <= min)\n    stop(\"Invalid min/max values\")\n\n  min + sample(max-min, 1)-1\n}\n\np_randomInt <- function(...) {\n  withPrivateSeed(randomInt(...))\n}\n\nisWholeNum <- function(x, tol = .Machine$double.eps^0.5) {\n  abs(x - round(x)) < tol\n}\n\n`%OR%` <- function(x, y) {\n  if (is.null(x) || isTRUE(is.na(x)))\n    y\n  else\n    x\n}\n\n`%AND%` <- function(x, y) {\n  if (!is.null(x) && !is.na(x))\n    if (!is.null(y) && !is.na(y))\n      return(y)\n  return(NULL)\n}\n\n`%.%` <- function(x, y) {\n  paste(x, y, sep='')\n}\n\n# Given a vector or list, drop all the NULL items in it\ndropNulls <- function(x) {\n  x[!vapply(x, is.null, FUN.VALUE=logical(1))]\n}\n\nnullOrEmpty <- function(x) {\n  is.null(x) || length(x) == 0\n}\n# Given a vector or list, drop all the NULL items in it\ndropNullsOrEmpty <- function(x) {\n  x[!vapply(x, nullOrEmpty, FUN.VALUE=logical(1))]\n}\n\n# Given a vector/list, return TRUE if any elements are unnamed, FALSE otherwise.\nanyUnnamed <- function(x) {\n  # Zero-length vector\n  if (length(x) == 0) return(FALSE)\n\n  nms <- names(x)\n\n  # List with no name attribute\n  if (is.null(nms)) return(TRUE)\n\n  # List with name attribute; check for any \"\"\n  any(!nzchar(nms))\n}\n\n# Combine dir and (file)name into a file path. If a file already exists with a\n# name differing only by case, then use it instead.\nfile.path.ci <- function(...) {\n  result <- find.file.ci(...)\n  if (!is.null(result))\n    return(result)\n\n  # If not found, return the file path that was given to us.\n  return(file.path(...))\n}\n\n# Does a particular file exist? Case-insensitive for filename, case-sensitive\n# for path (on platforms with case-sensitive file system).\nfile.exists.ci <- function(...) {\n  !is.null(find.file.ci(...))\n}\n\n# Look for a file, case-insensitive for filename, case-sensitive for path (on\n# platforms with case-sensitive filesystem). If found, return the path to the\n# file, with the correct case. If not found, return NULL.\nfind.file.ci <- function(...) {\n  default <- file.path(...)\n  if (length(default) > 1)\n    stop(\"find.file.ci can only check for one file at a time.\")\n  if (file.exists(default))\n    return(default)\n\n  dir <- dirname(default)\n  name <- basename(default)\n\n  # If we got here, then we'll check for a directory with the exact case, and a\n  # name with any case.\n  all_files <- list.files(dir, all.files=TRUE, full.names=TRUE,\n                          include.dirs=TRUE)\n  match_idx <- tolower(name) == tolower(basename(all_files))\n  matches <- all_files[match_idx]\n  if (length(matches) == 0)\n    return(NULL)\n\n  return(matches[1])\n}\n\n# Attempt to join a path and relative path, and turn the result into a\n# (normalized) absolute path. The result will only be returned if it is an\n# existing file/directory and is a descendant of dir.\n#\n# Example:\n# resolve(\"/Users/jcheng\", \"shiny\")  # \"/Users/jcheng/shiny\"\n# resolve(\"/Users/jcheng\", \"./shiny\")  # \"/Users/jcheng/shiny\"\n# resolve(\"/Users/jcheng\", \"shiny/../shiny/\")  # \"/Users/jcheng/shiny\"\n# resolve(\"/Users/jcheng\", \".\")  # NULL\n# resolve(\"/Users/jcheng\", \"..\")  # NULL\n# resolve(\"/Users/jcheng\", \"shiny/..\")  # NULL\nresolve <- function(dir, relpath) {\n  abs.path <- file.path(dir, relpath)\n  if (!file.exists(abs.path))\n    return(NULL)\n  abs.path <- normalizePath(abs.path, winslash='/', mustWork=TRUE)\n  dir <- normalizePath(dir, winslash='/', mustWork=TRUE)\n  # trim the possible trailing slash under Windows (#306)\n  if (isWindows()) dir <- sub('/$', '', dir)\n  if (nchar(abs.path) <= nchar(dir) + 1)\n    return(NULL)\n  if (substr(abs.path, 1, nchar(dir)) != dir ||\n      substr(abs.path, nchar(dir)+1, nchar(dir)+1) != '/') {\n    return(NULL)\n  }\n  return(abs.path)\n}\n\nisWindows <- function() .Platform$OS.type == 'windows'\n\n# This is a wrapper for download.file and has the same interface.\n# The only difference is that, if the protocol is https, it changes the\n# download settings, depending on platform.\ndownload <- function(url, ...) {\n  # First, check protocol. If http or https, check platform:\n  if (grepl('^https?://', url)) {\n\n    # Check whether we are running R 3.2\n    isR32 <- getRversion() >= \"3.2\"\n\n    # Windows\n    if (.Platform$OS.type == \"windows\") {\n\n      if (isR32) {\n        method <- \"wininet\"\n      } else {\n\n        # If we directly use setInternet2, R CMD CHECK gives a Note on Mac/Linux\n        seti2 <- `::`(utils, 'setInternet2')\n\n        # Check whether we are already using internet2 for internal\n        internet2_start <- seti2(NA)\n\n        # If not then temporarily set it\n        if (!internet2_start) {\n          # Store initial settings, and restore on exit\n          on.exit(suppressWarnings(seti2(internet2_start)))\n\n          # Needed for https. Will get warning if setInternet2(FALSE) already run\n          # and internet routines are used. But the warnings don't seem to matter.\n          suppressWarnings(seti2(TRUE))\n        }\n\n        method <- \"internal\"\n      }\n\n      # download.file will complain about file size with something like:\n      #       Warning message:\n      #         In download.file(url, ...) : downloaded length 19457 != reported length 200\n      # because apparently it compares the length with the status code returned (?)\n      # so we supress that\n      suppressWarnings(utils::download.file(url, method = method, ...))\n\n    } else {\n      # If non-Windows, check for libcurl/curl/wget/lynx, then call download.file with\n      # appropriate method.\n\n      if (isR32 && capabilities(\"libcurl\")) {\n        method <- \"libcurl\"\n      } else if (nzchar(Sys.which(\"wget\")[1])) {\n        method <- \"wget\"\n      } else if (nzchar(Sys.which(\"curl\")[1])) {\n        method <- \"curl\"\n\n        # curl needs to add a -L option to follow redirects.\n        # Save the original options and restore when we exit.\n        orig_extra_options <- getOption(\"download.file.extra\")\n        on.exit(options(download.file.extra = orig_extra_options))\n\n        options(download.file.extra = paste(\"-L\", orig_extra_options))\n\n      } else if (nzchar(Sys.which(\"lynx\")[1])) {\n        method <- \"lynx\"\n      } else {\n        stop(\"no download method found\")\n      }\n\n      utils::download.file(url, method = method, ...)\n    }\n\n  } else {\n    utils::download.file(url, ...)\n  }\n}\n\ngetContentType <- function(file, defaultType = 'application/octet-stream') {\n  subtype <- ifelse(grepl('[.]html?$', file), 'charset=UTF-8', '')\n  mime::guess_type(file, unknown = defaultType, subtype = subtype)\n}\n\n# Create a zero-arg function from a quoted expression and environment\n# @examples\n# makeFunction(body=quote(print(3)))\nmakeFunction <- function(args = pairlist(), body, env = parent.frame()) {\n  eval(call(\"function\", args, body), env)\n}\n\n#' Convert an expression to a function\n#'\n#' This is to be called from another function, because it will attempt to get\n#' an unquoted expression from two calls back.\n#'\n#' If expr is a quoted expression, then this just converts it to a function.\n#' If expr is a function, then this simply returns expr (and prints a\n#'   deprecation message).\n#' If expr was a non-quoted expression from two calls back, then this will\n#'   quote the original expression and convert it to a function.\n#\n#' @param expr A quoted or unquoted expression, or a function.\n#' @param env The desired environment for the function. Defaults to the\n#'   calling environment two steps back.\n#' @param quoted Is the expression quoted?\n#'\n#' @examples\n#' # Example of a new renderer, similar to renderText\n#' # This is something that toolkit authors will do\n#' renderTriple <- function(expr, env=parent.frame(), quoted=FALSE) {\n#'   # Convert expr to a function\n#'   func <- shiny::exprToFunction(expr, env, quoted)\n#'\n#'   function() {\n#'     value <- func()\n#'     paste(rep(value, 3), collapse=\", \")\n#'   }\n#' }\n#'\n#'\n#' # Example of using the renderer.\n#' # This is something that app authors will do.\n#' values <- reactiveValues(A=\"text\")\n#'\n#' \\dontrun{\n#' # Create an output object\n#' output$tripleA <- renderTriple({\n#'   values$A\n#' })\n#' }\n#'\n#' # At the R console, you can experiment with the renderer using isolate()\n#' tripleA <- renderTriple({\n#'   values$A\n#' })\n#'\n#' isolate(tripleA())\n#' # \"text, text, text\"\n#'\n#' @export\nexprToFunction <- function(expr, env=parent.frame(), quoted=FALSE) {\n  if (!quoted) {\n    expr <- eval(substitute(substitute(expr)), parent.frame())\n  }\n\n  # expr is a quoted expression\n  makeFunction(body=expr, env=env)\n}\n\n#' Install an expression as a function\n#'\n#' Installs an expression in the given environment as a function, and registers\n#' debug hooks so that breakpoints may be set in the function.\n#'\n#' This function can replace \\code{exprToFunction} as follows: we may use\n#' \\code{func <- exprToFunction(expr)} if we do not want the debug hooks, or\n#' \\code{installExprFunction(expr, \"func\")} if we do. Both approaches create a\n#' function named \\code{func} in the current environment.\n#'\n#' @seealso Wraps \\code{\\link{exprToFunction}}; see that method's documentation\n#'   for more documentation and examples.\n#'\n#' @param expr A quoted or unquoted expression\n#' @param name The name the function should be given\n#' @param eval.env The desired environment for the function. Defaults to the\n#'   calling environment two steps back.\n#' @param quoted Is the expression quoted?\n#' @param assign.env The environment in which the function should be assigned.\n#' @param label A label for the object to be shown in the debugger. Defaults to\n#'   the name of the calling function.\n#' @param wrappedWithLabel,..stacktraceon Advanced use only. For stack manipulation purposes; see\n#'   \\code{\\link{stacktrace}}.\n#'\n#' @export\ninstallExprFunction <- function(expr, name, eval.env = parent.frame(2),\n                                quoted = FALSE,\n                                assign.env = parent.frame(1),\n                                label = deparse(sys.call(-1)[[1]]),\n                                wrappedWithLabel = TRUE,\n                                ..stacktraceon = FALSE) {\n  if (!quoted) {\n    quoted <- TRUE\n    expr <- eval(substitute(substitute(expr)), parent.frame())\n  }\n\n  func <- exprToFunction(expr, eval.env, quoted)\n  if (length(label) > 1) {\n    # Just in case the deparsed code is more complicated than we imagine. If we\n    # have a label with length > 1 it causes warnings in wrapFunctionLabel.\n    label <- paste0(label, collapse = \"\\n\")\n  }\n  if (wrappedWithLabel) {\n    func <- wrapFunctionLabel(func, label, ..stacktraceon = ..stacktraceon)\n  } else {\n    registerDebugHook(name, assign.env, label)\n  }\n  assign(name, func, envir = assign.env)\n}\n\n#' Parse a GET query string from a URL\n#'\n#' Returns a named list of key-value pairs.\n#'\n#' @param str The query string. It can have a leading \\code{\"?\"} or not.\n#' @param nested Whether to parse the query string of as a nested list when it\n#'   contains pairs of square brackets \\code{[]}. For example, the query\n#'   \\samp{a[i1][j1]=x&b[i1][j1]=y&b[i2][j1]=z} will be parsed as \\code{list(a =\n#'   list(i1 = list(j1 = 'x')), b = list(i1 = list(j1 = 'y'), i2 = list(j1 =\n#'   'z')))} when \\code{nested = TRUE}, and \\code{list(`a[i1][j1]` = 'x',\n#'   `b[i1][j1]` = 'y', `b[i2][j1]` = 'z')} when \\code{nested = FALSE}.\n#' @export\n#' @examples\n#' parseQueryString(\"?foo=1&bar=b%20a%20r\")\n#'\n#' \\dontrun{\n#' # Example of usage within a Shiny app\n#' shinyServer(function(input, output, session) {\n#'\n#'   output$queryText <- renderText({\n#'     query <- parseQueryString(session$clientData$url_search)\n#'\n#'     # Ways of accessing the values\n#'     if (as.numeric(query$foo) == 1) {\n#'       # Do something\n#'     }\n#'     if (query[[\"bar\"]] == \"targetstring\") {\n#'       # Do something else\n#'     }\n#'\n#'     # Return a string with key-value pairs\n#'     paste(names(query), query, sep = \"=\", collapse=\", \")\n#'   })\n#' })\n#' }\n#'\nparseQueryString <- function(str, nested = FALSE) {\n  if (is.null(str) || nchar(str) == 0)\n    return(list())\n\n  # Remove leading ?\n  if (substr(str, 1, 1) == '?')\n    str <- substr(str, 2, nchar(str))\n\n  pairs <- strsplit(str, '&', fixed = TRUE)[[1]]\n  pairs <- strsplit(pairs, '=', fixed = TRUE)\n\n  keys   <- vapply(pairs, function(x) x[1], FUN.VALUE = character(1))\n  values <- vapply(pairs, function(x) x[2], FUN.VALUE = character(1))\n  # Replace NA with '', so they don't get converted to 'NA' by URLdecode\n  values[is.na(values)] <- ''\n\n  # Convert \"+\" to \" \", since URLdecode doesn't do it\n  keys   <- gsub('+', ' ', keys,   fixed = TRUE)\n  values <- gsub('+', ' ', values, fixed = TRUE)\n\n  keys   <- URLdecode(keys)\n  values <- URLdecode(values)\n\n  res <- stats::setNames(as.list(values), keys)\n  if (!nested) return(res)\n\n  # Make a nested list from a query of the form ?a[1][1]=x11&a[1][2]=x12&...\n  for (i in grep('\\\\[.+\\\\]', keys)) {\n    k <- strsplit(keys[i], '[][]')[[1L]]  # split by [ or ]\n    res <- assignNestedList(res, k[k != ''], values[i])\n    res[[keys[i]]] <- NULL    # remove res[['a[1][1]']]\n  }\n  res\n}\n\n# Assign value to the bottom element of the list x using recursive indices idx\nassignNestedList <- function(x = list(), idx, value) {\n  for (i in seq_along(idx)) {\n    sub <- idx[seq_len(i)]\n    if (is.null(x[[sub]])) x[[sub]] <- list()\n  }\n  x[[idx]] <- value\n  x\n}\n\n# decide what to do in case of errors; it is customizable using the shiny.error\n# option (e.g. we can set options(shiny.error = recover))\n#' @include conditions.R\nshinyCallingHandlers <- function(expr) {\n  withCallingHandlers(captureStackTraces(expr),\n    error = function(e) {\n      # Don't intercept shiny.silent.error (i.e. validation errors)\n      if (inherits(e, \"shiny.silent.error\"))\n        return()\n\n      handle <- getOption('shiny.error')\n      if (is.function(handle)) handle()\n    }\n  )\n}\n\n#' Print message for deprecated functions in Shiny\n#'\n#' To disable these messages, use \\code{options(shiny.deprecation.messages=FALSE)}.\n#'\n#' @param new Name of replacement function.\n#' @param msg Message to print. If used, this will override the default message.\n#' @param old Name of deprecated function.\n#' @param version The last version of Shiny before the item was deprecated.\n#' @keywords internal\nshinyDeprecated <- function(new=NULL, msg=NULL,\n                            old=as.character(sys.call(sys.parent()))[1L],\n                            version = NULL) {\n\n  if (getOption(\"shiny.deprecation.messages\") %OR% TRUE == FALSE)\n    return(invisible())\n\n  if (is.null(msg)) {\n    msg <- paste(old, \"is deprecated.\")\n    if (!is.null(new)) {\n      msg <- paste(msg, \"Please use\", new, \"instead.\",\n        \"To disable this message, run options(shiny.deprecation.messages=FALSE)\")\n    }\n  }\n\n  if (!is.null(version)) {\n    msg <- paste0(msg, \" (Last used in version \", version, \")\")\n  }\n\n  # Similar to .Deprecated(), but print a message instead of warning\n  message(msg)\n}\n\n#' Register a function with the debugger (if one is active).\n#'\n#' Call this function after exprToFunction to give any active debugger a hook\n#' to set and clear breakpoints in the function. A debugger may implement\n#' registerShinyDebugHook to receive callbacks when Shiny functions are\n#' instantiated at runtime.\n#'\n#' @param name Name of the field or object containing the function.\n#' @param where The reference object or environment containing the function.\n#' @param label A label to display on the function in the debugger.\n#' @noRd\nregisterDebugHook <- function(name, where, label) {\n  if (exists(\"registerShinyDebugHook\", mode = \"function\")) {\n    registerShinyDebugHook <- get(\"registerShinyDebugHook\", mode = \"function\")\n    params <- new.env(parent = emptyenv())\n    params$name <- name\n    params$where <- where\n    params$label <- label\n    registerShinyDebugHook(params)\n  }\n}\n\nCallbacks <- R6Class(\n  'Callbacks',\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    .nextId = integer(0),\n    .callbacks = 'Map',\n\n    initialize = function() {\n      .nextId <<- as.integer(.Machine$integer.max)\n      .callbacks <<- Map$new()\n    },\n    register = function(callback) {\n      id <- as.character(.nextId)\n      .nextId <<- .nextId - 1L\n      .callbacks$set(id, callback)\n      return(function() {\n        .callbacks$remove(id)\n      })\n    },\n    invoke = function(..., onError=NULL, ..stacktraceon = FALSE) {\n      # Ensure that calls are invoked in the order that they were registered\n      keys <- as.character(sort(as.integer(.callbacks$keys()), decreasing = TRUE))\n      callbacks <- .callbacks$mget(keys)\n\n      for (callback in callbacks) {\n        if (is.null(onError)) {\n          if (..stacktraceon) {\n            ..stacktraceon..(callback(...))\n          } else {\n            callback(...)\n          }\n        } else {\n          tryCatch(\n            captureStackTraces(\n              if (..stacktraceon)\n                ..stacktraceon..(callback(...))\n              else\n                callback(...)\n            ),\n            error = onError\n          )\n        }\n      }\n    },\n    count = function() {\n      .callbacks$size()\n    }\n  )\n)\n\n# convert a data frame to JSON as required by DataTables request\ndataTablesJSON <- function(data, req) {\n  n <- nrow(data)\n  # DataTables requests were sent via POST\n  params <- URLdecode(rawToChar(req$rook.input$read()))\n  q <- parseQueryString(params, nested = TRUE)\n  ci <- q$search[['caseInsensitive']] == 'true'\n\n  # data may have been replaced/updated in the new table while the Ajax request\n  # from the previous table is still on its way, so it is possible that the old\n  # request asks for more columns than the current data, in which case we should\n  # discard this request and return empty data; the next Ajax request from the\n  # new table will retrieve the correct number of columns of data\n  if (length(q$columns) != ncol(data)) {\n    res <- toJSON(list(\n      draw = as.integer(q$draw),\n      recordsTotal = n,\n      recordsFiltered = 0,\n      data = NULL\n    ))\n    return(httpResponse(200, 'application/json', enc2utf8(res)))\n  }\n\n  # global searching\n  i <- seq_len(n)\n  if (length(q$search[['value']]) && q$search[['value']] != '') {\n    i0 <- apply(data, 2, function(x) {\n      grep2(q$search[['value']], as.character(x),\n            fixed = q$search[['regex']] == 'false', ignore.case = ci)\n    })\n    i <- intersect(i, unique(unlist(i0)))\n  }\n\n  # search by columns\n  if (length(i)) for (j in names(q$columns)) {\n    col <- q$columns[[j]]\n    # if the j-th column is not searchable or the search string is \"\", skip it\n    if (col[['searchable']] != 'true') next\n    if ((k <- col[['search']][['value']]) == '') next\n    j <- as.integer(j)\n    dj <- data[, j + 1]\n    r  <- commaToRange(k)\n    ij <- if (length(r) == 2 && is.numeric(dj)) {\n      which(dj >= r[1] & dj <= r[2])\n    } else {\n      grep2(k, as.character(dj), fixed = col[['search']][['regex']] == 'false',\n            ignore.case = ci)\n    }\n    i <- intersect(ij, i)\n    if (length(i) == 0) break\n  }\n  if (length(i) != n) data <- data[i, , drop = FALSE]\n\n  # sorting\n  oList <- list()\n  for (ord in q$order) {\n    k <- ord[['column']]  # which column to sort\n    d <- ord[['dir']]     # direction asc/desc\n    if (q$columns[[k]][['orderable']] != 'true') next\n    col <- data[, as.integer(k) + 1]\n    oList[[length(oList) + 1]] <- (if (d == 'asc') identity else `-`)(\n      if (is.numeric(col)) col else xtfrm(col)\n    )\n  }\n  if (length(oList)) {\n    i <- do.call(order, oList)\n    data <- data[i, , drop = FALSE]\n  }\n  # paging\n  if (q$length != '-1') {\n    i <- seq(as.integer(q$start) + 1L, length.out = as.integer(q$length))\n    i <- i[i <= nrow(data)]\n    fdata <- data[i, , drop = FALSE]  # filtered data\n  } else fdata <- data\n\n  fdata <- unname(as.matrix(fdata))\n  if (is.character(fdata) && q$escape != 'false') {\n    if (q$escape == 'true') fdata <- htmlEscape(fdata) else {\n      k <- as.integer(strsplit(q$escape, ',')[[1]])\n      # use seq_len() in case escape = negative indices, e.g. c(-1, -5)\n      for (j in seq_len(ncol(fdata))[k]) fdata[, j] <- htmlEscape(fdata[, j])\n    }\n  }\n\n  res <- toJSON(list(\n    draw = as.integer(q$draw),\n    recordsTotal = n,\n    recordsFiltered = nrow(data),\n    data = fdata\n  ))\n  httpResponse(200, 'application/json', enc2utf8(res))\n}\n\n# when both ignore.case and fixed are TRUE, we use grep(ignore.case = FALSE,\n# fixed = TRUE) to do lower-case matching of pattern on x\ngrep2 <- function(pattern, x, ignore.case = FALSE, fixed = FALSE, ...) {\n  if (fixed && ignore.case) {\n    pattern <- tolower(pattern)\n    x <- tolower(x)\n    ignore.case <- FALSE\n  }\n  # when the user types in the search box, the regular expression may not be\n  # complete before it is sent to the server, in which case we do not search\n  if (!fixed && inherits(try(grep(pattern, ''), silent = TRUE), 'try-error'))\n    return(seq_along(x))\n  grep(pattern, x, ignore.case = ignore.case, fixed = fixed, ...)\n}\n\ngetExists <- function(x, mode, envir = parent.frame()) {\n  if (exists(x, envir = envir, mode = mode, inherits = FALSE))\n    get(x, envir = envir, mode = mode, inherits = FALSE)\n}\n\n# convert a string of the form \"lower,upper\" to c(lower, upper)\ncommaToRange <- function(string) {\n  if (!grepl(',', string)) return()\n  r <- strsplit(string, ',')[[1]]\n  if (length(r) > 2) return()\n  if (length(r) == 1) r <- c(r, '')  # lower,\n  r <- as.numeric(r)\n  if (is.na(r[1])) r[1] <- -Inf\n  if (is.na(r[2])) r[2] <- Inf\n  r\n}\n\n# for options passed to DataTables/Selectize/..., the options of the class AsIs\n# will be evaluated as literal JavaScript code\ncheckAsIs <- function(options) {\n  evalOptions <- if (length(options)) {\n    nms <- names(options)\n    if (length(nms) == 0L || any(nms == '')) stop(\"'options' must be a named list\")\n    i <- unlist(lapply(options, function(x) {\n      is.character(x) && inherits(x, 'AsIs')\n    }))\n    if (any(i)) {\n      # must convert to character, otherwise toJSON() turns it to an array []\n      options[i] <- lapply(options[i], paste, collapse = '\\n')\n      nms[i]  # options of these names will be evaluated in JS\n    }\n  }\n  list(options = options, eval = evalOptions)\n}\n\nsrcrefFromShinyCall <- function(expr) {\n  srcrefs <- attr(expr, \"srcref\")\n  num_exprs <- length(srcrefs)\n  if (num_exprs < 1)\n    return(NULL)\n  c(srcrefs[[1]][1], srcrefs[[1]][2],\n    srcrefs[[num_exprs]][3], srcrefs[[num_exprs]][4],\n    srcrefs[[1]][5], srcrefs[[num_exprs]][6])\n}\n\n# Indicates whether the given querystring should cause the associated request\n# to be handled in showcase mode. Returns the showcase mode if set, or NULL\n# if no showcase mode is set.\nshowcaseModeOfQuerystring <- function(querystring) {\n  if (nchar(querystring) > 0) {\n    qs <- parseQueryString(querystring)\n    if (exists(\"showcase\", where = qs)) {\n      return(as.numeric(qs$showcase))\n    }\n  }\n  return(NULL)\n}\n\nshowcaseModeOfReq <- function(req) {\n  showcaseModeOfQuerystring(req$QUERY_STRING)\n}\n\n# Returns (just) the filename containing the given source reference, or an\n# empty string if the source reference doesn't include file information.\nsrcFileOfRef <- function(srcref) {\n  fileEnv <- attr(srcref, \"srcfile\")\n  # The 'srcfile' attribute should be a non-null environment containing the\n  # variable 'filename', which gives the full path to the source file.\n  if (!is.null(fileEnv) &&\n      is.environment(fileEnv) &&\n      exists(\"filename\", where = fileEnv))\n    basename(fileEnv[[\"filename\"]])\n  else\n    \"\"\n}\n\n# Format a number without sci notation, and keep as many digits as possible (do\n# we really need to go beyond 15 digits?)\nformatNoSci <- function(x) {\n  if (is.null(x)) return(NULL)\n  format(x, scientific = FALSE, digits = 15)\n}\n\n# Returns a function that calls the given func and caches the result for\n# subsequent calls, unless the given file's mtime changes.\ncachedFuncWithFile <- function(dir, file, func, case.sensitive = FALSE) {\n  dir <- normalizePath(dir, mustWork=TRUE)\n  mtime <- NA\n  value <- NULL\n  function(...) {\n    fname <- if (case.sensitive)\n      file.path(dir, file)\n    else\n      file.path.ci(dir, file)\n\n    now <- file.info(fname)$mtime\n    if (!identical(mtime, now)) {\n      value <<- func(fname, ...)\n      mtime <<- now\n    }\n    value\n  }\n}\n\n# turn column-based data to row-based data (mainly for JSON), e.g. data.frame(x\n# = 1:10, y = 10:1) ==> list(list(x = 1, y = 10), list(x = 2, y = 9), ...)\ncolumnToRowData <- function(data) {\n  do.call(\n    mapply, c(\n      list(FUN = function(...) list(...), SIMPLIFY = FALSE, USE.NAMES = FALSE),\n      as.list(data)\n    )\n  )\n}\n\n#' Validate input values and other conditions\n#'\n#' For an output rendering function (e.g. \\code{\\link{renderPlot}()}), you may\n#' need to check that certain input values are available and valid before you\n#' can render the output. \\code{validate} gives you a convenient mechanism for\n#' doing so.\n#'\n#' The \\code{validate} function takes any number of (unnamed) arguments, each of\n#' which represents a condition to test. If any of the conditions represent\n#' failure, then a special type of error is signaled which stops execution. If\n#' this error is not handled by application-specific code, it is displayed to\n#' the user by Shiny.\n#'\n#' An easy way to provide arguments to \\code{validate} is to use the \\code{need}\n#' function, which takes an expression and a string; if the expression is\n#' considered a failure, then the string will be used as the error message. The\n#' \\code{need} function considers its expression to be a failure if it is any of\n#' the following:\n#'\n#' \\itemize{\n#'   \\item{\\code{FALSE}}\n#'   \\item{\\code{NULL}}\n#'   \\item{\\code{\"\"}}\n#'   \\item{An empty atomic vector}\n#'   \\item{An atomic vector that contains only missing values}\n#'   \\item{A logical vector that contains all \\code{FALSE} or missing values}\n#'   \\item{An object of class \\code{\"try-error\"}}\n#'   \\item{A value that represents an unclicked \\code{\\link{actionButton}}}\n#' }\n#'\n#' If any of these values happen to be valid, you can explicitly turn them to\n#' logical values. For example, if you allow \\code{NA} but not \\code{NULL}, you\n#' can use the condition \\code{!is.null(input$foo)}, because \\code{!is.null(NA)\n#' == TRUE}.\n#'\n#' If you need validation logic that differs significantly from \\code{need}, you\n#' can create other validation test functions. A passing test should return\n#' \\code{NULL}. A failing test should return an error message as a\n#' single-element character vector, or if the failure should happen silently,\n#' \\code{FALSE}.\n#'\n#' Because validation failure is signaled as an error, you can use\n#' \\code{validate} in reactive expressions, and validation failures will\n#' automatically propagate to outputs that use the reactive expression. In\n#' other words, if reactive expression \\code{a} needs \\code{input$x}, and two\n#' outputs use \\code{a} (and thus depend indirectly on \\code{input$x}), it's\n#' not necessary for the outputs to validate \\code{input$x} explicitly, as long\n#' as \\code{a} does validate it.\n#'\n#' @param ... A list of tests. Each test should equal \\code{NULL} for success,\n#'   \\code{FALSE} for silent failure, or a string for failure with an error\n#'   message.\n#' @param errorClass A CSS class to apply. The actual CSS string will have\n#'   \\code{shiny-output-error-} prepended to this value.\n#' @export\n#' @examples\n#' # in ui.R\n#' fluidPage(\n#'   checkboxGroupInput('in1', 'Check some letters', choices = head(LETTERS)),\n#'   selectizeInput('in2', 'Select a state', choices = state.name),\n#'   plotOutput('plot')\n#' )\n#'\n#' # in server.R\n#' function(input, output) {\n#'   output$plot <- renderPlot({\n#'     validate(\n#'       need(input$in1, 'Check at least one letter!'),\n#'       need(input$in2 != '', 'Please choose a state.')\n#'     )\n#'     plot(1:10, main = paste(c(input$in1, input$in2), collapse = ', '))\n#'   })\n#' }\nvalidate <- function(..., errorClass = character(0)) {\n  results <- sapply(list(...), function(x) {\n    # Detect NULL or NA\n    if (is.null(x))\n      return(NA_character_)\n    else if (identical(x, FALSE))\n      return(\"\")\n    else if (is.character(x))\n      return(paste(as.character(x), collapse = \"\\n\"))\n    else\n      stop(\"Unexpected validation result: \", as.character(x))\n  })\n\n  results <- stats::na.omit(results)\n  if (length(results) == 0)\n    return(invisible())\n\n  # There may be empty strings remaining; these are message-less failures that\n  # started as FALSE\n  results <- results[nzchar(results)]\n\n  stopWithCondition(c(\"validation\", errorClass), paste(results, collapse=\"\\n\"))\n}\n\n#' @param expr An expression to test. The condition will pass if the expression\n#'   meets the conditions spelled out in Details.\n#' @param message A message to convey to the user if the validation condition is\n#'   not met. If no message is provided, one will be created using \\code{label}.\n#'   To fail with no message, use \\code{FALSE} for the message.\n#' @param label A human-readable name for the field that may be missing. This\n#'   parameter is not needed if \\code{message} is provided, but must be provided\n#'   otherwise.\n#' @export\n#' @rdname validate\nneed <- function(expr, message = paste(label, \"must be provided\"), label) {\n\n  force(message) # Fail fast on message/label both being missing\n\n  if (!isTruthy(expr))\n    return(message)\n  else\n    return(invisible(NULL))\n}\n\n#' Check for required values\n#'\n#' Ensure that values are available (\"truthy\"--see Details) before proceeding\n#' with a calculation or action. If any of the given values is not truthy, the\n#' operation is stopped by raising a \"silent\" exception (not logged by Shiny,\n#' nor displayed in the Shiny app's UI).\n#'\n#' The \\code{req} function was designed to be used in one of two ways. The first\n#' is to call it like a statement (ignoring its return value) before attempting\n#' operations using the required values:\n#'\n#' \\preformatted{rv <- reactiveValues(state = FALSE)\n#' r <- reactive({\n#'   req(input$a, input$b, rv$state)\n#'   # Code that uses input$a, input$b, and/or rv$state...\n#' })}\n#'\n#' In this example, if \\code{r()} is called and any of \\code{input$a},\n#' \\code{input$b}, and \\code{rv$state} are \\code{NULL}, \\code{FALSE}, \\code{\"\"},\n#' etc., then the \\code{req} call will trigger an error that propagates all the\n#' way up to whatever render block or observer is executing.\n#'\n#' The second is to use it to wrap an expression that must be truthy:\n#'\n#' \\preformatted{output$plot <- renderPlot({\n#'   if (req(input$plotType) == \"histogram\") {\n#'     hist(dataset())\n#'   } else if (input$plotType == \"scatter\") {\n#'     qplot(dataset(), aes(x = x, y = y))\n#'   }\n#' })}\n#'\n#' In this example, \\code{req(input$plotType)} first checks that\n#' \\code{input$plotType} is truthy, and if so, returns it. This is a convenient\n#' way to check for a value \"inline\" with its first use.\n#'\n#' \\strong{Truthy and falsy values}\n#'\n#' The terms \"truthy\" and \"falsy\" generally indicate whether a value, when\n#' coerced to a \\code{\\link{logical}}, is \\code{TRUE} or \\code{FALSE}. We use\n#' the term a little loosely here; our usage tries to match the intuitive\n#' notions of \"Is this value missing or available?\", or \"Has the user provided\n#' an answer?\", or in the case of action buttons, \"Has the button been\n#' clicked?\".\n#'\n#' For example, a \\code{textInput} that has not been filled out by the user has\n#' a value of \\code{\"\"}, so that is considered a falsy value.\n#'\n#' To be precise, \\code{req} considers a value truthy \\emph{unless} it is one\n#' of:\n#'\n#' \\itemize{\n#'   \\item{\\code{FALSE}}\n#'   \\item{\\code{NULL}}\n#'   \\item{\\code{\"\"}}\n#'   \\item{An empty atomic vector}\n#'   \\item{An atomic vector that contains only missing values}\n#'   \\item{A logical vector that contains all \\code{FALSE} or missing values}\n#'   \\item{An object of class \\code{\"try-error\"}}\n#'   \\item{A value that represents an unclicked \\code{\\link{actionButton}}}\n#' }\n#'\n#' Note in particular that the value \\code{0} is considered truthy, even though\n#' \\code{as.logical(0)} is \\code{FALSE}.\n#'\n#' If the built-in rules for truthiness do not match your requirements, you can\n#' always work around them. Since \\code{FALSE} is falsy, you can simply provide\n#' the results of your own checks to \\code{req}:\n#'\n#' \\code{req(input$a != 0)}\n#'\n#' @param ... Values to check for truthiness.\n#' @return The first value that was passed in.\n#'\n#' @export\nreq <- function(...) {\n  dotloop(function(item) {\n    if (!isTruthy(item))\n      stopWithCondition(\"validation\", \"\")\n  }, ...)\n\n  if (!missing(..1))\n    ..1\n  else\n    invisible()\n}\n\n# Execute a function against each element of ..., but only evaluate each element\n# after the previous element has been passed to fun_. The return value of fun_\n# is discarded, and only invisible() is returned from dotloop.\n#\n# Can be used to facilitate short-circuit eval on dots.\ndotloop <- function(fun_, ...) {\n  for (i in 1:(nargs()-1)) {\n    fun_(eval(as.symbol(paste0(\"..\", i))))\n  }\n  invisible()\n}\n\nisTruthy <- function(x) {\n  if (inherits(x, 'try-error'))\n    return(FALSE)\n\n  if (!is.atomic(x))\n    return(TRUE)\n\n  if (is.null(x))\n    return(FALSE)\n  if (length(x) == 0)\n    return(FALSE)\n  if (all(is.na(x)))\n    return(FALSE)\n  if (is.character(x) && !any(nzchar(stats::na.omit(x))))\n    return(FALSE)\n  if (inherits(x, 'shinyActionButtonValue') && x == 0)\n    return(FALSE)\n  if (is.logical(x) && !any(stats::na.omit(x)))\n    return(FALSE)\n\n  return(TRUE)\n}\n\n# add class(es) to the error condition, which will be used as names of CSS\n# classes, e.g. shiny-output-error shiny-output-error-validation\nstopWithCondition <- function(class, message) {\n  cond <- structure(\n    list(message = message),\n    class = c(class, 'shiny.silent.error', 'error', 'condition')\n  )\n  stop(cond)\n}\n\n#' Collect information about the Shiny Server environment\n#'\n#' This function returns the information about the current Shiny Server, such as\n#' its version, and whether it is the open source edition or professional\n#' edition. If the app is not served through the Shiny Server, this function\n#' just returns \\code{list(shinyServer = FALSE)}.\n#'\n#' This function will only return meaningful data when using Shiny Server\n#' version 1.2.2 or later.\n#' @export\n#' @return A list of the Shiny Server information.\nserverInfo <- function() {\n  .globals$serverInfo\n}\n.globals$serverInfo <- list(shinyServer = FALSE)\n\nsetServerInfo <- function(...) {\n  infoOld <- serverInfo()\n  infoNew <- list(...)\n  infoOld[names(infoNew)] <- infoNew\n  .globals$serverInfo <- infoOld\n}\n\n# assume file is encoded in UTF-8, but warn against BOM\ncheckEncoding <- function(file) {\n  # skip *nix because its locale is normally UTF-8 based (e.g. en_US.UTF-8), and\n  # *nix users have to make a conscious effort to save a file with an encoding\n  # that is not UTF-8; if they choose to do so, we cannot do much about it\n  # except sitting back and seeing them punished after they choose to escape a\n  # world of consistency (falling back to getOption('encoding') will not help\n  # because native.enc is also normally UTF-8 based on *nix)\n  if (!isWindows()) return('UTF-8')\n  size <- file.info(file)[, 'size']\n  if (is.na(size)) stop('Cannot access the file ', file)\n  # BOM is 3 bytes, so if the file contains BOM, it must be at least 3 bytes\n  if (size < 3L) return('UTF-8')\n\n  # check if there is a BOM character: this is also skipped on *nix, because R\n  # on *nix simply ignores this meaningless character if present, but it hurts\n  # on Windows\n  if (identical(charToRaw(readChar(file, 3L, TRUE)), charToRaw('\\UFEFF'))) {\n    warning('You should not include the Byte Order Mark (BOM) in ', file, '. ',\n            'Please re-save it in UTF-8 without BOM. See ',\n            'http://shiny.rstudio.com/articles/unicode.html for more info.')\n    return('UTF-8-BOM')\n  }\n  'UTF-8'\n}\n\n# read a file using UTF-8 and (on Windows) convert to native encoding if possible\nreadUTF8 <- function(file) {\n  enc <- checkEncoding(file)\n  file <- base::file(file, encoding = enc)\n  on.exit(close(file), add = TRUE)\n  x <- enc2utf8(readLines(file, warn = FALSE))\n  tryNativeEncoding(x)\n}\n\n# if the UTF-8 string can be represented in the native encoding, use native encoding\ntryNativeEncoding <- function(string) {\n  if (!isWindows()) return(string)\n  string2 <- enc2native(string)\n  if (identical(enc2utf8(string2), string)) string2 else string\n}\n\n# similarly, try to source() a file with UTF-8\nsourceUTF8 <- function(file, envir = globalenv()) {\n  lines <- readUTF8(file)\n  enc <- if (any(Encoding(lines) == 'UTF-8')) 'UTF-8' else 'unknown'\n  src <- srcfilecopy(file, lines, isFile = TRUE)  # source reference info\n  # oddly, parse(file) does not work when file contains multibyte chars that\n  # **can** be encoded natively on Windows (might be a bug in base R); we\n  # rewrite the source code in a natively encoded temp file and parse it in this\n  # case (the source reference is still pointed to the original file, though)\n  if (isWindows() && enc == 'unknown') {\n    file <- tempfile(); on.exit(unlink(file), add = TRUE)\n    writeLines(lines, file)\n  }\n  exprs <- parse(file, keep.source = FALSE, srcfile = src, encoding = enc)\n\n  # Wrap the exprs in first `{`, then ..stacktraceon..(). It's only really the\n  # ..stacktraceon..() that we care about, but the `{` is needed to make that\n  # possible.\n  exprs <- makeCall(`{`, exprs)\n  # Need to wrap exprs in a list because we want it treated as a single argument\n  exprs <- makeCall(..stacktraceon.., list(exprs))\n\n  eval(exprs, envir)\n}\n\n# @param func Name of function, in unquoted form\n# @param args An evaluated list of unevaluated argument expressions\nmakeCall <- function(func, args) {\n  as.call(c(list(substitute(func)), args))\n}\n\n# a workaround for https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=16264\nsrcfilecopy <- function(filename, lines, ...) {\n  if (getRversion() > '3.2.2') return(base::srcfilecopy(filename, lines, ...))\n  src <- base::srcfilecopy(filename, lines = '', ...)\n  src$lines <- lines\n  src\n}\n\n# write text as UTF-8\nwriteUTF8 <- function(text, ...) {\n  text <- enc2utf8(text)\n  writeLines(text, ..., useBytes = TRUE)\n}\n\nURLdecode <- decodeURIComponent\nURLencode <- function(value, reserved = FALSE) {\n  value <- enc2utf8(value)\n  if (reserved) encodeURIComponent(value) else encodeURI(value)\n}\n\n\n# This function takes a name and function, and it wraps that function in a new\n# function which calls the original function using the specified name. This can\n# be helpful for profiling, because the specified name will show up on the stack\n# trace.\nwrapFunctionLabel <- function(func, name, ..stacktraceon = FALSE) {\n  if (name == \"name\" || name == \"func\" || name == \"relabelWrapper\") {\n    stop(\"Invalid name for wrapFunctionLabel: \", name)\n  }\n  assign(name, func, environment())\n  registerDebugHook(name, environment(), name)\n\n  relabelWrapper <- eval(substitute(\n    function(...) {\n      # This `f` gets renamed to the value of `name`. Note that it may not\n      # print as the new name, because of source refs stored in the function.\n      if (..stacktraceon)\n        ..stacktraceon..(f(...))\n      else\n        f(...)\n    },\n    list(f = as.name(name))\n  ))\n\n  relabelWrapper\n}\n"},{"filename":"/R/imageutils.R","content":"#' Run a plotting function and save the output as a PNG\n#'\n#' This function returns the name of the PNG file that it generates. In\n#' essence, it calls \\code{png()}, then \\code{func()}, then \\code{dev.off()}.\n#' So \\code{func} must be a function that will generate a plot when used this\n#' way.\n#'\n#' For output, it will try to use the following devices, in this order:\n#' quartz (via \\code{\\link[grDevices]{png}}), then \\code{\\link[Cairo]{CairoPNG}},\n#' and finally \\code{\\link[grDevices]{png}}. This is in order of quality of\n#' output. Notably, plain \\code{png} output on Linux and Windows may not\n#' antialias some point shapes, resulting in poor quality output.\n#'\n#' In some cases, \\code{Cairo()} provides output that looks worse than\n#' \\code{png()}. To disable Cairo output for an app, use\n#' \\code{options(shiny.usecairo=FALSE)}.\n#'\n#' @param func A function that generates a plot.\n#' @param filename The name of the output file. Defaults to a temp file with\n#'   extension \\code{.png}.\n#' @param width Width in pixels.\n#' @param height Height in pixels.\n#' @param res Resolution in pixels per inch. This value is passed to\n#'   \\code{\\link{png}}. Note that this affects the resolution of PNG rendering in\n#'   R; it won't change the actual ppi of the browser.\n#' @param ... Arguments to be passed through to \\code{\\link[grDevices]{png}}.\n#'   These can be used to set the width, height, background color, etc.\n#'\n#' @export\nplotPNG <- function(func, filename=tempfile(fileext='.png'),\n                    width=400, height=400, res=72, ...) {\n  # If quartz is available, use png() (which will default to quartz).\n  # Otherwise, if the Cairo package is installed, use CairoPNG().\n  # Finally, if neither quartz nor Cairo, use png().\n  if (capabilities(\"aqua\")) {\n    pngfun <- grDevices::png\n  } else if ((getOption('shiny.usecairo') %OR% TRUE) &&\n             nchar(system.file(package = \"Cairo\"))) {\n    pngfun <- Cairo::CairoPNG\n  } else {\n    pngfun <- grDevices::png\n  }\n\n  pngfun(filename=filename, width=width, height=height, res=res, ...)\n  # Call plot.new() so that even if no plotting operations are performed at\n  # least we have a blank background. N.B. we need to set the margin to 0\n  # temporarily before plot.new() because when the plot size is small (e.g.\n  # 200x50), we will get an error \"figure margin too large\", which is triggered\n  # by plot.new() with the default (large) margin. However, this does not\n  # guarantee user's code in func() will not trigger the error -- they may have\n  # to set par(mar = smaller_value) before they draw base graphics.\n  op <- graphics::par(mar = rep(0, 4))\n  tryCatch(\n    graphics::plot.new(),\n    finally = graphics::par(op)\n  )\n\n  dv <- grDevices::dev.cur()\n  on.exit(grDevices::dev.off(dv), add = TRUE)\n  func()\n\n  filename\n}\n"},{"filename":"/R/render-plot.R","content":"#' Plot Output\n#'\n#' Renders a reactive plot that is suitable for assigning to an \\code{output}\n#' slot.\n#'\n#' The corresponding HTML output tag should be \\code{div} or \\code{img} and have\n#' the CSS class name \\code{shiny-plot-output}.\n#'\n#' @section Interactive plots:\n#'\n#'   With ggplot2 graphics, the code in \\code{renderPlot} should return a ggplot\n#'   object; if instead the code prints the ggplot2 object with something like\n#'   \\code{print(p)}, then the coordinates for interactive graphics will not be\n#'   properly scaled to the data space.\n#'\n#'   See \\code{\\link{plotOutput}} for more information about interactive plots.\n#'\n#' @seealso For the corresponding client-side output function, and example\n#'   usage, see \\code{\\link{plotOutput}}. For more details on how the plots are\n#'   generated, and how to control the output, see \\code{\\link{plotPNG}}.\n#'\n#' @param expr An expression that generates a plot.\n#' @param width,height The width/height of the rendered plot, in pixels; or\n#'   \\code{'auto'} to use the \\code{offsetWidth}/\\code{offsetHeight} of the HTML\n#'   element that is bound to this plot. You can also pass in a function that\n#'   returns the width/height in pixels or \\code{'auto'}; in the body of the\n#'   function you may reference reactive values and functions. When rendering an\n#'   inline plot, you must provide numeric values (in pixels) to both\n#'   \\code{width} and \\code{height}.\n#' @param res Resolution of resulting plot, in pixels per inch. This value is\n#'   passed to \\code{\\link{png}}. Note that this affects the resolution of PNG\n#'   rendering in R; it won't change the actual ppi of the browser.\n#' @param ... Arguments to be passed through to \\code{\\link[grDevices]{png}}.\n#'   These can be used to set the width, height, background color, etc.\n#' @param env The environment in which to evaluate \\code{expr}.\n#' @param quoted Is \\code{expr} a quoted expression (with \\code{quote()})? This\n#'   is useful if you want to save an expression in a variable.\n#' @param func A function that generates a plot (deprecated; use \\code{expr}\n#'   instead).\n#'\n#' @export\nrenderPlot <- function(expr, width='auto', height='auto', res=72, ...,\n                       env=parent.frame(), quoted=FALSE, func=NULL) {\n  # This ..stacktraceon is matched by a ..stacktraceoff.. when plotFunc\n  # is called\n  installExprFunction(expr, \"func\", env, quoted, ..stacktraceon = TRUE)\n\n  args <- list(...)\n\n  if (is.function(width))\n    widthWrapper <- reactive({ width() })\n  else\n    widthWrapper <- function() { width }\n\n  if (is.function(height))\n    heightWrapper <- reactive({ height() })\n  else\n    heightWrapper <- function() { height }\n\n  # A modified version of print.ggplot which returns the built ggplot object\n  # as well as the gtable grob. This overrides the ggplot::print.ggplot\n  # method, but only within the context of renderPlot. The reason this needs\n  # to be a (pseudo) S3 method is so that, if an object has a class in\n  # addition to ggplot, and there's a print method for that class, that we\n  # won't override that method. https://github.com/rstudio/shiny/issues/841\n  print.ggplot <- function(x) {\n    grid::grid.newpage()\n\n    build <- ggplot2::ggplot_build(x)\n\n    gtable <- ggplot2::ggplot_gtable(build)\n    grid::grid.draw(gtable)\n\n    structure(list(\n      build = build,\n      gtable = gtable\n    ), class = \"ggplot_build_gtable\")\n  }\n\n\n  # Vars to store session and output, so that they can be accessed from\n  # the render() reactive.\n  session <- NULL\n  outputName <- NULL\n\n  # This function is the one that's returned from renderPlot(), and gets\n  # wrapped in an observer when the output value is assigned. The expression\n  # passed to renderPlot() is actually run in render(); this function can only\n  # replay a plot if the width/height changes.\n  renderFunc <- function(shinysession, name, ...) {\n    session <<- shinysession\n    outputName <<- name\n\n    # The reactive that runs the expr in renderPlot()\n    plotData <- render()\n\n    width <- widthWrapper()\n    height <- heightWrapper()\n    # Note that these are reactive calls. A change to the width and height\n    # will inherently cause a reactive plot to redraw (unless width and\n    # height were explicitly specified).\n    if (width == 'auto')\n      width <- session$clientData[[paste0('output_', outputName, '_width')]]\n    if (height == 'auto')\n      height <- session$clientData[[paste0('output_', outputName, '_height')]]\n\n    if (is.null(width) || is.null(height) || width <= 0 || height <= 0)\n      return(NULL)\n\n    img <- plotData$img\n\n    # If only the width/height have changed, simply replay the plot and make a\n    # new img.\n    if (width != img$width || height != img$height) {\n      pixelratio <- session$clientData$pixelratio %OR% 1\n\n      coordmap <- NULL\n      plotFunc <- function() {\n        ..stacktraceon..(replayPlot(plotData$recordedPlot))\n\n        # Coordmap must be recalculated after replaying plot, because pixel\n        # dimensions will have changed.\n        if (inherits(plotData$plotResult, \"ggplot_build_gtable\")) {\n          coordmap <<- getGgplotCoordmap(plotData$plotResult, pixelratio)\n        } else {\n          coordmap <<- getPrevPlotCoordmap(width, height)\n        }\n      }\n      outfile <- ..stacktraceoff..(\n        plotPNG(plotFunc, width = width*pixelratio, height = height*pixelratio,\n                res = res*pixelratio)\n      )\n      on.exit(unlink(outfile))\n\n      img <- dropNulls(list(\n        src = session$fileUrl(name, outfile, contentType='image/png'),\n        width = width,\n        height = height,\n        coordmap = coordmap,\n        # Get coordmap error message if present\n        error = attr(coordmap, \"error\", exact = TRUE)\n      ))\n    }\n\n    img\n  }\n\n\n  render <- reactive({\n    isolate({\n      width <- widthWrapper()\n      height <- heightWrapper()\n\n      if (width == 'auto')\n        width <- session$clientData[[paste0('output_', outputName, '_width')]]\n      if (height == 'auto')\n        height <- session$clientData[[paste0('output_', outputName, '_height')]]\n    })\n\n    if (is.null(width) || is.null(height) || width <= 0 || height <= 0)\n      return(NULL)\n\n    # Resolution multiplier\n    pixelratio <- session$clientData$pixelratio %OR% 1\n\n    plotResult <- NULL\n    recordedPlot <- NULL\n    plotFunc <- function() {\n      # Actually perform the plotting\n      result <- withVisible(func())\n\n      if (result$visible) {\n        # Use capture.output to squelch printing to the actual console; we\n        # are only interested in plot output\n        utils::capture.output({\n          # This ..stacktraceon.. negates the ..stacktraceoff.. that wraps\n          # the call to plotFunc. The value needs to be printed just in case\n          # it's an object that requires printing to generate plot output,\n          # similar to ggplot2. But for base graphics, it would already have\n          # been rendered when func was called above, and the print should\n          # have no effect.\n          plotResult <<- ..stacktraceon..(print(result$value))\n        })\n      }\n\n      recordedPlot <<- recordPlot()\n\n      if (inherits(plotResult, \"ggplot_build_gtable\")) {\n        coordmap <<- getGgplotCoordmap(plotResult, pixelratio)\n      } else {\n        coordmap <<- getPrevPlotCoordmap(width, height)\n      }\n    }\n\n    # This ..stacktraceoff.. is matched by the `func` function's\n    # wrapFunctionLabel(..stacktraceon=TRUE) call near the beginning of\n    # renderPlot, and by the ..stacktraceon.. in plotFunc where ggplot objects\n    # are printed\n    outfile <- ..stacktraceoff..(\n      do.call(plotPNG, c(plotFunc, width=width*pixelratio,\n        height=height*pixelratio, res=res*pixelratio, args))\n    )\n    on.exit(unlink(outfile))\n\n    list(\n      # img is the content that gets sent to the client.\n      img = dropNulls(list(\n        src = session$fileUrl(name, outfile, contentType='image/png'),\n        width = width,\n        height = height,\n        coordmap = coordmap,\n        # Get coordmap error message if present.\n        error = attr(coordmap, \"error\", exact = TRUE)\n      )),\n      # Returned value from expression in renderPlot() -- may be a printable\n      # object like ggplot2. Needed just in case we replayPlot and need to get\n      # a coordmap again.\n      plotResult = plotResult,\n      recordedPlot = recordedPlot\n    )\n  })\n\n\n  # If renderPlot isn't going to adapt to the height of the div, then the\n  # div needs to adapt to the height of renderPlot. By default, plotOutput\n  # sets the height to 400px, so to make it adapt we need to override it\n  # with NULL.\n  outputFunc <- plotOutput\n  if (!identical(height, 'auto')) formals(outputFunc)['height'] <- list(NULL)\n\n  markRenderFunction(outputFunc, renderFunc)\n}\n\n# The coordmap extraction functions below return something like the examples\n# below. For base graphics:\n# plot(mtcars$wt, mtcars$mpg)\n# str(getPrevPlotCoordmap(400, 300))\n# List of 1\n#  $ :List of 4\n#   ..$ domain :List of 4\n#   .. ..$ left  : num 1.36\n#   .. ..$ right : num 5.58\n#   .. ..$ bottom: num 9.46\n#   .. ..$ top   : num 34.8\n#   ..$ range  :List of 4\n#   .. ..$ left  : num 50.4\n#   .. ..$ right : num 373\n#   .. ..$ bottom: num 199\n#   .. ..$ top   : num 79.6\n#   ..$ log    :List of 2\n#   .. ..$ x: NULL\n#   .. ..$ y: NULL\n#   ..$ mapping: Named list()\n#\n# For ggplot2, it might be something like:\n# p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()\n# str(getGgplotCoordmap(p, 1))\n# List of 1\n#  $ :List of 10\n#   ..$ panel     : int 1\n#   ..$ row       : int 1\n#   ..$ col       : int 1\n#   ..$ panel_vars: Named list()\n#   ..$ scale_x   : int 1\n#   ..$ scale_y   : int 1\n#   ..$ log       :List of 2\n#   .. ..$ x: NULL\n#   .. ..$ y: NULL\n#   ..$ domain    :List of 4\n#   .. ..$ left  : num 1.32\n#   .. ..$ right : num 5.62\n#   .. ..$ bottom: num 9.22\n#   .. ..$ top   : num 35.1\n#   ..$ mapping   :List of 2\n#   .. ..$ x: chr \"wt\"\n#   .. ..$ y: chr \"mpg\"\n#   ..$ range     :List of 4\n#   .. ..$ left  : num 40.8\n#   .. ..$ right : num 446\n#   .. ..$ bottom: num 263\n#   .. ..$ top   : num 14.4\n#\n# With a faceted ggplot2 plot, the outer list contains two objects, each of\n# which represents one panel. In this example, there is one panelvar, but there\n# can be up to two of them.\n# mtc <- mtcars\n# mtc$am <- factor(mtc$am)\n# p <- ggplot(mtcars, aes(wt, mpg)) + geom_point() + facet_wrap(~ am)\n# str(getGgplotCoordmap(p, 1))\n# List of 2\n#  $ :List of 10\n#   ..$ panel     : int 1\n#   ..$ row       : int 1\n#   ..$ col       : int 1\n#   ..$ panel_vars:List of 1\n#   .. ..$ panelvar1: Factor w/ 2 levels \"0\",\"1\": 1\n#   ..$ scale_x   : int 1\n#   ..$ scale_y   : int 1\n#   ..$ log       :List of 2\n#   .. ..$ x: NULL\n#   .. ..$ y: NULL\n#   ..$ domain    :List of 4\n#   .. ..$ left  : num 1.32\n#   .. ..$ right : num 5.62\n#   .. ..$ bottom: num 9.22\n#   .. ..$ top   : num 35.1\n#   ..$ mapping   :List of 3\n#   .. ..$ x        : chr \"wt\"\n#   .. ..$ y        : chr \"mpg\"\n#   .. ..$ panelvar1: chr \"am\"\n#   ..$ range     :List of 4\n#   .. ..$ left  : num 45.6\n#   .. ..$ right : num 317\n#   .. ..$ bottom: num 251\n#   .. ..$ top   : num 35.7\n#  $ :List of 10\n#   ..$ panel     : int 2\n#   ..$ row       : int 1\n#   ..$ col       : int 2\n#   ..$ panel_vars:List of 1\n#   .. ..$ panelvar1: Factor w/ 2 levels \"0\",\"1\": 2\n#   ..$ scale_x   : int 1\n#   ..$ scale_y   : int 1\n#   ..$ log       :List of 2\n#   .. ..$ x: NULL\n#   .. ..$ y: NULL\n#   ..$ domain    :List of 4\n#   .. ..$ left  : num 1.32\n#   .. ..$ right : num 5.62\n#   .. ..$ bottom: num 9.22\n#   .. ..$ top   : num 35.1\n#   ..$ mapping   :List of 3\n#   .. ..$ x        : chr \"wt\"\n#   .. ..$ y        : chr \"mpg\"\n#   .. ..$ panelvar1: chr \"am\"\n#   ..$ range     :List of 4\n#   .. ..$ left  : num 322\n#   .. ..$ right : num 594\n#   .. ..$ bottom: num 251\n#   .. ..$ top   : num 35.7\n\n\n# Get a coordmap for the previous plot made with base graphics.\n# Requires width and height of output image, in pixels.\n# Must be called before the graphics device is closed.\ngetPrevPlotCoordmap <- function(width, height) {\n  usrCoords <- graphics::par('usr')\n  usrBounds <- usrCoords\n  if (graphics::par('xlog')) {\n    usrBounds[c(1,2)] <- 10 ^ usrBounds[c(1,2)]\n  }\n  if (graphics::par('ylog')) {\n    usrBounds[c(3,4)] <- 10 ^ usrBounds[c(3,4)]\n  }\n\n  # Wrapped in double list because other types of plots can have multiple panels.\n  list(list(\n    # Bounds of the plot area, in data space\n    domain = list(\n      left = usrCoords[1],\n      right = usrCoords[2],\n      bottom = usrCoords[3],\n      top = usrCoords[4]\n    ),\n    # The bounds of the plot area, in DOM pixels\n    range = list(\n      left = graphics::grconvertX(usrBounds[1], 'user', 'nfc') * width,\n      right = graphics::grconvertX(usrBounds[2], 'user', 'nfc') * width,\n      bottom = (1-graphics::grconvertY(usrBounds[3], 'user', 'nfc')) * height - 1,\n      top = (1-graphics::grconvertY(usrBounds[4], 'user', 'nfc')) * height - 1\n    ),\n    log = list(\n      x = if (graphics::par('xlog')) 10 else NULL,\n      y = if (graphics::par('ylog')) 10 else NULL\n    ),\n    # We can't extract the original variable names from a base graphic.\n    # `mapping` is an empty _named_ list, so that it is converted to an object\n    # (not an array) in JSON.\n    mapping = list(x = NULL)[0]\n  ))\n}\n\n\n# Given a ggplot_build_gtable object, return a coordmap for it.\ngetGgplotCoordmap <- function(p, pixelratio) {\n  if (!inherits(p, \"ggplot_build_gtable\"))\n    return(NULL)\n\n  # Given a built ggplot object, return x and y domains (data space coords) for\n  # each panel.\n  find_panel_info <- function(b) {\n    layout <- b$panel$layout\n    # Convert factor to numbers\n    layout$PANEL <- as.integer(as.character(layout$PANEL))\n\n    # Names of facets\n    facet <- b$plot$facet\n    facet_vars <- NULL\n    if (inherits(facet, \"grid\")) {\n      facet_vars <- vapply(c(facet$cols, facet$rows), as.character, character(1))\n    } else if (inherits(facet, \"wrap\")) {\n      facet_vars <- vapply(facet$facets, as.character, character(1))\n    }\n\n    # Iterate over each row in the layout data frame\n    lapply(seq_len(nrow(layout)), function(i) {\n      # Slice out one row\n      l <- layout[i, ]\n\n      scale_x <- l$SCALE_X\n      scale_y <- l$SCALE_Y\n\n      mapping <- find_plot_mappings(b)\n\n      # For each of the faceting variables, get the value of that variable in\n      # the current panel. Default to empty _named_ list so that it's sent as a\n      # JSON object, not array.\n      panel_vars <- list(a = NULL)[0]\n      for (i in seq_along(facet_vars)) {\n        var_name <- facet_vars[[i]]\n        vname <- paste0(\"panelvar\", i)\n\n        mapping[[vname]] <- var_name\n        panel_vars[[vname]] <- l[[var_name]]\n      }\n\n      list(\n        panel   = l$PANEL,\n        row     = l$ROW,\n        col     = l$COL,\n        panel_vars = panel_vars,\n        scale_x = scale_x,\n        scale_y = scale_x,\n        log     = check_log_scales(b, scale_x, scale_y),\n        domain  = find_panel_domain(b, l$PANEL, scale_x, scale_y),\n        mapping = mapping\n      )\n    })\n  }\n\n  # Given a single range object (representing the data domain) from a built\n  # ggplot object, return the domain.\n  find_panel_domain <- function(b, panel_num, scalex_num = 1, scaley_num = 1) {\n    range <- b$panel$ranges[[panel_num]]\n    res <- list(\n      left   = range$x.range[1],\n      right  = range$x.range[2],\n      bottom = range$y.range[1],\n      top    = range$y.range[2]\n    )\n\n    # Check for reversed scales\n    xscale <- b$panel$x_scales[[scalex_num]]\n    yscale <- b$panel$y_scales[[scaley_num]]\n\n    if (!is.null(xscale$trans) && xscale$trans$name == \"reverse\") {\n      res$left  <- -res$left\n      res$right <- -res$right\n    }\n    if (!is.null(yscale$trans) && yscale$trans$name == \"reverse\") {\n      res$top    <- -res$top\n      res$bottom <- -res$bottom\n    }\n\n    res\n  }\n\n  # Given built ggplot object, return object with the log base for x and y if\n  # there are log scales or coord transforms.\n  check_log_scales <- function(b, scalex_num = 1, scaley_num = 1) {\n\n    # Given a vector of transformation names like c(\"log-10\", \"identity\"),\n    # return the first log base, like 10. If none are present, return NULL.\n    extract_log_base <- function(names) {\n      names <- names[grepl(\"^log-\", names)]\n\n      if (length(names) == 0)\n        return(NULL)\n\n      names <- names[1]\n\n      as.numeric(sub(\"^log-\", \"\", names))\n    }\n\n    # Look for log scales and log coord transforms. People shouldn't use both.\n    x_names <- character(0)\n    y_names <- character(0)\n\n    # Continuous scales have a trans; discrete ones don't\n    if (!is.null(b$panel$x_scales[[scalex_num]]$trans))\n      x_names <- b$panel$x_scales[[scalex_num]]$trans$name\n    if (!is.null(b$panel$y_scales[[scaley_num]]$trans))\n      y_names <- b$panel$y_scales[[scaley_num]]$trans$name\n\n    coords <- b$plot$coordinates\n    if (!is.null(coords$trans)) {\n      if (!is.null(coords$trans$x))\n        x_names <- c(x_names, coords$trans$x$name)\n      if (!is.null(coords$trans$y))\n        y_names <- c(y_names, coords$trans$y$name)\n    }\n\n    # Keep only scale/trans names that start with \"log-\"\n    x_names <- x_names[grepl(\"^log-\", x_names)]\n    y_names <- y_names[grepl(\"^log-\", y_names)]\n\n    # Extract the log base from the trans name -- a string like \"log-10\".\n    list(\n      x = extract_log_base(x_names),\n      y = extract_log_base(y_names)\n    )\n  }\n\n  # Given a built ggplot object, return a named list of variables mapped to x\n  # and y. This function will be called for each panel, but in practice the\n  # result is always the same across panels, so we'll cache the result.\n  mappings_cache <- NULL\n  find_plot_mappings <- function(b) {\n    if (!is.null(mappings_cache))\n      return(mappings_cache)\n\n    # lapply'ing as.character results in unexpected behavior for expressions\n    # like `wt/2`. This works better.\n    mappings <- as.list(as.character(b$plot$mapping))\n\n    # If x or y mapping is missing, look in each layer for mappings and return\n    # the first one.\n    missing_mappings <- setdiff(c(\"x\", \"y\"), names(mappings))\n    if (length(missing_mappings) != 0) {\n      # Grab mappings for each layer\n      layer_mappings <- lapply(b$plot$layers, function(layer) {\n        lapply(layer$mapping, as.character)\n      })\n\n      # Get just the first x or y value in the combined list of plot and layer\n      # mappings.\n      mappings <- c(list(mappings), layer_mappings)\n      mappings <- Reduce(x = mappings, init = list(x = NULL, y = NULL),\n        function(init, m) {\n          if (is.null(init$x) && !is.null(m$x)) init$x <- m$x\n          if (is.null(init$y) && !is.null(m$y)) init$y <- m$y\n          init\n        }\n      )\n    }\n\n    mappings_cache <<- mappings\n    mappings\n  }\n\n  # Given a gtable object, return the x and y ranges (in pixel dimensions)\n  find_panel_ranges <- function(g, pixelratio) {\n    # Given a vector of unit objects, return logical vector indicating which ones\n    # are \"null\" units. These units use the remaining available width/height --\n    # that is, the space not occupied by elements that have an absolute size.\n    is_null_unit <- function(x) {\n      # A vector of units can be either a list of individual units (a unit.list\n      # object), each with their own set of attributes, or an atomic vector with\n      # one set of attributes. ggplot2 switched from the former (in version\n      # 1.0.1) to the latter. We need to make sure that we get the correct\n      # result in both cases.\n      if (inherits(x, \"unit.list\")) {\n        # For ggplot2 <= 1.0.1\n        vapply(x, FUN.VALUE = logical(1), function(u) {\n          isTRUE(attr(u, \"unit\", exact = TRUE) == \"null\")\n        })\n      } else {\n        # For later versions of ggplot2\n        attr(x, \"unit\", exact = TRUE) == \"null\"\n      }\n    }\n\n    # Convert a unit (or vector of units) to a numeric vector of pixel sizes\n    h_px <- function(x) as.numeric(grid::convertHeight(x, \"native\"))\n    w_px <- function(x) as.numeric(grid::convertWidth(x, \"native\"))\n\n    # Given a vector of relative sizes (in grid units), and a function for\n    # converting grid units to numeric pixels, return a numeric vector of\n    # pixel sizes.\n    find_px_sizes <- function(rel_sizes, unit_to_px) {\n      # Total pixels (in height or width)\n      total_px <- unit_to_px(grid::unit(1, \"npc\"))\n      # Calculate size of all panel(s) together. Panels (and only panels) have\n      # null size.\n      null_idx <- is_null_unit(rel_sizes)\n      # All the absolute heights. At this point, null heights are 0. We need to\n      # calculate them separately and add them in later.\n      px_sizes <- unit_to_px(rel_sizes)\n      # Total size for panels is image size minus absolute (non-panel) elements\n      panel_px_total <- total_px - sum(px_sizes)\n      # Divide up the total panel size up into the panels (scaled by size)\n      panel_sizes_rel <- as.numeric(rel_sizes[null_idx])\n      panel_sizes_rel <- panel_sizes_rel / sum(panel_sizes_rel)\n      px_sizes[null_idx] <- panel_px_total * panel_sizes_rel\n      abs(px_sizes)\n    }\n\n    px_heights <- find_px_sizes(g$heights, h_px)\n    px_widths <- find_px_sizes(g$widths, w_px)\n\n    # Convert to absolute pixel positions\n    x_pos <- cumsum(px_widths)\n    y_pos <- cumsum(px_heights)\n\n    # Match up the pixel dimensions to panels\n    layout <- g$layout\n    # For panels:\n    # * For facet_wrap, they'll be named \"panel-1\", \"panel-2\", etc.\n    # * For no facet or facet_grid, they'll just be named \"panel\". For\n    #   facet_grid, we need to re-order the layout table. Assume that panel\n    #   numbers go from left to right, then next row.\n    # Assign a number to each panel, corresponding to PANEl in the built ggplot\n    # object.\n    layout <- layout[grepl(\"^panel\", layout$name), ]\n    layout <- layout[order(layout$t, layout$l), ]\n    layout$panel <- seq_len(nrow(layout))\n\n    # When using a HiDPI client on a Linux server, the pixel\n    # dimensions are doubled, so we have to divide the dimensions by\n    # `pixelratio`. When a HiDPI client is used on a Mac server (with\n    # the quartz device), the pixel dimensions _aren't_ doubled, even though\n    # the image has double size. In the latter case we don't have to scale the\n    # numbers down.\n    pix_ratio <- 1\n    if (!grepl(\"^quartz\", names(grDevices::dev.cur()))) {\n      pix_ratio <- pixelratio\n    }\n\n    # Return list of lists, where each inner list has left, right, top, bottom\n    # values for a panel\n    lapply(seq_len(nrow(layout)), function(i) {\n      p <- layout[i, , drop = FALSE]\n      list(\n        left   = x_pos[p$l - 1] / pix_ratio,\n        right  = x_pos[p$r] / pix_ratio,\n        bottom = y_pos[p$b] / pix_ratio,\n        top    = y_pos[p$t - 1] / pix_ratio\n      )\n    })\n  }\n\n\n  tryCatch({\n    # Get info from built ggplot object\n    info <- find_panel_info(p$build)\n\n    # Get ranges from gtable - it's possible for this to return more elements than\n    # info, because it calculates positions even for panels that aren't present.\n    # This can happen with facet_wrap.\n    ranges <- find_panel_ranges(p$gtable, pixelratio)\n\n    for (i in seq_along(info)) {\n      info[[i]]$range <- ranges[[i]]\n    }\n\n    return(info)\n\n  }, error = function(e) {\n    # If there was an error extracting info from the ggplot object, just return\n    # a list with the error message.\n    return(structure(list(), error = e$message))\n  })\n}\n"},{"filename":"/R/reactives.R","content":"#' @include utils.R\nNULL\n\nDependents <- R6Class(\n  'Dependents',\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    .dependents = 'Map',\n\n    initialize = function() {\n      .dependents <<- Map$new()\n    },\n    register = function(depId=NULL, depLabel=NULL) {\n      ctx <- .getReactiveEnvironment()$currentContext()\n      if (!.dependents$containsKey(ctx$id)) {\n        .dependents$set(ctx$id, ctx)\n        ctx$onInvalidate(function() {\n          .dependents$remove(ctx$id)\n        })\n\n        if (!is.null(depId) && nchar(depId) > 0)\n          .graphDependsOnId(ctx$id, depId)\n        if (!is.null(depLabel))\n          .graphDependsOn(ctx$id, depLabel)\n      }\n    },\n    invalidate = function() {\n      lapply(\n        .dependents$values(),\n        function(ctx) {\n          ctx$invalidate()\n          NULL\n        }\n      )\n    }\n  )\n)\n\n\n# ReactiveValues ------------------------------------------------------------\n\nReactiveValues <- R6Class(\n  'ReactiveValues',\n  portable = FALSE,\n  public = list(\n    # For debug purposes\n    .label = character(0),\n    .values = 'environment',\n    .dependents = 'environment',\n    # Dependents for the list of all names, including hidden\n    .namesDeps = 'Dependents',\n    # Dependents for all values, including hidden\n    .allValuesDeps = 'Dependents',\n    # Dependents for all values\n    .valuesDeps = 'Dependents',\n\n    initialize = function() {\n      .label <<- paste('reactiveValues',\n                       p_randomInt(1000, 10000),\n                       sep=\"\")\n      .values <<- new.env(parent=emptyenv())\n      .dependents <<- new.env(parent=emptyenv())\n      .namesDeps <<- Dependents$new()\n      .allValuesDeps <<- Dependents$new()\n      .valuesDeps <<- Dependents$new()\n    },\n    get = function(key) {\n      ctx <- .getReactiveEnvironment()$currentContext()\n      dep.key <- paste(key, ':', ctx$id, sep='')\n      if (!exists(dep.key, where=.dependents, inherits=FALSE)) {\n        .graphDependsOn(ctx$id, sprintf('%s$%s', .label, key))\n        assign(dep.key, ctx, pos=.dependents, inherits=FALSE)\n        ctx$onInvalidate(function() {\n          rm(list=dep.key, pos=.dependents, inherits=FALSE)\n        })\n      }\n\n      if (!exists(key, where=.values, inherits=FALSE))\n        NULL\n      else\n        base::get(key, pos=.values, inherits=FALSE)\n    },\n    set = function(key, value) {\n      hidden <- substr(key, 1, 1) == \".\"\n\n      if (exists(key, where=.values, inherits=FALSE)) {\n        if (identical(base::get(key, pos=.values, inherits=FALSE), value)) {\n          return(invisible())\n        }\n      }\n      else {\n        .namesDeps$invalidate()\n      }\n\n      if (hidden)\n        .allValuesDeps$invalidate()\n      else\n        .valuesDeps$invalidate()\n\n      assign(key, value, pos=.values, inherits=FALSE)\n\n      .graphValueChange(sprintf('names(%s)', .label), ls(.values, all.names=TRUE))\n      .graphValueChange(sprintf('%s (all)', .label), as.list(.values))\n      .graphValueChange(sprintf('%s$%s', .label, key), value)\n\n      dep.keys <- objects(\n        pos=.dependents,\n        pattern=paste('^\\\\Q', key, ':', '\\\\E', '\\\\d+$', sep=''),\n        all.names=TRUE\n      )\n      lapply(\n        mget(dep.keys, envir=.dependents),\n        function(ctx) {\n          ctx$invalidate()\n          NULL\n        }\n      )\n      invisible()\n    },\n    mset = function(lst) {\n      lapply(base::names(lst),\n             function(name) {\n               self$set(name, lst[[name]])\n             })\n    },\n    names = function() {\n      .graphDependsOn(.getReactiveEnvironment()$currentContext()$id,\n                      sprintf('names(%s)', .label))\n      .namesDeps$register()\n      return(ls(.values, all.names=TRUE))\n    },\n    toList = function(all.names=FALSE) {\n      .graphDependsOn(.getReactiveEnvironment()$currentContext()$id,\n                      sprintf('%s (all)', .label))\n      if (all.names)\n        .allValuesDeps$register()\n\n      .valuesDeps$register()\n\n      return(as.list(.values, all.names=all.names))\n    },\n    .setLabel = function(label) {\n      .label <<- label\n    }\n  )\n)\n\n\n# reactivevalues ------------------------------------------------------------\n# S3 wrapper class for ReactiveValues reference class\n\n#' Create an object for storing reactive values\n#'\n#' This function returns an object for storing reactive values. It is similar to\n#' a list, but with special capabilities for reactive programming. When you read\n#' a value from it, the calling reactive expression takes a reactive dependency\n#' on that value, and when you write to it, it notifies any reactive functions\n#' that depend on that value. Note that values taken from the reactiveValues\n#' object are reactive, but the reactiveValues object itself is not.\n#'\n#' @examples\n#' # Create the object with no values\n#' values <- reactiveValues()\n#'\n#' # Assign values to 'a' and 'b'\n#' values$a <- 3\n#' values[['b']] <- 4\n#'\n#' \\dontrun{\n#' # From within a reactive context, you can access values with:\n#' values$a\n#' values[['a']]\n#' }\n#'\n#' # If not in a reactive context (e.g., at the console), you can use isolate()\n#' # to retrieve the value:\n#' isolate(values$a)\n#' isolate(values[['a']])\n#'\n#' # Set values upon creation\n#' values <- reactiveValues(a = 1, b = 2)\n#' isolate(values$a)\n#'\n#' @param ... Objects that will be added to the reactivevalues object. All of\n#'   these objects must be named.\n#'\n#' @seealso \\code{\\link{isolate}} and \\code{\\link{is.reactivevalues}}.\n#'\n#' @export\nreactiveValues <- function(...) {\n  args <- list(...)\n  if ((length(args) > 0) && (is.null(names(args)) || any(names(args) == \"\")))\n    stop(\"All arguments passed to reactiveValues() must be named.\")\n\n  values <- .createReactiveValues(ReactiveValues$new())\n\n  # Use .subset2() instead of [[, to avoid method dispatch\n  .subset2(values, 'impl')$mset(args)\n  values\n}\n\ncheckName <- function(x) {\n  if (!is.character(x) || length(x) != 1) {\n    stop(\"Must use single string to index into reactivevalues\")\n  }\n}\n\n# Create a reactivevalues object\n#\n# @param values A ReactiveValues object\n# @param readonly Should this object be read-only?\n# @param ns A namespace function (either `identity` or `NS(namespace)`)\n.createReactiveValues <- function(values = NULL, readonly = FALSE,\n  ns = identity) {\n\n  structure(\n    list(\n      impl = values,\n      readonly = readonly,\n      ns = ns\n    ),\n    class='reactivevalues'\n  )\n}\n\n#' Checks whether an object is a reactivevalues object\n#'\n#' Checks whether its argument is a reactivevalues object.\n#'\n#' @param x The object to test.\n#' @seealso \\code{\\link{reactiveValues}}.\n#' @export\nis.reactivevalues <- function(x) inherits(x, 'reactivevalues')\n\n#' @export\n`$.reactivevalues` <- function(x, name) {\n  checkName(name)\n  .subset2(x, 'impl')$get(.subset2(x, 'ns')(name))\n}\n\n#' @export\n`[[.reactivevalues` <- `$.reactivevalues`\n\n#' @export\n`$<-.reactivevalues` <- function(x, name, value) {\n  if (.subset2(x, 'readonly')) {\n    stop(\"Attempted to assign value to a read-only reactivevalues object\")\n  }\n  checkName(name)\n  .subset2(x, 'impl')$set(.subset2(x, 'ns')(name), value)\n  x\n}\n\n#' @export\n`[[<-.reactivevalues` <- `$<-.reactivevalues`\n\n#' @export\n`[.reactivevalues` <- function(values, name) {\n  stop(\"Single-bracket indexing of reactivevalues object is not allowed.\")\n}\n\n#' @export\n`[<-.reactivevalues` <- function(values, name, value) {\n  stop(\"Single-bracket indexing of reactivevalues object is not allowed.\")\n}\n\n#' @export\nnames.reactivevalues <- function(x) {\n  prefix <- .subset2(x, 'ns')(\"\")\n  results <- .subset2(x, 'impl')$names()\n  if (nzchar(prefix)) {\n    results <- results[substring(results, 1, nchar(prefix)) == prefix]\n    results <- substring(results, nchar(prefix) + 1)\n  }\n  results\n}\n\n#' @export\n`names<-.reactivevalues` <- function(x, value) {\n  stop(\"Can't assign names to reactivevalues object\")\n}\n\n#' @export\nas.list.reactivevalues <- function(x, all.names=FALSE, ...) {\n  shinyDeprecated(\"reactiveValuesToList\",\n    msg = paste(\"'as.list.reactivevalues' is deprecated. \",\n      \"Use reactiveValuesToList instead.\",\n      \"\\nPlease see ?reactiveValuesToList for more information.\",\n      sep = \"\"))\n\n  reactiveValuesToList(x, all.names)\n}\n\n# For debug purposes\n.setLabel <- function(x, label) {\n  .subset2(x, 'impl')$.setLabel(label)\n}\n\n#' Convert a reactivevalues object to a list\n#'\n#' This function does something similar to what you might \\code{\\link{as.list}}\n#' to do. The difference is that the calling context will take dependencies on\n#' every object in the reactivevalues object. To avoid taking dependencies on\n#' all the objects, you can wrap the call with \\code{\\link{isolate}()}.\n#'\n#' @param x A reactivevalues object.\n#' @param all.names If \\code{TRUE}, include objects with a leading dot. If\n#'   \\code{FALSE} (the default) don't include those objects.\n#' @examples\n#' values <- reactiveValues(a = 1)\n#' \\dontrun{\n#' reactiveValuesToList(values)\n#' }\n#'\n#' # To get the objects without taking dependencies on them, use isolate().\n#' # isolate() can also be used when calling from outside a reactive context (e.g.\n#' # at the console)\n#' isolate(reactiveValuesToList(values))\n#'\n#' @export\nreactiveValuesToList <- function(x, all.names=FALSE) {\n  .subset2(x, 'impl')$toList(all.names)\n}\n\n# This function is needed because str() on a reactivevalues object will call\n# [[.reactivevalues(), which will give an error when it tries to access\n# x[['impl']].\n#' @export\nstr.reactivevalues <- function(object, indent.str = \" \", ...) {\n  utils::str(unclass(object), indent.str = indent.str, ...)\n  # Need to manually print out the class field,\n  cat(indent.str, '- attr(*, \"class\")=', sep = \"\")\n  utils::str(class(object))\n}\n\n# Observable ----------------------------------------------------------------\n\nObservable <- R6Class(\n  'Observable',\n  portable = FALSE,\n  public = list(\n    .func = 'function',\n    .label = character(0),\n    .domain = NULL,\n    .dependents = 'Dependents',\n    .invalidated = logical(0),\n    .running = logical(0),\n    .value = NULL,\n    .error = FALSE,\n    .visible = logical(0),\n    .execCount = integer(0),\n    .mostRecentCtxId = character(0),\n\n    initialize = function(func, label = deparse(substitute(func)),\n                          domain = getDefaultReactiveDomain(),\n                          ..stacktraceon = TRUE) {\n      if (length(formals(func)) > 0)\n        stop(\"Can't make a reactive expression from a function that takes one \",\n             \"or more parameters; only functions without parameters can be \",\n             \"reactive.\")\n\n      .func <<- wrapFunctionLabel(func, paste(\"reactive\", label),\n        ..stacktraceon = ..stacktraceon)\n      .label <<- label\n      .domain <<- domain\n      .dependents <<- Dependents$new()\n      .invalidated <<- TRUE\n      .running <<- FALSE\n      .execCount <<- 0L\n      .mostRecentCtxId <<- \"\"\n    },\n    getValue = function() {\n      .dependents$register()\n\n      if (.invalidated || .running) {\n        ..stacktraceoff..(\n          self$.updateValue()\n        )\n      }\n\n      .graphDependsOnId(getCurrentContext()$id, .mostRecentCtxId)\n\n      if (.error) {\n        stop(.value)\n      }\n\n      if (.visible)\n        .value\n      else\n        invisible(.value)\n    },\n    .updateValue = function() {\n      ctx <- Context$new(.domain, .label, type = 'observable',\n                         prevId = .mostRecentCtxId)\n      .mostRecentCtxId <<- ctx$id\n      ctx$onInvalidate(function() {\n        .invalidated <<- TRUE\n        .dependents$invalidate()\n      })\n      .execCount <<- .execCount + 1L\n\n      .invalidated <<- FALSE\n\n      wasRunning <- .running\n      .running <<- TRUE\n      on.exit(.running <<- wasRunning)\n\n      ctx$run(function() {\n        result <- withCallingHandlers(\n\n          {\n            .error <<- FALSE\n            withVisible(.func())\n          },\n\n          error = function(cond) {\n            # If an error occurs, we want to propagate the error, but we also\n            # want to save a copy of it, so future callers of this reactive will\n            # get the same error (i.e. the error is cached).\n\n            # We stripStackTrace in the next line, just in case someone\n            # downstream of us (i.e. deeper into the call stack) used\n            # captureStackTraces; otherwise the entire stack would always be the\n            # same (i.e. you'd always see the whole stack trace of the *first*\n            # time the code was run and the condition raised; there'd be no way\n            # to see the stack trace of the call site that caused the cached\n            # exception to be re-raised, and you need that information to figure\n            # out what's triggering the re-raise).\n            #\n            # We use try(stop()) as an easy way to generate a try-error object\n            # out of this condition.\n            .value <<- cond\n            .error <<- TRUE\n            .visible <<- FALSE\n          }\n        )\n        .value <<- result$value\n        .visible <<- result$visible\n      })\n    }\n  )\n)\n\n#' Create a reactive expression\n#'\n#' Wraps a normal expression to create a reactive expression. Conceptually, a\n#' reactive expression is a expression whose result will change over time.\n#'\n#' Reactive expressions are expressions that can read reactive values and call\n#' other reactive expressions. Whenever a reactive value changes, any reactive\n#' expressions that depended on it are marked as \"invalidated\" and will\n#' automatically re-execute if necessary. If a reactive expression is marked as\n#' invalidated, any other reactive expressions that recently called it are also\n#' marked as invalidated. In this way, invalidations ripple through the\n#' expressions that depend on each other.\n#'\n#' See the \\href{http://rstudio.github.com/shiny/tutorial/}{Shiny tutorial} for\n#' more information about reactive expressions.\n#'\n#' @param x For \\code{reactive}, an expression (quoted or unquoted). For\n#'   \\code{is.reactive}, an object to test.\n#' @param env The parent environment for the reactive expression. By default,\n#'   this is the calling environment, the same as when defining an ordinary\n#'   non-reactive expression.\n#' @param quoted Is the expression quoted? By default, this is \\code{FALSE}.\n#'   This is useful when you want to use an expression that is stored in a\n#'   variable; to do so, it must be quoted with \\code{quote()}.\n#' @param label A label for the reactive expression, useful for debugging.\n#' @param domain See \\link{domains}.\n#' @param ..stacktraceon Advanced use only. For stack manipulation purposes; see\n#'   \\code{\\link{stacktrace}}.\n#' @return a function, wrapped in a S3 class \"reactive\"\n#'\n#' @examples\n#' values <- reactiveValues(A=1)\n#'\n#' reactiveB <- reactive({\n#'   values$A + 1\n#' })\n#'\n#' # Can use quoted expressions\n#' reactiveC <- reactive(quote({ values$A + 2 }), quoted = TRUE)\n#'\n#' # To store expressions for later conversion to reactive, use quote()\n#' expr_q <- quote({ values$A + 3 })\n#' reactiveD <- reactive(expr_q, quoted = TRUE)\n#'\n#' # View the values from the R console with isolate()\n#' isolate(reactiveB())\n#' isolate(reactiveC())\n#' isolate(reactiveD())\n#'\n#' @export\nreactive <- function(x, env = parent.frame(), quoted = FALSE, label = NULL,\n                     domain = getDefaultReactiveDomain(),\n                     ..stacktraceon = TRUE) {\n  fun <- exprToFunction(x, env, quoted)\n  # Attach a label and a reference to the original user source for debugging\n  srcref <- attr(substitute(x), \"srcref\", exact = TRUE)\n  if (is.null(label)) {\n    label <- srcrefToLabel(srcref[[1]],\n      sprintf('reactive(%s)', paste(deparse(body(fun)), collapse='\\n')))\n  }\n  if (length(srcref) >= 2) attr(label, \"srcref\") <- srcref[[2]]\n  attr(label, \"srcfile\") <- srcFileOfRef(srcref[[1]])\n  o <- Observable$new(fun, label, domain, ..stacktraceon = ..stacktraceon)\n  structure(o$getValue, observable = o, class = \"reactive\")\n}\n\n# Given the srcref to a reactive expression, attempts to figure out what the\n# name of the reactive expression is. This isn't foolproof, as it literally\n# scans the line of code that started the reactive block and looks for something\n# that looks like assignment. If we fail, fall back to a default value (likely\n# the block of code in the body of the reactive).\nsrcrefToLabel <- function(srcref, defaultLabel) {\n  if (is.null(srcref))\n    return(defaultLabel)\n\n  srcfile <- attr(srcref, \"srcfile\", exact = TRUE)\n  if (is.null(srcfile))\n    return(defaultLabel)\n\n  if (is.null(srcfile$lines))\n    return(defaultLabel)\n\n  lines <- srcfile$lines\n  # When pasting at the Console, srcfile$lines is not split\n  if (length(lines) == 1) {\n    lines <- strsplit(lines, \"\\n\")[[1]]\n  }\n\n  if (length(lines) < srcref[1]) {\n    return(defaultLabel)\n  }\n\n  firstLine <- substring(lines[srcref[1]], 1, srcref[2] - 1)\n\n  m <- regexec(\"(.*)(<-|=)\\\\s*reactive\\\\s*\\\\($\", firstLine)\n  if (m[[1]][1] == -1) {\n    return(defaultLabel)\n  }\n  sym <- regmatches(firstLine, m)[[1]][2]\n  res <- try(parse(text = sym), silent = TRUE)\n  if (inherits(res, \"try-error\"))\n    return(defaultLabel)\n\n  if (length(res) != 1)\n    return(defaultLabel)\n\n  return(as.character(res))\n}\n\n#' @export\nprint.reactive <- function(x, ...) {\n  label <- attr(x, \"observable\")$.label\n  cat(label, \"\\n\")\n}\n\n#' @export\n#' @rdname reactive\nis.reactive <- function(x) inherits(x, \"reactive\")\n\n# Return the number of times that a reactive expression or observer has been run\nexecCount <- function(x) {\n  if (is.reactive(x))\n    return(attr(x, \"observable\")$.execCount)\n  else if (inherits(x, 'Observer'))\n    return(x$.execCount)\n  else\n    stop('Unexpected argument to execCount')\n}\n\n# Observer ------------------------------------------------------------------\n\nObserver <- R6Class(\n  'Observer',\n  portable = FALSE,\n  public = list(\n    .func = 'function',\n    .label = character(0),\n    .domain = 'ANY',\n    .priority = numeric(0),\n    .autoDestroy = logical(0),\n    .invalidateCallbacks = list(),\n    .execCount = integer(0),\n    .onResume = 'function',\n    .suspended = logical(0),\n    .destroyed = logical(0),\n    .prevId = character(0),\n\n    initialize = function(observerFunc, label, suspended = FALSE, priority = 0,\n                          domain = getDefaultReactiveDomain(),\n                          autoDestroy = TRUE, ..stacktraceon = TRUE) {\n      if (length(formals(observerFunc)) > 0)\n        stop(\"Can't make an observer from a function that takes parameters; \",\n             \"only functions without parameters can be reactive.\")\nregisterDebugHook(\"observerFunc\", environment(), label)\n      .func <<- function() {\n        tryCatch(\n          if (..stacktraceon)\n            ..stacktraceon..(observerFunc())\n          else\n            observerFunc(),\n          validation = function(e) {\n            # It's OK for a validation error to cause an observer to stop\n            # running\n          }\n        )\n      }\n      .label <<- label\n      .domain <<- domain\n      .autoDestroy <<- autoDestroy\n      .priority <<- normalizePriority(priority)\n      .execCount <<- 0L\n      .suspended <<- suspended\n      .onResume <<- function() NULL\n      .destroyed <<- FALSE\n      .prevId <<- ''\n\n      onReactiveDomainEnded(.domain, self$.onDomainEnded)\n\n      # Defer the first running of this until flushReact is called\n      .createContext()$invalidate()\n    },\n    .createContext = function() {\n      ctx <- Context$new(.domain, .label, type='observer', prevId=.prevId)\n      .prevId <<- ctx$id\n\n      ctx$onInvalidate(function() {\n        lapply(.invalidateCallbacks, function(invalidateCallback) {\n          invalidateCallback()\n          NULL\n        })\n\n        continue <- function() {\n          ctx$addPendingFlush(.priority)\n        }\n\n        if (.suspended == FALSE)\n          continue()\n        else\n          .onResume <<- continue\n      })\n\n      ctx$onFlush(function() {\n        tryCatch({\n          if (!.destroyed)\n            shinyCallingHandlers(run())\n\n        }, error = function(e) {\n          printError(e)\n          if (!is.null(.domain)) {\n            .domain$unhandledError(e)\n          }\n        })\n      })\n\n      return(ctx)\n    },\n    run = function() {\n      ctx <- .createContext()\n      .execCount <<- .execCount + 1L\n      ctx$run(.func)\n    },\n    onInvalidate = function(callback) {\n      \"Register a callback function to run when this observer is invalidated.\n      No arguments will be provided to the callback function when it is\n      invoked.\"\n      .invalidateCallbacks <<- c(.invalidateCallbacks, callback)\n    },\n    setPriority = function(priority = 0) {\n      \"Change this observer's priority. Note that if the observer is currently\n      invalidated, then the change in priority will not take effect until the\n      next invalidation--unless the observer is also currently suspended, in\n      which case the priority change will be effective upon resume.\"\n      .priority <<- normalizePriority(priority)\n    },\n    setAutoDestroy = function(autoDestroy) {\n      \"Sets whether this observer should be automatically destroyed when its\n      domain (if any) ends. If autoDestroy is TRUE and the domain already\n      ended, then destroy() is called immediately.\"\n      oldValue <- .autoDestroy\n      .autoDestroy <<- autoDestroy\n      if (!is.null(.domain) && .domain$isEnded()) {\n        destroy()\n      }\n      invisible(oldValue)\n    },\n    suspend = function() {\n      \"Causes this observer to stop scheduling flushes (re-executions) in\n      response to invalidations. If the observer was invalidated prior to this\n      call but it has not re-executed yet (because it waits until onFlush is\n      called) then that re-execution will still occur, because the flush is\n      already scheduled.\"\n      .suspended <<- TRUE\n    },\n    resume = function() {\n      \"Causes this observer to start re-executing in response to invalidations.\n      If the observer was invalidated while suspended, then it will schedule\n      itself for re-execution (pending flush).\"\n      if (.suspended) {\n        .suspended <<- FALSE\n        .onResume()\n        .onResume <<- function() NULL\n      }\n      invisible()\n    },\n    destroy = function() {\n      \"Prevents this observer from ever executing again (even if a flush has\n      already been scheduled).\"\n\n      suspend()\n      .destroyed <<- TRUE\n    },\n    .onDomainEnded = function() {\n      if (isTRUE(.autoDestroy)) {\n        destroy()\n      }\n    }\n  )\n)\n\n#' Create a reactive observer\n#'\n#' Creates an observer from the given expression.\n#'\n#' An observer is like a reactive expression in that it can read reactive values\n#' and call reactive expressions, and will automatically re-execute when those\n#' dependencies change. But unlike reactive expressions, it doesn't yield a\n#' result and can't be used as an input to other reactive expressions. Thus,\n#' observers are only useful for their side effects (for example, performing\n#' I/O).\n#'\n#' Another contrast between reactive expressions and observers is their\n#' execution strategy. Reactive expressions use lazy evaluation; that is, when\n#' their dependencies change, they don't re-execute right away but rather wait\n#' until they are called by someone else. Indeed, if they are not called then\n#' they will never re-execute. In contrast, observers use eager evaluation; as\n#' soon as their dependencies change, they schedule themselves to re-execute.\n#'\n#' Starting with Shiny 0.10.0, observers are automatically destroyed by default\n#' when the \\link[=domains]{domain} that owns them ends (e.g. when a Shiny session\n#' ends).\n#'\n#' @param x An expression (quoted or unquoted). Any return value will be\n#'   ignored.\n#' @param env The parent environment for the reactive expression. By default,\n#'   this is the calling environment, the same as when defining an ordinary\n#'   non-reactive expression.\n#' @param quoted Is the expression quoted? By default, this is \\code{FALSE}.\n#'   This is useful when you want to use an expression that is stored in a\n#'   variable; to do so, it must be quoted with \\code{quote()}.\n#' @param label A label for the observer, useful for debugging.\n#' @param suspended If \\code{TRUE}, start the observer in a suspended state.\n#'   If \\code{FALSE} (the default), start in a non-suspended state.\n#' @param priority An integer or numeric that controls the priority with which\n#'   this observer should be executed. An observer with a given priority level\n#'   will always execute sooner than all observers with a lower priority level.\n#'   Positive, negative, and zero values are allowed.\n#' @param domain See \\link{domains}.\n#' @param autoDestroy If \\code{TRUE} (the default), the observer will be\n#'   automatically destroyed when its domain (if any) ends.\n#' @param ..stacktraceon Advanced use only. For stack manipulation purposes; see\n#'   \\code{\\link{stacktrace}}.\n#' @return An observer reference class object. This object has the following\n#'   methods:\n#'   \\describe{\n#'     \\item{\\code{suspend()}}{\n#'       Causes this observer to stop scheduling flushes (re-executions) in\n#'       response to invalidations. If the observer was invalidated prior to\n#'       this call but it has not re-executed yet then that re-execution will\n#'       still occur, because the flush is already scheduled.\n#'     }\n#'     \\item{\\code{resume()}}{\n#'       Causes this observer to start re-executing in response to\n#'       invalidations. If the observer was invalidated while suspended, then it\n#'       will schedule itself for re-execution.\n#'     }\n#'     \\item{\\code{destroy()}}{\n#'       Stops the observer from executing ever again, even if it is currently\n#'       scheduled for re-execution.\n#'     }\n#'     \\item{\\code{setPriority(priority = 0)}}{\n#'       Change this observer's priority. Note that if the observer is currently\n#'       invalidated, then the change in priority will not take effect until the\n#'       next invalidation--unless the observer is also currently suspended, in\n#'       which case the priority change will be effective upon resume.\n#'     }\n#'     \\item{\\code{setAutoDestroy(autoDestroy)}}{\n#'       Sets whether this observer should be automatically destroyed when its\n#'       domain (if any) ends. If autoDestroy is TRUE and the domain already\n#'       ended, then destroy() is called immediately.\"\n#'     }\n#'     \\item{\\code{onInvalidate(callback)}}{\n#'       Register a callback function to run when this observer is invalidated.\n#'       No arguments will be provided to the callback function when it is\n#'       invoked.\n#'     }\n#'   }\n#'\n#' @examples\n#' values <- reactiveValues(A=1)\n#'\n#' obsB <- observe({\n#'   print(values$A + 1)\n#' })\n#'\n#' # Can use quoted expressions\n#' obsC <- observe(quote({ print(values$A + 2) }), quoted = TRUE)\n#'\n#' # To store expressions for later conversion to observe, use quote()\n#' expr_q <- quote({ print(values$A + 3) })\n#' obsD <- observe(expr_q, quoted = TRUE)\n#'\n#' # In a normal Shiny app, the web client will trigger flush events. If you\n#' # are at the console, you can force a flush with flushReact()\n#' shiny:::flushReact()\n#'\n#' @export\nobserve <- function(x, env=parent.frame(), quoted=FALSE, label=NULL,\n                    suspended=FALSE, priority=0,\n                    domain=getDefaultReactiveDomain(), autoDestroy = TRUE,\n                    ..stacktraceon = TRUE) {\n\n  fun <- exprToFunction(x, env, quoted)\n  if (is.null(label))\n    label <- sprintf('observe(%s)', paste(deparse(body(fun)), collapse='\\n'))\n\n  o <- Observer$new(fun, label=label, suspended=suspended, priority=priority,\n                    domain=domain, autoDestroy=autoDestroy,\n                    ..stacktraceon=..stacktraceon)\n  invisible(o)\n}\n\n#' Make a reactive variable\n#'\n#' Turns a normal variable into a reactive variable, that is, one that has\n#' reactive semantics when assigned or read in the usual ways. The variable may\n#' already exist; if so, its value will be used as the initial value of the\n#' reactive variable (or \\code{NULL} if the variable did not exist).\n#'\n#' @param symbol A character string indicating the name of the variable that\n#'   should be made reactive\n#' @param env The environment that will contain the reactive variable\n#'\n#' @return None.\n#'\n#' @examples\n#' \\dontrun{\n#' a <- 10\n#' makeReactiveBinding(\"a\")\n#' b <- reactive(a * -1)\n#' observe(print(b()))\n#' a <- 20\n#' }\n#' @export\nmakeReactiveBinding <- function(symbol, env = parent.frame()) {\n  if (exists(symbol, where = env, inherits = FALSE)) {\n    initialValue <- get(symbol, pos = env, inherits = FALSE)\n    rm(list = symbol, pos = env, inherits = FALSE)\n  }\n  else\n    initialValue <- NULL\n  values <- reactiveValues(value = initialValue)\n  makeActiveBinding(symbol, env=env, fun=function(v) {\n    if (missing(v))\n      values$value\n    else\n      values$value <- v\n  })\n\n  invisible()\n}\n\n# `%<-reactive%` <- function(name, value) {\n#   sym <- deparse(substitute(name))\n#   assign(sym, value, pos = parent.frame())\n#   makeReactiveBinding(sym, env=parent.frame())\n#   invisible(NULL)\n# }\n\n# Causes flushReact to be called every time an expression is\n# entered into the top-level prompt\nsetAutoflush <- local({\n  callbackId <- NULL\n\n  function(enable) {\n    if (xor(is.null(callbackId), isTRUE(enable))) {\n      return(invisible())\n    }\n\n    if (isTRUE(enable)) {\n      callbackId <<- addTaskCallback(function(expr, value, ok, visible) {\n        timerCallbacks$executeElapsed()\n        flushReact()\n        return(TRUE)\n      })\n    } else {\n      removeTaskCallback(callbackId)\n      callbackId <<- NULL\n    }\n    invisible()\n  }\n})\n\n# ---------------------------------------------------------------------------\n\n#' Timer\n#'\n#' Creates a reactive timer with the given interval. A reactive timer is like a\n#' reactive value, except reactive values are triggered when they are set, while\n#' reactive timers are triggered simply by the passage of time.\n#'\n#' \\link[=reactive]{Reactive expressions} and observers that want to be\n#' invalidated by the timer need to call the timer function that\n#' \\code{reactiveTimer} returns, even if the current time value is not actually\n#' needed.\n#'\n#' See \\code{\\link{invalidateLater}} as a safer and simpler alternative.\n#'\n#' @param intervalMs How often to fire, in milliseconds\n#' @param session A session object. This is needed to cancel any scheduled\n#'   invalidations after a user has ended the session. If \\code{NULL}, then\n#'   this invalidation will not be tied to any session, and so it will still\n#'   occur.\n#' @return A no-parameter function that can be called from a reactive context,\n#'   in order to cause that context to be invalidated the next time the timer\n#'   interval elapses. Calling the returned function also happens to yield the\n#'   current time (as in \\code{\\link{Sys.time}}).\n#' @seealso \\code{\\link{invalidateLater}}\n#'\n#' @examples\n#' \\dontrun{\n#' shinyServer(function(input, output, session) {\n#'\n#'   # Anything that calls autoInvalidate will automatically invalidate\n#'   # every 2 seconds.\n#'   autoInvalidate <- reactiveTimer(2000)\n#'\n#'   observe({\n#'     # Invalidate and re-execute this reactive expression every time the\n#'     # timer fires.\n#'     autoInvalidate()\n#'\n#'     # Do something each time this is invalidated.\n#'     # The isolate() makes this observer _not_ get invalidated and re-executed\n#'     # when input$n changes.\n#'     print(paste(\"The value of input$n is\", isolate(input$n)))\n#'   })\n#'\n#'   # Generate a new histogram each time the timer fires, but not when\n#'   # input$n changes.\n#'   output$plot <- renderPlot({\n#'     autoInvalidate()\n#'     hist(isolate(input$n))\n#'   })\n#' })\n#' }\n#'\n#' @export\nreactiveTimer <- function(intervalMs=1000, session = getDefaultReactiveDomain()) {\n  dependents <- Map$new()\n  timerCallbacks$schedule(intervalMs, function() {\n    # Quit if the session is closed\n    if (!is.null(session) && session$isClosed()) {\n      return(invisible())\n    }\n\n    timerCallbacks$schedule(intervalMs, sys.function())\n    lapply(\n      dependents$values(),\n      function(dep.ctx) {\n        dep.ctx$invalidate()\n        NULL\n      })\n  })\n  return(function() {\n    ctx <- .getReactiveEnvironment()$currentContext()\n    if (!dependents$containsKey(ctx$id)) {\n      dependents$set(ctx$id, ctx)\n      ctx$onInvalidate(function() {\n        dependents$remove(ctx$id)\n      })\n    }\n    return(Sys.time())\n  })\n}\n\n#' Scheduled Invalidation\n#'\n#' Schedules the current reactive context to be invalidated in the given number\n#' of milliseconds.\n#'\n#' If this is placed within an observer or reactive expression, that object will\n#' be invalidated (and re-execute) after the interval has passed. The\n#' re-execution will reset the invalidation flag, so in a typical use case, the\n#' object will keep re-executing and waiting for the specified interval. It's\n#' possible to stop this cycle by adding conditional logic that prevents the\n#' \\code{invalidateLater} from being run.\n#'\n#' @param millis Approximate milliseconds to wait before invalidating the\n#'   current reactive context.\n#' @param session A session object. This is needed to cancel any scheduled\n#'   invalidations after a user has ended the session. If \\code{NULL}, then\n#'   this invalidation will not be tied to any session, and so it will still\n#'   occur.\n#'\n#' @seealso \\code{\\link{reactiveTimer}} is a slightly less safe alternative.\n#'\n#' @examples\n#' \\dontrun{\n#' shinyServer(function(input, output, session) {\n#'\n#'   observe({\n#'     # Re-execute this reactive expression after 1000 milliseconds\n#'     invalidateLater(1000, session)\n#'\n#'     # Do something each time this is invalidated.\n#'     # The isolate() makes this observer _not_ get invalidated and re-executed\n#'     # when input$n changes.\n#'     print(paste(\"The value of input$n is\", isolate(input$n)))\n#'   })\n#'\n#'   # Generate a new histogram at timed intervals, but not when\n#'   # input$n changes.\n#'   output$plot <- renderPlot({\n#'     # Re-execute this reactive expression after 2000 milliseconds\n#'     invalidateLater(2000)\n#'     hist(isolate(input$n))\n#'   })\n#' })\n#' }\n#'\n#' @export\ninvalidateLater <- function(millis, session = getDefaultReactiveDomain()) {\n  ctx <- .getReactiveEnvironment()$currentContext()\n  timerCallbacks$schedule(millis, function() {\n    # Quit if the session is closed\n    if (!is.null(session) && session$isClosed()) {\n      return(invisible())\n    }\n    ctx$invalidate()\n  })\n  invisible()\n}\n\ncoerceToFunc <- function(x) {\n  force(x);\n  if (is.function(x))\n    return(x)\n  else\n    return(function() x)\n}\n\n#' Reactive polling\n#'\n#' Used to create a reactive data source, which works by periodically polling a\n#' non-reactive data source.\n#'\n#' \\code{reactivePoll} works by pairing a relatively cheap \"check\" function with\n#' a more expensive value retrieval function. The check function will be\n#' executed periodically and should always return a consistent value until the\n#' data changes. When the check function returns a different value, then the\n#' value retrieval function will be used to re-populate the data.\n#'\n#' Note that the check function doesn't return \\code{TRUE} or \\code{FALSE} to\n#' indicate whether the underlying data has changed. Rather, the check function\n#' indicates change by returning a different value from the previous time it was\n#' called.\n#'\n#' For example, \\code{reactivePoll} is used to implement\n#' \\code{reactiveFileReader} by pairing a check function that simply returns the\n#' last modified timestamp of a file, and a value retrieval function that\n#' actually reads the contents of the file.\n#'\n#' As another example, one might read a relational database table reactively by\n#' using a check function that does \\code{SELECT MAX(timestamp) FROM table} and\n#' a value retrieval function that does \\code{SELECT * FROM table}.\n#'\n#' The \\code{intervalMillis}, \\code{checkFunc}, and \\code{valueFunc} functions\n#' will be executed in a reactive context; therefore, they may read reactive\n#' values and reactive expressions.\n#'\n#' @param intervalMillis Approximate number of milliseconds to wait between\n#'   calls to \\code{checkFunc}. This can be either a numeric value, or a\n#'   function that returns a numeric value.\n#' @param session The user session to associate this file reader with, or\n#'   \\code{NULL} if none. If non-null, the reader will automatically stop when\n#'   the session ends.\n#' @param checkFunc A relatively cheap function whose values over time will be\n#'   tested for equality; inequality indicates that the underlying value has\n#'   changed and needs to be invalidated and re-read using \\code{valueFunc}. See\n#'   Details.\n#' @param valueFunc A function that calculates the underlying value. See\n#'   Details.\n#'\n#' @return A reactive expression that returns the result of \\code{valueFunc},\n#'   and invalidates when \\code{checkFunc} changes.\n#'\n#' @seealso \\code{\\link{reactiveFileReader}}\n#'\n#' @examples\n#' \\dontrun{\n#' # Assume the existence of readTimestamp and readValue functions\n#' shinyServer(function(input, output, session) {\n#'   data <- reactivePoll(1000, session, readTimestamp, readValue)\n#'   output$dataTable <- renderTable({\n#'     data()\n#'   })\n#' })\n#' }\n#'\n#' @export\nreactivePoll <- function(intervalMillis, session, checkFunc, valueFunc) {\n  intervalMillis <- coerceToFunc(intervalMillis)\n\n  rv <- reactiveValues(cookie = isolate(checkFunc()))\n\n  observe({\n    rv$cookie <- checkFunc()\n    invalidateLater(intervalMillis(), session)\n  })\n\n  # TODO: what to use for a label?\n  re <- reactive({\n    rv$cookie\n\n    valueFunc()\n\n  }, label = NULL)\n\n  return(re)\n}\n\n#' Reactive file reader\n#'\n#' Given a file path and read function, returns a reactive data source for the\n#' contents of the file.\n#'\n#' \\code{reactiveFileReader} works by periodically checking the file's last\n#' modified time; if it has changed, then the file is re-read and any reactive\n#' dependents are invalidated.\n#'\n#' The \\code{intervalMillis}, \\code{filePath}, and \\code{readFunc} functions\n#' will each be executed in a reactive context; therefore, they may read\n#' reactive values and reactive expressions.\n#'\n#' @param intervalMillis Approximate number of milliseconds to wait between\n#'   checks of the file's last modified time. This can be a numeric value, or a\n#'   function that returns a numeric value.\n#' @param session The user session to associate this file reader with, or\n#'   \\code{NULL} if none. If non-null, the reader will automatically stop when\n#'   the session ends.\n#' @param filePath The file path to poll against and to pass to \\code{readFunc}.\n#'   This can either be a single-element character vector, or a function that\n#'   returns one.\n#' @param readFunc The function to use to read the file; must expect the first\n#'   argument to be the file path to read. The return value of this function is\n#'   used as the value of the reactive file reader.\n#' @param ... Any additional arguments to pass to \\code{readFunc} whenever it is\n#'   invoked.\n#'\n#' @return A reactive expression that returns the contents of the file, and\n#'   automatically invalidates when the file changes on disk (as determined by\n#'   last modified time).\n#'\n#' @seealso \\code{\\link{reactivePoll}}\n#'\n#' @examples\n#' \\dontrun{\n#' # Per-session reactive file reader\n#' shinyServer(function(input, output, session)) {\n#'   fileData <- reactiveFileReader(1000, session, 'data.csv', read.csv)\n#'\n#'   output$data <- renderTable({\n#'     fileData()\n#'   })\n#' }\n#'\n#' # Cross-session reactive file reader. In this example, all sessions share\n#' # the same reader, so read.csv only gets executed once no matter how many\n#' # user sessions are connected.\n#' fileData <- reactiveFileReader(1000, session, 'data.csv', read.csv)\n#' shinyServer(function(input, output, session)) {\n#'   output$data <- renderTable({\n#'     fileData()\n#'   })\n#' }\n#' }\n#'\n#' @export\nreactiveFileReader <- function(intervalMillis, session, filePath, readFunc, ...) {\n  filePath <- coerceToFunc(filePath)\n  extraArgs <- list(...)\n\n  reactivePoll(\n    intervalMillis, session,\n    function() {\n      path <- filePath()\n      info <- file.info(path)\n      return(paste(path, info$mtime, info$size))\n    },\n    function() {\n      do.call(readFunc, c(filePath(), extraArgs))\n    }\n  )\n}\n\n#' Create a non-reactive scope for an expression\n#'\n#' Executes the given expression in a scope where reactive values or expression\n#' can be read, but they cannot cause the reactive scope of the caller to be\n#' re-evaluated when they change.\n#'\n#' Ordinarily, the simple act of reading a reactive value causes a relationship\n#' to be established between the caller and the reactive value, where a change\n#' to the reactive value will cause the caller to re-execute. (The same applies\n#' for the act of getting a reactive expression's value.) The \\code{isolate}\n#' function lets you read a reactive value or expression without establishing this\n#' relationship.\n#'\n#' The expression given to \\code{isolate()} is evaluated in the calling\n#' environment. This means that if you assign a variable inside the\n#' \\code{isolate()}, its value will be visible outside of the \\code{isolate()}.\n#' If you want to avoid this, you can use \\code{\\link{local}()} inside the\n#' \\code{isolate()}.\n#'\n#' This function can also be useful for calling reactive expression at the\n#' console, which can be useful for debugging. To do so, simply wrap the\n#' calls to the reactive expression with \\code{isolate()}.\n#'\n#' @param expr An expression that can access reactive values or expressions.\n#'\n#' @examples\n#' \\dontrun{\n#' observe({\n#'   input$saveButton  # Do take a dependency on input$saveButton\n#'\n#'   # isolate a simple expression\n#'   data <- get(isolate(input$dataset))  # No dependency on input$dataset\n#'   writeToDatabase(data)\n#' })\n#'\n#' observe({\n#'   input$saveButton  # Do take a dependency on input$saveButton\n#'\n#'   # isolate a whole block\n#'   data <- isolate({\n#'     a <- input$valueA   # No dependency on input$valueA or input$valueB\n#'     b <- input$valueB\n#'     c(a=a, b=b)\n#'   })\n#'   writeToDatabase(data)\n#' })\n#'\n#' observe({\n#'   x <- 1\n#'   # x outside of isolate() is affected\n#'   isolate(x <- 2)\n#'   print(x) # 2\n#'\n#'   y <- 1\n#'   # Use local() to avoid affecting calling environment\n#'   isolate(local(y <- 2))\n#'   print(y) # 1\n#' })\n#'\n#' }\n#'\n#' # Can also use isolate to call reactive expressions from the R console\n#' values <- reactiveValues(A=1)\n#' fun <- reactive({ as.character(values$A) })\n#' isolate(fun())\n#' # \"1\"\n#'\n#' # isolate also works if the reactive expression accesses values from the\n#' # input object, like input$x\n#'\n#' @export\nisolate <- function(expr) {\n  ctx <- Context$new(getDefaultReactiveDomain(), '[isolate]', type='isolate')\n  on.exit(ctx$invalidate())\n  # Matching ..stacktraceon../..stacktraceoff.. pair\n  ..stacktraceoff..(ctx$run(function() {\n    ..stacktraceon..(expr)\n  }))\n}\n\n#' Evaluate an expression without a reactive context\n#'\n#' Temporarily blocks the current reactive context and evaluates the given\n#' expression. Any attempt to directly access reactive values or expressions in\n#' \\code{expr} will give the same results as doing it at the top-level (by\n#' default, an error).\n#'\n#' @param expr An expression to evaluate.\n#' @return The value of \\code{expr}.\n#'\n#' @seealso \\code{\\link{isolate}}\n#'\n#' @export\nmaskReactiveContext <- function(expr) {\n  .getReactiveEnvironment()$runWith(NULL, function() {\n    expr\n  })\n}\n\n#' Event handler\n#'\n#' Respond to \"event-like\" reactive inputs, values, and expressions.\n#'\n#' Shiny's reactive programming framework is primarily designed for calculated\n#' values (reactive expressions) and side-effect-causing actions (observers)\n#' that respond to \\emph{any} of their inputs changing. That's often what is\n#' desired in Shiny apps, but not always: sometimes you want to wait for a\n#' specific action to be taken from the user, like clicking an\n#' \\code{\\link{actionButton}}, before calculating an expression or taking an\n#' action. A reactive value or expression that is used to trigger other\n#' calculations in this way is called an \\emph{event}.\n#'\n#' These situations demand a more imperative, \"event handling\" style of\n#' programming that is possible--but not particularly intuitive--using the\n#' reactive programming primitives \\code{\\link{observe}} and\n#' \\code{\\link{isolate}}. \\code{observeEvent} and \\code{eventReactive} provide\n#' straightforward APIs for event handling that wrap \\code{observe} and\n#' \\code{isolate}.\n#'\n#' Use \\code{observeEvent} whenever you want to \\emph{perform an action} in\n#' response to an event. (Note that \"recalculate a value\" does not generally\n#' count as performing an action--see \\code{eventReactive} for that.) The first\n#' argument is the event you want to respond to, and the second argument is a\n#' function that should be called whenever the event occurs.\n#'\n#' Use \\code{eventReactive} to create a \\emph{calculated value} that only\n#' updates in response to an event. This is just like a normal\n#' \\link[=reactive]{reactive expression} except it ignores all the usual\n#' invalidations that come from its reactive dependencies; it only invalidates\n#' in response to the given event.\n#'\n#' Both \\code{observeEvent} and \\code{eventReactive} take an \\code{ignoreNULL}\n#' parameter that affects behavior when the \\code{eventExpr} evaluates to\n#' \\code{NULL} (or in the special case of an \\code{\\link{actionButton}},\n#' \\code{0}). In these cases, if \\code{ignoreNULL} is \\code{TRUE}, then an\n#' \\code{observeEvent} will not execute and an \\code{eventReactive} will raise a\n#' silent \\link[=validate]{validation} error. This is useful behavior if you\n#' don't want to do the action or calculation when your app first starts, but\n#' wait for the user to initiate the action first (like a \"Submit\" button);\n#' whereas \\code{ignoreNULL=FALSE} is desirable if you want to initially perform\n#' the action/calculation and just let the user re-initiate it (like a\n#' \"Recalculate\" button).\n#'\n#' @param eventExpr A (quoted or unquoted) expression that represents the event;\n#'   this can be a simple reactive value like \\code{input$click}, a call to a\n#'   reactive expression like \\code{dataset()}, or even a complex expression\n#'   inside curly braces\n#' @param handlerExpr The expression to call whenever \\code{eventExpr} is\n#'   invalidated. This should be a side-effect-producing action (the return\n#'   value will be ignored). It will be executed within an \\code{\\link{isolate}}\n#'   scope.\n#' @param valueExpr The expression that produces the return value of the\n#'   \\code{eventReactive}. It will be executed within an \\code{\\link{isolate}}\n#'   scope.\n#' @param event.env The parent environment for \\code{eventExpr}. By default,\n#'   this is the calling environment.\n#' @param event.quoted Is the \\code{eventExpr} expression quoted? By default,\n#'   this is \\code{FALSE}. This is useful when you want to use an expression\n#'   that is stored in a variable; to do so, it must be quoted with\n#'   \\code{quote()}.\n#' @param handler.env The parent environment for \\code{handlerExpr}. By default,\n#'   this is the calling environment.\n#' @param handler.quoted Is the \\code{handlerExpr} expression quoted? By\n#'   default, this is \\code{FALSE}. This is useful when you want to use an\n#'   expression that is stored in a variable; to do so, it must be quoted with\n#'   \\code{quote()}.\n#' @param value.env The parent environment for \\code{valueExpr}. By default,\n#'   this is the calling environment.\n#' @param value.quoted Is the \\code{valueExpr} expression quoted? By default,\n#'   this is \\code{FALSE}. This is useful when you want to use an expression\n#'   that is stored in a variable; to do so, it must be quoted with \\code{quote()}.\n#' @param label A label for the observer or reactive, useful for debugging.\n#' @param suspended If \\code{TRUE}, start the observer in a suspended state. If\n#'   \\code{FALSE} (the default), start in a non-suspended state.\n#' @param priority An integer or numeric that controls the priority with which\n#'   this observer should be executed. An observer with a given priority level\n#'   will always execute sooner than all observers with a lower priority level.\n#'   Positive, negative, and zero values are allowed.\n#' @param domain See \\link{domains}.\n#' @param autoDestroy If \\code{TRUE} (the default), the observer will be\n#'   automatically destroyed when its domain (if any) ends.\n#' @param ignoreNULL Whether the action should be triggered (or value\n#'   calculated, in the case of \\code{eventReactive}) when the input is\n#'   \\code{NULL}. See Details.\n#' @return \\code{observeEvent} returns an observer reference class object (see\n#'   \\code{\\link{observe}}). \\code{eventReactive} returns a reactive expression\n#'   object (see \\code{\\link{reactive}}).\n#'\n#' @seealso \\code{\\link{actionButton}}\n#'\n#' @examples\n#' ## Only run this example in interactive R sessions\n#' if (interactive()) {\n#'   ui <- fluidPage(\n#'     column(4,\n#'       numericInput(\"x\", \"Value\", 5),\n#'       br(),\n#'       actionButton(\"button\", \"Show\")\n#'     ),\n#'     column(8, tableOutput(\"table\"))\n#'   )\n#'   server <- function(input, output) {\n#'     # Take an action every time button is pressed;\n#'     # here, we just print a message to the console\n#'     observeEvent(input$button, {\n#'       cat(\"Showing\", input$x, \"rows\\n\")\n#'     })\n#'     # Take a reactive dependency on input$button, but\n#'     # not on any of the stuff inside the function\n#'     df <- eventReactive(input$button, {\n#'       head(cars, input$x)\n#'     })\n#'     output$table <- renderTable({\n#'       df()\n#'     })\n#'   }\n#'   shinyApp(ui=ui, server=server)\n#' }\n#'\n#' @export\nobserveEvent <- function(eventExpr, handlerExpr,\n  event.env = parent.frame(), event.quoted = FALSE,\n  handler.env = parent.frame(), handler.quoted = FALSE,\n  label=NULL, suspended=FALSE, priority=0, domain=getDefaultReactiveDomain(),\n  autoDestroy = TRUE, ignoreNULL = TRUE) {\n\n  eventFunc <- exprToFunction(eventExpr, event.env, event.quoted)\n  if (is.null(label))\n    label <- sprintf('observeEvent(%s)', paste(deparse(body(eventFunc)), collapse='\\n'))\n  eventFunc <- wrapFunctionLabel(eventFunc, \"observeEventExpr\", ..stacktraceon = TRUE)\n\n  handlerFunc <- exprToFunction(handlerExpr, handler.env, handler.quoted)\n  handlerFunc <- wrapFunctionLabel(handlerFunc, \"observeEventHandler\", ..stacktraceon = TRUE)\n\n  invisible(observe({\n    e <- eventFunc()\n\n    if (ignoreNULL && isNullEvent(e)) {\n      return()\n    }\n\n    isolate(handlerFunc())\n  }, label = label, suspended = suspended, priority = priority, domain = domain,\n    autoDestroy = TRUE, ..stacktraceon = FALSE))\n}\n\n#' @rdname observeEvent\n#' @export\neventReactive <- function(eventExpr, valueExpr,\n  event.env = parent.frame(), event.quoted = FALSE,\n  value.env = parent.frame(), value.quoted = FALSE,\n  label=NULL, domain=getDefaultReactiveDomain(),\n  ignoreNULL = TRUE) {\n\n  eventFunc <- exprToFunction(eventExpr, event.env, event.quoted)\n  if (is.null(label))\n    label <- sprintf('eventReactive(%s)', paste(deparse(body(eventFunc)), collapse='\\n'))\n  eventFunc <- wrapFunctionLabel(eventFunc, \"eventReactiveExpr\", ..stacktraceon = TRUE)\n\n  handlerFunc <- exprToFunction(valueExpr, value.env, value.quoted)\n  handlerFunc <- wrapFunctionLabel(handlerFunc, \"eventReactiveHandler\", ..stacktraceon = TRUE)\n\n  invisible(reactive({\n    e <- eventFunc()\n\n    validate(need(\n      !ignoreNULL || !isNullEvent(e),\n      message = FALSE\n    ))\n\n    isolate(handlerFunc())\n  }, label = label, domain = domain, ..stacktraceon = FALSE))\n}\n\nisNullEvent <- function(value) {\n  is.null(value) || (inherits(value, 'shinyActionButtonValue') && value == 0)\n}\n"},{"filename":"/R/react.R","content":"Context <- R6Class(\n  'Context',\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    id = character(0),\n    .label = character(0),      # For debug purposes\n    .invalidated = FALSE,\n    .invalidateCallbacks = list(),\n    .flushCallbacks = list(),\n    .domain = NULL,\n\n    initialize = function(domain, label='', type='other', prevId='') {\n      id <<- .getReactiveEnvironment()$nextId()\n      .label <<- label\n      .domain <<- domain\n      .graphCreateContext(id, label, type, prevId, domain)\n    },\n    run = function(func) {\n      \"Run the provided function under this context.\"\n      withReactiveDomain(.domain, {\n        env <- .getReactiveEnvironment()\n        .graphEnterContext(id)\n        on.exit(.graphExitContext(id), add = TRUE)\n        env$runWith(self, func)\n      })\n    },\n    invalidate = function() {\n      \"Invalidate this context. It will immediately call the callbacks\n        that have been registered with onInvalidate().\"\n      if (.invalidated)\n        return()\n      .invalidated <<- TRUE\n\n      .graphInvalidate(id, .domain)\n      lapply(.invalidateCallbacks, function(func) {\n        func()\n      })\n      .invalidateCallbacks <<- list()\n      NULL\n    },\n    onInvalidate = function(func) {\n      \"Register a function to be called when this context is invalidated.\n        If this context is already invalidated, the function is called\n        immediately.\"\n      if (.invalidated)\n        func()\n      else\n        .invalidateCallbacks <<- c(.invalidateCallbacks, func)\n      NULL\n    },\n    addPendingFlush = function(priority) {\n      \"Tell the reactive environment that this context should be flushed the\n        next time flushReact() called.\"\n      if (!is.null(.domain)) {\n        .domain$incrementBusyCount()\n      }\n      .getReactiveEnvironment()$addPendingFlush(self, priority)\n    },\n    onFlush = function(func) {\n      \"Register a function to be called when this context is flushed.\"\n      .flushCallbacks <<- c(.flushCallbacks, func)\n    },\n    executeFlushCallbacks = function() {\n      \"For internal use only.\"\n\n      on.exit({\n        if (!is.null(.domain)) {\n          .domain$decrementBusyCount()\n        }\n      }, add = TRUE)\n\n      lapply(.flushCallbacks, function(flushCallback) {\n        flushCallback()\n      })\n    }\n  )\n)\n\nReactiveEnvironment <- R6Class(\n  'ReactiveEnvironment',\n  portable = FALSE,\n  class = FALSE,\n  public = list(\n    .currentContext = NULL,\n    .nextId = 0L,\n    .pendingFlush = 'PriorityQueue',\n    .inFlush = FALSE,\n\n    initialize = function() {\n      .pendingFlush <<- PriorityQueue$new()\n    },\n    nextId = function() {\n      .nextId <<- .nextId + 1L\n      return(as.character(.nextId))\n    },\n    currentContext = function() {\n      if (is.null(.currentContext)) {\n        if (isTRUE(getOption('shiny.suppressMissingContextError'))) {\n          return(getDummyContext())\n        } else {\n          stop('Operation not allowed without an active reactive context. ',\n               '(You tried to do something that can only be done from inside a ',\n               'reactive expression or observer.)')\n        }\n      }\n      return(.currentContext)\n    },\n    runWith = function(ctx, contextFunc) {\n      old.ctx <- .currentContext\n      .currentContext <<- ctx\n      on.exit(.currentContext <<- old.ctx)\n      contextFunc()\n    },\n    addPendingFlush = function(ctx, priority) {\n      .pendingFlush$enqueue(ctx, priority)\n    },\n    flush = function() {\n      # If already in a flush, don't start another one\n      if (.inFlush) return()\n      .inFlush <<- TRUE\n      on.exit(.inFlush <<- FALSE)\n\n      while (!.pendingFlush$isEmpty()) {\n        ctx <- .pendingFlush$dequeue()\n        ctx$executeFlushCallbacks()\n      }\n    }\n  )\n)\n\n.getReactiveEnvironment <- local({\n  reactiveEnvironment <- NULL\n  function() {\n    if (is.null(reactiveEnvironment))\n      reactiveEnvironment <<- ReactiveEnvironment$new()\n    return(reactiveEnvironment)\n  }\n})\n\n# Causes any pending invalidations to run.\nflushReact <- function() {\n  .getReactiveEnvironment()$flush()\n}\n\n# Retrieves the current reactive context, or errors if there is no reactive\n# context active at the moment.\ngetCurrentContext <- function() {\n  .getReactiveEnvironment()$currentContext()\n}\n\ngetDummyContext <- function() {}\nlocal({\n  dummyContext <- NULL\n  getDummyContext <<- function() {\n    if (is.null(dummyContext)) {\n      dummyContext <<- Context$new(getDefaultReactiveDomain(), '[none]',\n        type='isolate')\n    }\n    return(dummyContext)\n  }\n})\n"}],"prof_output":"/tmp/RtmpIZFL6w/file34b540981cc1.prof","highlight":{"output":["^output\\$"],"gc":["^<GC>$"],"stacktrace":["^\\.\\.stacktraceo(n|ff)\\.\\.$"]}}},"evals":[]}</script>
<script type="application/htmlwidget-sizing" data-for="htmlwidget-7411">{"viewer":{"width":450,"height":350,"padding":0,"fill":true},"browser":{"width":960,"height":500,"padding":0,"fill":true}}</script>
</body>
</html>
