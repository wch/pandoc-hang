<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
</head>
<body>
<script>{"x":"#' @import utils digest\nNULL\n\n# Like base::paste, but converts all string args to UTF-8 first.\npaste8 <- function(..., sep = \" \", collapse = NULL) {\n  args <- c(\n    lapply(list(...), enc2utf8),\n    list(\n      sep = if (is.null(sep)) sep else enc2utf8(sep),\n      collapse = if (is.null(collapse)) collapse else enc2utf8(collapse)\n    )\n  )\n\n  do.call(paste, args)\n}\n\n# Reusable function for registering a set of methods with S3 manually. The\n# methods argument is a list of character vectors, each of which has the form\n# c(package, genname, class).\nregisterMethods <- function(methods) {\n  lapply(methods, function(method) {\n    pkg <- method[[1]]\n    generic <- method[[2]]\n    class <- method[[3]]\n    func <- get(paste(generic, class, sep=\".\"))\n    if (pkg %in% loadedNamespaces()) {\n      registerS3method(generic, class, func, envir = asNamespace(pkg))\n    }\n    setHook(\n      packageEvent(pkg, \"onLoad\"),\n      function(...) {\n        registerS3method(generic, class, func, envir = asNamespace(pkg))\n      }\n    )\n  })\n}\n\n.onLoad <- function(...) {\n  # htmltools provides methods for knitr::knit_print, but knitr isn't a Depends or\n  # Imports of htmltools, only an Enhances. Therefore, the NAMESPACE file has to\n  # declare it as an export, not an S3method. That means that R will only know to\n  # use our methods if htmltools is actually attached, i.e., you have to use\n  # library(htmltools) in a knitr document or else you'll get escaped HTML in your\n  # document. This code snippet manually registers our methods with S3 once both\n  # htmltools and knitr are loaded.\n  registerMethods(list(\n    # c(package, genname, class)\n    c(\"knitr\", \"knit_print\", \"html\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag.list\")\n  ))\n}\n\ndepListToNamedDepList <- function(dependencies) {\n  if (inherits(dependencies, \"html_dependency\"))\n    dependencies <- list(dependencies)\n\n  if (is.null(names(dependencies))) {\n    names(dependencies) <- sapply(dependencies, `[[`, \"name\")\n  }\n  return(dependencies)\n}\n\n#' Resolve a list of dependencies\n#'\n#' Given a list of dependencies, removes any redundant dependencies (based on\n#' name equality). If multiple versions of a dependency are found, the copy with\n#' the latest version number is used.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects.\n#' @return dependencies A list of \\code{\\link{htmlDependency}} objects with\n#'   redundancies removed.\n#'\n#' @export\nresolveDependencies <- function(dependencies) {\n  # Remove nulls\n  deps <- dependencies[!sapply(dependencies, is.null)]\n\n  # Get names and numeric versions in vector/list form\n  depnames <- sapply(deps, `[[`, \"name\")\n  depvers <- numeric_version(sapply(deps, `[[`, \"version\"))\n\n  # Get latest version of each dependency. `unique` uses the first occurrence of\n  # each dependency name, which is important for inter-dependent libraries.\n  return(lapply(unique(depnames), function(depname) {\n    # Sort by depname equality, then by version. Since na.last=NA, all elements\n    # whose names do not match will not be included in the sorted vector.\n    sorted <- order(ifelse(depnames == depname, TRUE, NA), depvers,\n      na.last = NA, decreasing = TRUE)\n    # The first element in the list is the one with the largest version.\n    deps[[sorted[[1]]]]\n  }))\n}\n\n# Remove `remove` from `dependencies` if the name matches.\n# dependencies is a named list of dependencies.\n# remove is a named list of dependencies that take priority.\n# If warnOnConflict, then warn when a dependency is being removed because of an\n# older version already being loaded.\n\n#' Subtract dependencies\n#'\n#' Remove a set of dependencies from another list of dependencies. The set of\n#' dependencies to remove can be expressed as either a character vector or a\n#' list; if the latter, a warning can be emitted if the version of the\n#' dependency being removed is later than the version of the dependency object\n#' that is causing the removal.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects from which\n#'   dependencies should be removed.\n#' @param remove A list of \\code{\\link{htmlDependency}} objects indicating which\n#'   dependencies should be removed, or a character vector indicating dependency\n#'   names.\n#' @param warnOnConflict If \\code{TRUE}, a warning is emitted for each\n#'   dependency that is removed if the corresponding dependency in \\code{remove}\n#'   has a lower version number. Has no effect if \\code{remove} is provided as a\n#'   character vector.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects that don't intersect\n#'   with \\code{remove}.\n#'\n#' @export\nsubtractDependencies <- function(dependencies, remove, warnOnConflict = TRUE) {\n  depnames <- sapply(dependencies, `[[`, \"name\")\n  rmnames <- if (is.character(remove))\n    remove\n  else\n    sapply(remove, `[[`, \"name\")\n\n  matches <- depnames %in% rmnames\n  if (warnOnConflict && !is.character(remove)) {\n    for (loser in dependencies[matches]) {\n      winner <- remove[[head(rmnames == loser$name, 1)]]\n      if (compareVersion(loser$version, winner$version) > 0) {\n        warning(sprintf(paste(\"The dependency %s %s conflicts with\",\n          \"version %s\"), loser$name, loser$version, winner$version\n        ))\n      }\n    }\n  }\n\n  # Return only deps that weren't in remove\n  return(dependencies[!matches])\n}\n\n\n# Given a vector or list, drop all the NULL items in it\ndropNulls <- function(x) {\n  x[!vapply(x, is.null, FUN.VALUE=logical(1))]\n}\n\nnullOrEmpty <- function(x) {\n  is.null(x) || length(x) == 0\n}\n# Given a vector or list, drop all the NULL items in it\ndropNullsOrEmpty <- function(x) {\n  x[!vapply(x, nullOrEmpty, FUN.VALUE=logical(1))]\n}\n\nisTag <- function(x) {\n  inherits(x, \"shiny.tag\")\n}\n\n#' @rdname print.html\n#' @export\nprint.shiny.tag <- function(x, browse = is.browsable(x), ...) {\n  if (browse)\n    html_print(x)\n  else\n    print(as.character(x), ...)\n  invisible(x)\n}\n\n# indent can be numeric to indicate an initial indent level,\n# or FALSE to suppress\n#' @export\nformat.shiny.tag <- function(x, ..., singletons = character(0), indent = 0) {\n  as.character(renderTags(x, singletons = singletons, indent = indent)$html)\n}\n\n#' @export\nas.character.shiny.tag <- function(x, ...) {\n  as.character(renderTags(x)$html)\n}\n\n#' @export\nas.character.html <- function(x, ...) {\n  as.vector(enc2utf8(x))\n}\n\n#' @export\nprint.shiny.tag.list <- print.shiny.tag\n\n#' @export\nformat.shiny.tag.list <- format.shiny.tag\n\n#' @export\nas.character.shiny.tag.list <- as.character.shiny.tag\n\n#' Print method for HTML/tags\n#'\n#' S3 method for printing HTML that prints markup or renders HTML in a web\n#' browser.\n#'\n#' @param x The value to print.\n#' @param browse If \\code{TRUE}, the HTML will be rendered and displayed in a\n#'   browser (or possibly another HTML viewer supplied by the environment via\n#'   the \\code{viewer} option). If \\code{FALSE} then the HTML object's markup\n#'   will be rendered at the console.\n#' @param ... Additional arguments passed to print.\n#'\n#' @export\nprint.html <- function(x, ..., browse = is.browsable(x)) {\n  if (browse)\n    html_print(HTML(x))\n  else\n    cat(x, \"\\n\")\n  invisible(x)\n}\n\n#' @export\nformat.html <- function(x, ...) {\n  as.character(x)\n}\n\nnormalizeText <- function(text) {\n  if (!is.null(attr(text, \"html\", TRUE)))\n    text\n  else\n    htmlEscape(text, attribute=FALSE)\n\n}\n\n#' @name tag\n#' @rdname tag\n#' @export\ntagList <- function(...) {\n  lst <- list(...)\n  class(lst) <- c(\"shiny.tag.list\", \"list\")\n  return(lst)\n}\n\n#' @rdname tag\n#' @export\ntagAppendAttributes <- function(tag, ...) {\n  tag$attribs <- c(tag$attribs, list(...))\n  tag\n}\n\n#' @param attr The name of an attribute.\n#' @rdname tag\n#' @export\ntagHasAttribute <- function(tag, attr) {\n  result <- attr %in% names(tag$attribs)\n  result\n}\n\n#' @rdname tag\n#' @export\ntagGetAttribute <- function(tag, attr) {\n  # Find out which positions in the attributes list correspond to the given attr\n  attribs <- tag$attribs\n  attrIdx <- which(attr == names(attribs))\n\n  if (length(attrIdx) == 0) {\n    return (NULL)\n  }\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  result <- lapply(attribs[attrIdx], as.character)\n  # Separate multiple attributes with the same name\n  result <- paste(result, collapse  = \" \")\n  result\n}\n\n#' @rdname tag\n#' @export\ntagAppendChild <- function(tag, child) {\n  tag$children[[length(tag$children)+1]] <- child\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagAppendChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(tag$children, c(list(...), list))\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagSetChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(list(...), list)\n  tag\n}\n\n#' HTML Tag Object\n#'\n#' \\code{tag()} creates an HTML tag definition. Note that all of the valid HTML5\n#' tags are already defined in the \\code{\\link{tags}} environment so these\n#' functions should only be used to generate additional tags.\n#' \\code{tagAppendChild()} and \\code{tagList()} are for supporting package\n#' authors who wish to create their own sets of tags; see the contents of\n#' bootstrap.R for examples.\n#' @param _tag_name HTML tag name\n#' @param varArgs List of attributes and children of the element. Named list\n#'   items become attributes, and unnamed list items become children. Valid\n#'   children are tags, single-character character vectors (which become text\n#'   nodes), and raw HTML (see \\code{\\link{HTML}}). You can also pass lists that\n#'   contain tags, text nodes, and HTML.\n#' @param tag A tag to append child elements to.\n#' @param child A child element to append to a parent tag.\n#' @param ...  Unnamed items that comprise this list of tags.\n#' @param list An optional list of elements. Can be used with or instead of the\n#'   \\code{...} items.\n#' @return An HTML tag object that can be rendered as HTML using\n#'   \\code{\\link{as.character}()}.\n#' @export\n#' @examples\n#' tagList(tags$h1(\"Title\"),\n#'         tags$h2(\"Header text\"),\n#'         tags$p(\"Text here\"))\n#'\n#' # Can also convert a regular list to a tagList (internal data structure isn't\n#' # exactly the same, but when rendered to HTML, the output is the same).\n#' x <- list(tags$h1(\"Title\"),\n#'           tags$h2(\"Header text\"),\n#'           tags$p(\"Text here\"))\n#' tagList(x)\ntag <- function(`_tag_name`, varArgs) {\n  # Get arg names; if not a named list, use vector of empty strings\n  varArgsNames <- names(varArgs)\n  if (is.null(varArgsNames))\n    varArgsNames <- character(length=length(varArgs))\n\n  # Named arguments become attribs, dropping NULL values\n  named_idx <- nzchar(varArgsNames)\n  attribs <- dropNulls(varArgs[named_idx])\n\n  # Unnamed arguments are flattened and added as children.\n  # Use unname() to remove the names attribute from the list, which would\n  # consist of empty strings anyway.\n  children <- unname(varArgs[!named_idx])\n\n  # Return tag data structure\n  structure(\n    list(name = `_tag_name`,\n      attribs = attribs,\n      children = children),\n    class = \"shiny.tag\"\n  )\n}\n\nisTagList <- function(x) {\n  is.list(x) && (inherits(x, \"shiny.tag.list\") || identical(class(x), \"list\"))\n}\n\ntagWrite <- function(tag, textWriter, indent=0, eol = \"\\n\") {\n\n  if (length(tag) == 0)\n    return (NULL)\n\n  # optionally process a list of tags\n  if (!isTag(tag) && isTagList(tag)) {\n    tag <- dropNullsOrEmpty(flattenTags(tag))\n    lapply(tag, tagWrite, textWriter, indent)\n    return (NULL)\n  }\n\n  nextIndent <- if (is.numeric(indent)) indent + 1 else indent\n  indent <- if (is.numeric(indent)) indent else 0\n\n  # compute indent text\n  indentText <- paste(rep(\" \", indent*2), collapse=\"\")\n\n  # Check if it's just text (may either be plain-text or HTML)\n  if (is.character(tag)) {\n    textWriter(indentText)\n    textWriter(normalizeText(tag))\n    textWriter(eol)\n    return (NULL)\n  }\n\n  # write tag name\n  textWriter(paste8(indentText, \"<\", tag$name, sep=\"\"))\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  attribs <- lapply(tag$attribs, as.character)\n  # concatenate attributes\n  # split() is very slow, so avoid it if possible\n  if (anyDuplicated(names(attribs)))\n    attribs <- lapply(split(attribs, names(attribs)), paste, collapse = \" \")\n\n  # write attributes\n  for (attrib in names(attribs)) {\n    attribValue <- attribs[[attrib]]\n    if (!is.na(attribValue)) {\n      if (is.logical(attribValue))\n        attribValue <- tolower(attribValue)\n      text <- htmlEscape(attribValue, attribute=TRUE)\n      textWriter(paste8(\" \", attrib,\"=\\\"\", text, \"\\\"\", sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\" \", attrib, sep=\"\"))\n    }\n  }\n\n  # write any children\n  children <- dropNullsOrEmpty(flattenTags(tag$children))\n  if (length(children) > 0) {\n    textWriter(\">\")\n\n    # special case for a single child text node (skip newlines and indentation)\n    if ((length(children) == 1) && is.character(children[[1]]) ) {\n      textWriter(paste8(normalizeText(children[[1]]), \"\u003c/\", tag$name, \">\", eol,\n        sep=\"\"))\n    }\n    else {\n      textWriter(\"\\n\")\n      for (child in children)\n        tagWrite(child, textWriter, nextIndent)\n      textWriter(paste8(indentText, \"\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n  else {\n    # only self-close void elements\n    # (see: http://dev.w3.org/html5/spec/single-page.html#void-elements)\n    if (tag$name %in% c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\",\n      \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n      \"source\", \"track\", \"wbr\")) {\n      textWriter(paste8(\"/>\", eol, sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\">\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n}\n\n#' Render tags into HTML\n#'\n#' Renders tags (and objects that can be converted into tags using\n#' \\code{\\link{as.tags}}) into HTML. (Generally intended to be called from web\n#' framework libraries, not directly by most users--see\n#' \\code{\\link{print.html}(browse=TRUE)} for higher level rendering.)\n#'\n#' @param x Tag object(s) to render\n#' @param singletons A list of \\link{singleton} signatures to consider already\n#'   rendered; any matching singletons will be dropped instead of rendered.\n#'   (This is useful (only?) for incremental rendering.)\n#' @param indent Initial indent level, or \\code{FALSE} if no indentation should\n#'   be used.\n#'\n#' @return \\code{renderTags} returns a list with the following variables:\n#' \\describe{\n#'   \\item{\\code{head}}{An \\code{\\link{HTML}} string that should be included in\n#'     \\code{<head>}.\n#'   }\n#'   \\item{\\code{singletons}}{Character vector of singleton signatures that are\n#'     known after rendering.\n#'   }\n#'   \\item{\\code{dependencies}}{A list of \\link[=resolveDependencies]{resolved}\n#'     \\code{\\link{htmlDependency}} objects.\n#'   }\n#'   \\item{\\code{html}}{An \\code{\\link{HTML}} string that represents the main\n#'     HTML that was rendered.\n#'   }\n#' }\n#'\n#' @export\nrenderTags <- function(x, singletons = character(0), indent = 0) {\n  x <- tagify(x)\n  # Do singleton and head processing before rendering\n  singletonInfo <- takeSingletons(x, singletons)\n  headInfo <- takeHeads(singletonInfo$ui)\n  deps <- resolveDependencies(findDependencies(singletonInfo$ui))\n\n  headIndent <- if (is.numeric(indent)) indent + 1 else indent\n  headHtml <- doRenderTags(headInfo$head, indent = headIndent)\n  bodyHtml <- doRenderTags(headInfo$ui, indent = indent)\n\n  return(list(head = headHtml,\n    singletons = singletonInfo$singletons,\n    dependencies = deps,\n    html = bodyHtml))\n}\n\n#' @details \\code{doRenderTags} is intended for very low-level use; it ignores\n#'   singleton, head, and dependency handling, and simply renders the given tag\n#'   objects as HTML.\n#' @return \\code{doRenderTags} returns a simple \\code{\\link{HTML}} string.\n#' @rdname renderTags\n#' @export\ndoRenderTags <- function(x, indent = 0) {\n  # The text that is written to this connWriter will be converted to\n  # UTF-8 using enc2utf8. The rendered output will always be UTF-8\n  # encoded.\n  #\n  # We use a file() here instead of textConnection() or paste/c to\n  # avoid the overhead of copying, which is huge for moderately\n  # large numbers of calls to connWriter(). Generally when you want\n  # to incrementally build up a long string out of immutable ones,\n  # you want to use a mutable/growable string buffer of some kind;\n  # since R doesn't have something like that (that I know of),\n  # file() is the next best thing.\n  conn <- file(open=\"w+b\", encoding = \"UTF-8\")\n  connWriter <- function(text) {\n    text <- enc2utf8(text)\n    # This is actually writing UTF-8 bytes, not chars\n    writeBin(charToRaw(text), conn)\n  }\n  htmlResult <- tryCatch({\n    tagWrite(x, connWriter, indent)\n    flush(conn)\n    readLines(conn, encoding = \"UTF-8\")\n  },\n    finally = close(conn)\n  )\n  return(HTML(paste(htmlResult, collapse = \"\\n\")))\n}\n\n# Walk a tree of tag objects, rewriting objects according to func.\n# preorder=TRUE means preorder tree traversal, that is, an object\n# should be rewritten before its children.\nrewriteTags <- function(ui, func, preorder) {\n  if (preorder)\n    ui <- func(ui)\n\n  if (isTag(ui)) {\n    ui$children[] <- lapply(ui$children, rewriteTags, func, preorder)\n  } else if (isTagList(ui)) {\n    ui[] <- lapply(ui, rewriteTags, func, preorder)\n  }\n\n  if (!preorder)\n    ui <- func(ui)\n\n  return(ui)\n}\n\n#' Singleton manipulation functions\n#'\n#' Functions for manipulating \\code{\\link{singleton}} objects in tag\n#' hierarchies. Intended for framework authors.\n#'\n#' @rdname singleton_tools\n#' @name singleton_tools\nNULL\n\n#' @param ui Tag object or lists of tag objects. See \\link{builder} topic.\n#' @return \\code{surroundSingletons} preprocesses a tag object by changing any\n#'   singleton X into <!--SHINY.SINGLETON[sig]-->X'<!--/SHINY.SINGLETON[sig]-->\n#'   where sig is the sha1 of X, and X' is X minus the singleton attribute.\n#' @rdname singleton_tools\n#' @export\nsurroundSingletons <- local({\n  # In the case of nested singletons, outer singletons are processed\n  # before inner singletons (otherwise the processing of inner\n  # singletons would cause the sha1 of the outer singletons to be\n  # different).\n  surroundSingleton <- function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      uiObj <- singleton(uiObj, FALSE)\n      return(tagList(\n        HTML(sprintf(\"<!--SHINY.SINGLETON[%s]-->\", sig)),\n        uiObj,\n        HTML(sprintf(\"<!--/SHINY.SINGLETON[%s]-->\", sig))\n      ))\n    } else {\n      uiObj\n    }\n  }\n\n  function(ui) {\n    rewriteTags(ui, surroundSingleton, TRUE)\n  }\n})\n\n#' @param singletons Character vector of singleton signatures that have already\n#'   been encountered (i.e. returned from previous calls to\n#'   \\code{takeSingletons}).\n#' @param desingleton Logical value indicating whether singletons that are\n#'   encountered should have the singleton attribute removed.\n#' @return \\code{takeSingletons} returns a list with the elements \\code{ui} (the\n#'   processed tag objects with any duplicate singleton objects removed) and\n#'   \\code{singletons} (the list of known singleton signatures).\n#' @rdname singleton_tools\n#' @export\ntakeSingletons <- function(ui, singletons=character(0), desingleton=TRUE) {\n  result <- rewriteTags(ui, function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      if (sig %in% singletons)\n        return(NULL)\n      singletons <<- append(singletons, sig)\n      if (desingleton)\n        uiObj <- singleton(uiObj, FALSE)\n      return(uiObj)\n    } else {\n      return(uiObj)\n    }\n  }, TRUE)\n\n  return(list(ui=result, singletons=singletons))\n}\n\n# Given a tag object, extract out any children of tags$head\n# and return them separate from the body.\ntakeHeads <- function(ui) {\n  headItems <- list()\n  result <- rewriteTags(ui, function(uiObj) {\n    if (isTag(uiObj) && tolower(uiObj$name) == \"head\") {\n      headItems <<- append(headItems, uiObj$children)\n      return(NULL)\n    }\n    return(uiObj)\n  }, FALSE)\n\n  return(list(ui=result, head=headItems))\n}\n\n#' Collect attached dependencies from HTML tag object\n#'\n#' Walks a hierarchy of tags looking for attached dependencies.\n#'\n#' @param tags A tag-like object to search for dependencies.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects.\n#'\n#' @export\nfindDependencies <- function(tags) {\n  dep <- htmlDependencies(tags)\n  if (!is.null(dep) && inherits(dep, \"html_dependency\"))\n    dep <- list(dep)\n  children <- if (is.list(tags)) {\n    if (isTag(tags)) {\n      tags$children\n    } else {\n      tags\n    }\n  }\n  childDeps <- unlist(lapply(children, findDependencies), recursive = FALSE)\n  c(childDeps, if (!is.null(dep)) dep)\n}\n\n#' HTML Builder Functions\n#'\n#' Simple functions for constructing HTML documents.\n#'\n#' The \\code{tags} environment contains convenience functions for all valid\n#' HTML5 tags. To generate tags that are not part of the HTML5 specification,\n#' you can use the \\code{\\link{tag}()} function.\n#'\n#' Dedicated functions are available for the most common HTML tags that do not\n#' conflict with common R functions.\n#'\n#' The result from these functions is a tag object, which can be converted using\n#' \\code{\\link{as.character}()}.\n#'\n#' @name builder\n#' @param ... Attributes and children of the element. Named arguments become\n#'   attributes, and positional arguments become children. Valid children are\n#'   tags, single-character character vectors (which become text nodes), and raw\n#'   HTML (see \\code{\\link{HTML}}). You can also pass lists that contain tags,\n#'   text nodes, and HTML.\n#' @export tags\n#' @examples\n#' doc <- tags$html(\n#'   tags$head(\n#'     tags$title('My first page')\n#'   ),\n#'   tags$body(\n#'     h1('My first heading'),\n#'     p('My first paragraph, with some ',\n#'       strong('bold'),\n#'       ' text.'),\n#'     div(id='myDiv', class='simpleDiv',\n#'         'Here is a div with some attributes.')\n#'   )\n#' )\n#' cat(as.character(doc))\nNULL\n\n#' @rdname builder\n#' @format NULL\n#' @docType NULL\n#' @keywords NULL\ntags <- list(\n  a = function(...) tag(\"a\", list(...)),\n  abbr = function(...) tag(\"abbr\", list(...)),\n  address = function(...) tag(\"address\", list(...)),\n  area = function(...) tag(\"area\", list(...)),\n  article = function(...) tag(\"article\", list(...)),\n  aside = function(...) tag(\"aside\", list(...)),\n  audio = function(...) tag(\"audio\", list(...)),\n  b = function(...) tag(\"b\", list(...)),\n  base = function(...) tag(\"base\", list(...)),\n  bdi = function(...) tag(\"bdi\", list(...)),\n  bdo = function(...) tag(\"bdo\", list(...)),\n  blockquote = function(...) tag(\"blockquote\", list(...)),\n  body = function(...) tag(\"body\", list(...)),\n  br = function(...) tag(\"br\", list(...)),\n  button = function(...) tag(\"button\", list(...)),\n  canvas = function(...) tag(\"canvas\", list(...)),\n  caption = function(...) tag(\"caption\", list(...)),\n  cite = function(...) tag(\"cite\", list(...)),\n  code = function(...) tag(\"code\", list(...)),\n  col = function(...) tag(\"col\", list(...)),\n  colgroup = function(...) tag(\"colgroup\", list(...)),\n  command = function(...) tag(\"command\", list(...)),\n  data = function(...) tag(\"data\", list(...)),\n  datalist = function(...) tag(\"datalist\", list(...)),\n  dd = function(...) tag(\"dd\", list(...)),\n  del = function(...) tag(\"del\", list(...)),\n  details = function(...) tag(\"details\", list(...)),\n  dfn = function(...) tag(\"dfn\", list(...)),\n  div = function(...) tag(\"div\", list(...)),\n  dl = function(...) tag(\"dl\", list(...)),\n  dt = function(...) tag(\"dt\", list(...)),\n  em = function(...) tag(\"em\", list(...)),\n  embed = function(...) tag(\"embed\", list(...)),\n  eventsource = function(...) tag(\"eventsource\", list(...)),\n  fieldset = function(...) tag(\"fieldset\", list(...)),\n  figcaption = function(...) tag(\"figcaption\", list(...)),\n  figure = function(...) tag(\"figure\", list(...)),\n  footer = function(...) tag(\"footer\", list(...)),\n  form = function(...) tag(\"form\", list(...)),\n  h1 = function(...) tag(\"h1\", list(...)),\n  h2 = function(...) tag(\"h2\", list(...)),\n  h3 = function(...) tag(\"h3\", list(...)),\n  h4 = function(...) tag(\"h4\", list(...)),\n  h5 = function(...) tag(\"h5\", list(...)),\n  h6 = function(...) tag(\"h6\", list(...)),\n  head = function(...) tag(\"head\", list(...)),\n  header = function(...) tag(\"header\", list(...)),\n  hgroup = function(...) tag(\"hgroup\", list(...)),\n  hr = function(...) tag(\"hr\", list(...)),\n  html = function(...) tag(\"html\", list(...)),\n  i = function(...) tag(\"i\", list(...)),\n  iframe = function(...) tag(\"iframe\", list(...)),\n  img = function(...) tag(\"img\", list(...)),\n  input = function(...) tag(\"input\", list(...)),\n  ins = function(...) tag(\"ins\", list(...)),\n  kbd = function(...) tag(\"kbd\", list(...)),\n  keygen = function(...) tag(\"keygen\", list(...)),\n  label = function(...) tag(\"label\", list(...)),\n  legend = function(...) tag(\"legend\", list(...)),\n  li = function(...) tag(\"li\", list(...)),\n  link = function(...) tag(\"link\", list(...)),\n  mark = function(...) tag(\"mark\", list(...)),\n  map = function(...) tag(\"map\", list(...)),\n  menu = function(...) tag(\"menu\", list(...)),\n  meta = function(...) tag(\"meta\", list(...)),\n  meter = function(...) tag(\"meter\", list(...)),\n  nav = function(...) tag(\"nav\", list(...)),\n  noscript = function(...) tag(\"noscript\", list(...)),\n  object = function(...) tag(\"object\", list(...)),\n  ol = function(...) tag(\"ol\", list(...)),\n  optgroup = function(...) tag(\"optgroup\", list(...)),\n  option = function(...) tag(\"option\", list(...)),\n  output = function(...) tag(\"output\", list(...)),\n  p = function(...) tag(\"p\", list(...)),\n  param = function(...) tag(\"param\", list(...)),\n  pre = function(...) tag(\"pre\", list(...)),\n  progress = function(...) tag(\"progress\", list(...)),\n  q = function(...) tag(\"q\", list(...)),\n  ruby = function(...) tag(\"ruby\", list(...)),\n  rp = function(...) tag(\"rp\", list(...)),\n  rt = function(...) tag(\"rt\", list(...)),\n  s = function(...) tag(\"s\", list(...)),\n  samp = function(...) tag(\"samp\", list(...)),\n  script = function(...) tag(\"script\", list(...)),\n  section = function(...) tag(\"section\", list(...)),\n  select = function(...) tag(\"select\", list(...)),\n  small = function(...) tag(\"small\", list(...)),\n  source = function(...) tag(\"source\", list(...)),\n  span = function(...) tag(\"span\", list(...)),\n  strong = function(...) tag(\"strong\", list(...)),\n  style = function(...) tag(\"style\", list(...)),\n  sub = function(...) tag(\"sub\", list(...)),\n  summary = function(...) tag(\"summary\", list(...)),\n  sup = function(...) tag(\"sup\", list(...)),\n  table = function(...) tag(\"table\", list(...)),\n  tbody = function(...) tag(\"tbody\", list(...)),\n  td = function(...) tag(\"td\", list(...)),\n  textarea = function(...) tag(\"textarea\", list(...)),\n  tfoot = function(...) tag(\"tfoot\", list(...)),\n  th = function(...) tag(\"th\", list(...)),\n  thead = function(...) tag(\"thead\", list(...)),\n  time = function(...) tag(\"time\", list(...)),\n  title = function(...) tag(\"title\", list(...)),\n  tr = function(...) tag(\"tr\", list(...)),\n  track = function(...) tag(\"track\", list(...)),\n  u = function(...) tag(\"u\", list(...)),\n  ul = function(...) tag(\"ul\", list(...)),\n  var = function(...) tag(\"var\", list(...)),\n  video = function(...) tag(\"video\", list(...)),\n  wbr = function(...) tag(\"wbr\", list(...))\n)\n\n#' Mark Characters as HTML\n#'\n#' Marks the given text as HTML, which means the \\link{tag} functions will know\n#' not to perform HTML escaping on it.\n#'\n#' @param text The text value to mark with HTML\n#' @param ... Any additional values to be converted to character and\n#'   concatenated together\n#' @return The same value, but marked as HTML.\n#'\n#' @examples\n#' el <- div(HTML(\"I like <u>turtles\u003c/u>\"))\n#' cat(as.character(el))\n#'\n#' @export\nHTML <- function(text, ...) {\n  htmlText <- c(text, as.character(list(...)))\n  htmlText <- paste8(htmlText, collapse=\" \")\n  attr(htmlText, \"html\") <- TRUE\n  class(htmlText) <- c(\"html\", \"character\")\n  htmlText\n}\n\n#' Evaluate an expression using \\code{tags}\n#'\n#' This function makes it simpler to write HTML-generating code. Instead of\n#' needing to specify \\code{tags} each time a tag function is used, as in\n#' \\code{tags$div()} and \\code{tags$p()}, code inside \\code{withTags} is\n#' evaluated with \\code{tags} searched first, so you can simply use\n#' \\code{div()} and \\code{p()}.\n#'\n#' If your code uses an object which happens to have the same name as an\n#' HTML tag function, such as \\code{source()} or \\code{summary()}, it will call\n#' the tag function. To call the intended (non-tags function), specify the\n#' namespace, as in \\code{base::source()} or \\code{base::summary()}.\n#'\n#' @param code A set of tags.\n#'\n#' @examples\n#' # Using tags$ each time\n#' tags$div(class = \"myclass\",\n#'   tags$h3(\"header\"),\n#'   tags$p(\"text\")\n#' )\n#'\n#' # Equivalent to above, but using withTags\n#' withTags(\n#'   div(class = \"myclass\",\n#'     h3(\"header\"),\n#'     p(\"text\")\n#'   )\n#' )\n#'\n#'\n#' @export\nwithTags <- function(code) {\n  eval(substitute(code), envir = as.list(tags), enclos = parent.frame())\n}\n\n# Make sure any objects in the tree that can be converted to tags, have been\ntagify <- function(x) {\n  rewriteTags(x, function(uiObj) {\n    if (isTag(uiObj) || isTagList(uiObj) || is.character(uiObj))\n      return(uiObj)\n    else\n      return(tagify(as.tags(uiObj)))\n  }, FALSE)\n}\n\n# Given a list of tags, lists, and other items, return a flat list, where the\n# items from the inner, nested lists are pulled to the top level, recursively.\nflattenTags <- function(x) {\n  if (isTag(x)) {\n    # For tags, wrap them into a list (which will be unwrapped by caller)\n    list(x)\n  } else if (isTagList(x)) {\n    if (length(x) == 0) {\n      # Empty lists are simply returned\n      x\n    } else {\n      # For items that are lists (but not tags), recurse\n      unlist(lapply(x, flattenTags), recursive = FALSE)\n    }\n\n  } else if (is.character(x)){\n    # This will preserve attributes if x is a character with attribute,\n    # like what HTML() produces\n    list(x)\n\n  } else {\n    # For other items, coerce to character and wrap them into a list (which\n    # will be unwrapped by caller). Note that this will strip attributes.\n    flattenTags(as.tags(x))\n  }\n}\n\n#' Convert a value to tags\n#'\n#' An S3 method for converting arbitrary values to a value that can be used as\n#' the child of a tag or \\code{tagList}. The default implementation simply calls\n#' \\code{\\link[base]{as.character}}.\n#'\n#' @param x Object to be converted.\n#' @param ... Any additional parameters.\n#'\n#' @export\nas.tags <- function(x, ...) {\n  UseMethod(\"as.tags\")\n}\n\n#' @export\nas.tags.default <- function(x, ...) {\n  if (is.list(x) && !isTagList(x))\n    unclass(x)\n  else\n    tagList(as.character(x))\n}\n\n#' @export\nas.tags.html <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag.list <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.character <- function(x, ...) {\n  # For printing as.tags(\"<strong>\") directly at console, without dropping any\n  # attached dependencies\n  tagList(x)\n}\n\n#' Preserve HTML regions\n#'\n#' Use \"magic\" HTML comments to protect regions of HTML from being modified by\n#' text processing tools.\n#'\n#' Text processing tools like markdown and pandoc are designed to turn\n#' human-friendly markup into common output formats like HTML. This works well\n#' for most prose, but components that generate their own HTML may break if\n#' their markup is interpreted as the input language. The \\code{htmlPreserve}\n#' function is used to mark regions of an input document as containing pure HTML\n#' that must not be modified. This is achieved by substituting each such region\n#' with a benign but unique string before processing, and undoing those\n#' substitutions after processing.\n#'\n#' @param x A character vector of HTML to be preserved.\n#'\n#' @return \\code{htmlPreserve} returns a single-element character vector with\n#'   \"magic\" HTML comments surrounding the original text (unless the original\n#'   text was empty, in which case an empty string is returned).\n#'\n#' @examples\n#' # htmlPreserve will prevent \"<script>alert(10*2*3);\u003c/script>\"\n#' # from getting an <em> tag inserted in the middle\n#' markup <- paste(sep = \"\\n\",\n#'   \"This is *emphasized* text in markdown.\",\n#'   htmlPreserve(\"<script>alert(10*2*3);\u003c/script>\"),\n#'   \"Here is some more *emphasized text*.\"\n#' )\n#' extracted <- extractPreserveChunks(markup)\n#' markup <- extracted$value\n#' # Just think of this next line as Markdown processing\n#' output <- gsub(\"\\\\*(.*?)\\\\*\", \"<em>\\\\1\u003c/em>\", markup)\n#' output <- restorePreserveChunks(output, extracted$chunks)\n#' output\n#'\n#' @export\nhtmlPreserve <- function(x) {\n  x <- paste(x, collapse = \"\\r\\n\")\n  if (nzchar(x))\n    sprintf(\"<!--html_preserve-->%s<!--/html_preserve-->\", x)\n  else\n    x\n}\n\n# Temporarily set x in env to value, evaluate expr, and\n# then restore x to its original state\nwithTemporary <- function(env, x, value, expr, unset = FALSE) {\n\n  if (exists(x, envir = env, inherits = FALSE)) {\n    oldValue <- get(x, envir = env, inherits = FALSE)\n    on.exit(\n      assign(x, oldValue, envir = env, inherits = FALSE),\n      add = TRUE)\n  } else {\n    on.exit(\n      rm(list = x, envir = env, inherits = FALSE),\n      add = TRUE\n    )\n  }\n\n  if (!missing(value) && !isTRUE(unset))\n    assign(x, value, envir = env, inherits = FALSE)\n  else {\n    if (exists(x, envir = env, inherits = FALSE))\n      rm(list = x, envir = env, inherits = FALSE)\n  }\n  force(expr)\n}\n\n# Evaluate an expression using Shiny's own private stream of\n# randomness (not affected by set.seed).\nwithPrivateSeed <- local({\n  ownSeed <- NULL\n  function(expr) {\n    withTemporary(.GlobalEnv, \".Random.seed\",\n      ownSeed, unset=is.null(ownSeed), {\n        tryCatch({\n          expr\n        }, finally = {ownSeed <<- .Random.seed})\n      }\n    )\n  }\n})\n\n# extract_preserve_chunks looks for regions in strval marked by\n# <!--html_preserve-->...<!--/html_preserve--> and replaces each such region\n# with a long unique ID. The return value is a list with $value as the string\n# with the regions replaced, and $chunks as a named character vector where the\n# names are the IDs and the values are the regions that were extracted.\n#\n# Nested regions are handled appropriately; the outermost region is what's used\n# and any inner regions simply have their boundaries removed before the values\n# are stashed in $chunks.\n\n#' @return \\code{extractPreserveChunks} returns a list with two named elements:\n#'   \\code{value} is the string with the regions replaced, and \\code{chunks} is\n#'   a named character vector where the names are the IDs and the values are the\n#'   regions that were extracted.\n#' @rdname htmlPreserve\n#' @export\nextractPreserveChunks <- function(strval) {\n\n  # Literal start/end marker text. Case sensitive.\n  startmarker <- \"<!--html_preserve-->\"\n  endmarker <- \"<!--/html_preserve-->\"\n  # Start and end marker length MUST be different, it's how we tell them apart\n  startmarker_len <- nchar(startmarker)\n  endmarker_len <- nchar(endmarker)\n  # Pattern must match both start and end markers\n  pattern <- \"<!--/?html_preserve-->\"\n\n  # It simplifies string handling greatly to collapse multiple char elements\n  if (length(strval) != 1)\n    strval <- paste(strval, collapse = \"\\n\")\n\n  # matches contains the index of all the start and end markers\n  matches <- gregexpr(pattern, strval)[[1]]\n  lengths <- attr(matches, \"match.length\", TRUE)\n\n  # No markers? Just return.\n  if (matches[[1]] == -1)\n    return(list(value = strval, chunks = character(0)))\n\n  # If TRUE, it's a start; if FALSE, it's an end\n  boundary_type <- lengths == startmarker_len\n\n  # Positive number means we're inside a region, zero means we just exited to\n  # the top-level, negative number means error (an end without matching start).\n  # For example:\n  # boundary_type - TRUE TRUE FALSE FALSE TRUE FALSE\n  # preserve_level - 1 2 1 0 1 0\n  preserve_level <- cumsum(ifelse(boundary_type, 1, -1))\n\n  # Sanity check.\n  if (any(preserve_level < 0) || tail(preserve_level, 1) != 0) {\n    stop(\"Invalid nesting of html_preserve directives\")\n  }\n\n  # Identify all the top-level boundary markers. We want to find all of the\n  # elements of preserve_level whose value is 0 and preceding value is 1, or\n  # whose value is 1 and preceding value is 0. Since we know that preserve_level\n  # values can only go up or down by 1, we can simply shift preserve_level by\n  # one element and add it to preserve_level; in the result, any value of 1 is a\n  # match.\n  is_top_level <- 1 == (preserve_level + c(0, preserve_level[-length(preserve_level)]))\n\n  preserved <- character(0)\n\n  top_level_matches <- matches[is_top_level]\n  # Iterate backwards so string mutation doesn't screw up positions for future\n  # iterations\n  for (i in seq.int(length(top_level_matches) - 1, 1, by = -2)) {\n    start_outer <- top_level_matches[[i]]\n    start_inner <- start_outer + startmarker_len\n    end_inner <- top_level_matches[[i+1]]\n    end_outer <- end_inner + endmarker_len\n\n    id <- withPrivateSeed(\n      paste(\"preserve\", paste(\n        format(as.hexmode(sample(256, 8, replace = TRUE)-1), width=2),\n        collapse = \"\"),\n        sep = \"\")\n    )\n\n    preserved[id] <- gsub(pattern, \"\", substr(strval, start_inner, end_inner-1))\n\n    strval <- paste(\n      substr(strval, 1, start_outer - 1),\n      id,\n      substr(strval, end_outer, nchar(strval)),\n      sep=\"\")\n    substr(strval, start_outer, end_outer-1) <- id\n  }\n\n  list(value = strval, chunks = preserved)\n}\n\n#' @param strval Input string from which to extract/restore chunks.\n#' @param chunks The \\code{chunks} element of the return value of\n#'   \\code{extractPreserveChunks}.\n#' @return \\code{restorePreserveChunks} returns a character vector with the\n#'   chunk IDs replaced with their original values.\n#' @rdname htmlPreserve\n#' @export\nrestorePreserveChunks <- function(strval, chunks) {\n  for (id in names(chunks))\n    strval <- gsub(id, chunks[[id]], strval, fixed = TRUE, useBytes = TRUE)\n  strval\n}\n\n#' Knitr S3 methods\n#'\n#' These S3 methods are necessary to allow HTML tags to print themselves in\n#' knitr/rmarkdown documents.\n#'\n#' @name knitr_methods\n#' @param x Object to knit_print\n#' @param ... Additional knit_print arguments\nNULL\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag <- function(x, ...) {\n  x <- tagify(x)\n  output <- surroundSingletons(x)\n  deps <- resolveDependencies(findDependencies(x))\n  content <- takeHeads(output)\n  head_content <- doRenderTags(tagList(content$head))\n\n  meta <- if (length(head_content) > 1 || head_content != \"\") {\n    list(structure(head_content, class = \"shiny_head\"))\n  }\n  meta <- c(meta, deps)\n\n  knitr::asis_output(\n    htmlPreserve(format(content$ui, indent=FALSE)),\n    meta = meta)\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.html <- function(x, ...) {\n  deps <- resolveDependencies(findDependencies(x))\n  knitr::asis_output(htmlPreserve(as.character(x)),\n    meta = if (length(deps)) list(deps))\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag.list <- knit_print.shiny.tag\n\n\n\n#' @rdname builder\n#' @export\np <- function(...) tags$p(...)\n\n#' @rdname builder\n#' @export\nh1 <- function(...) tags$h1(...)\n\n#' @rdname builder\n#' @export\nh2 <- function(...) tags$h2(...)\n\n#' @rdname builder\n#' @export\nh3 <- function(...) tags$h3(...)\n\n#' @rdname builder\n#' @export\nh4 <- function(...) tags$h4(...)\n\n#' @rdname builder\n#' @export\nh5 <- function(...) tags$h5(...)\n\n#' @rdname builder\n#' @export\nh6 <- function(...) tags$h6(...)\n\n#' @rdname builder\n#' @export\na <- function(...) tags$a(...)\n\n#' @rdname builder\n#' @export\nbr <- function(...) tags$br(...)\n\n#' @rdname builder\n#' @export\ndiv <- function(...) tags$div(...)\n\n#' @rdname builder\n#' @export\nspan <- function(...) tags$span(...)\n\n#' @rdname builder\n#' @export\npre <- function(...) tags$pre(...)\n\n#' @rdname builder\n#' @export\ncode <- function(...) tags$code(...)\n\n#' @rdname builder\n#' @export\nimg <- function(...) tags$img(...)\n\n#' @rdname builder\n#' @export\nstrong <- function(...) tags$strong(...)\n\n#' @rdname builder\n#' @export\nem <- function(...) tags$em(...)\n\n#' @rdname builder\n#' @export\nhr <- function(...) tags$hr(...)\n\n#' Include Content From a File\n#'\n#' Load HTML, text, or rendered Markdown from a file and turn into HTML.\n#'\n#' These functions provide a convenient way to include an extensive amount of\n#' HTML, textual, Markdown, CSS, or JavaScript content, rather than using a\n#' large literal R string.\n#'\n#' @param path The path of the file to be included. It is highly recommended to\n#'   use a relative path (the base path being the Shiny application directory),\n#'   not an absolute path.\n#'\n#' @rdname include\n#' @name include\n#' @aliases includeHTML\n#' @export\nincludeHTML <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(HTML(paste8(lines, collapse='\\r\\n')))\n}\n\n#' @note \\code{includeText} escapes its contents, but does no other processing.\n#'   This means that hard breaks and multiple spaces will be rendered as they\n#'   usually are in HTML: as a single space character. If you are looking for\n#'   preformatted text, wrap the call with \\code{\\link{pre}}, or consider using\n#'   \\code{includeMarkdown} instead.\n#'\n#' @rdname include\n#' @export\nincludeText <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(paste8(lines, collapse='\\r\\n'))\n}\n\n#' @note The \\code{includeMarkdown} function requires the \\code{markdown}\n#'   package.\n#' @rdname include\n#' @export\nincludeMarkdown <- function(path) {\n  html <- markdown::markdownToHTML(path, fragment.only=TRUE)\n  Encoding(html) <- 'UTF-8'\n  return(HTML(html))\n}\n\n#' @param ... Any additional attributes to be applied to the generated tag.\n#' @rdname include\n#' @export\nincludeCSS <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  args <- list(...)\n  if (is.null(args$type))\n    args$type <- 'text/css'\n  return(do.call(tags$style,\n    c(list(HTML(paste8(lines, collapse='\\r\\n'))), args)))\n}\n\n#' @rdname include\n#' @export\nincludeScript <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(tags$script(HTML(paste8(lines, collapse='\\r\\n')), ...))\n}\n\n#' Include content only once\n#'\n#' Use \\code{singleton} to wrap contents (tag, text, HTML, or lists) that should\n#' be included in the generated document only once, yet may appear in the\n#' document-generating code more than once. Only the first appearance of the\n#' content (in document order) will be used.\n#'\n#' @param x A \\code{\\link{tag}}, text, \\code{\\link{HTML}}, or list.\n#' @param value Whether the object should be a singleton.\n#'\n#' @export\nsingleton <- function(x, value = TRUE) {\n  attr(x, \"htmltools.singleton\") <- if (isTRUE(value)) TRUE else NULL\n  return(x)\n}\n\n#' @rdname singleton\n#' @export\nis.singleton <- function(x) {\n  isTRUE(attr(x, \"htmltools.singleton\"))\n}\n\n\n#' Validate proper CSS formatting of a unit\n#'\n#' Checks that the argument is valid for use as a CSS unit of length.\n#'\n#' \\code{NULL} and \\code{NA} are returned unchanged.\n#'\n#' Single element numeric vectors are returned as a character vector with the\n#' number plus a suffix of \\code{\"px\"}.\n#'\n#' Single element character vectors must be \\code{\"auto\"} or \\code{\"inherit\"},\n#' or a number. If the number has a suffix, it must be valid: \\code{px},\n#' \\code{\\%}, \\code{em}, \\code{pt}, \\code{in}, \\code{cm}, \\code{mm}, \\code{ex},\n#' or \\code{pc}. If the number has no suffix, the suffix \\code{\"px\"} is\n#' appended.\n#'\n#' Any other value will cause an error to be thrown.\n#'\n#' @param x The unit to validate. Will be treated as a number of pixels if a\n#'   unit is not specified.\n#' @return A properly formatted CSS unit of length, if possible. Otherwise, will\n#'   throw an error.\n#' @examples\n#' validateCssUnit(\"10%\")\n#' validateCssUnit(400)  #treated as '400px'\n#' @export\nvalidateCssUnit <- function(x) {\n  if (is.null(x) || is.na(x))\n    return(x)\n\n  if (length(x) > 1 || (!is.character(x) && !is.numeric(x)))\n    stop('CSS units must be a single-element numeric or character vector')\n\n  # if the input is a character vector consisting only of digits (e.g. \"960\"),\n  # coerce it to a numeric value\n  if (is.character(x) && nchar(x) > 0 && gsub(\"\\\\d*\", \"\", x) == \"\")\n    x <- as.numeric(x)\n\n  pattern <-\n    \"^(auto|inherit|((\\\\.\\\\d+)|(\\\\d+(\\\\.\\\\d+)?))(%|in|cm|mm|em|ex|pt|pc|px))$\"\n\n  if (is.character(x) &&\n      !grepl(pattern, x)) {\n    stop('\"', x, '\" is not a valid CSS unit (e.g., \"100%\", \"400px\", \"auto\")')\n  } else if (is.numeric(x)) {\n    x <- paste(x, \"px\", sep = \"\")\n  }\n  x\n}\n\n#' CSS string helper\n#'\n#' Convenience function for building CSS style declarations (i.e. the string\n#' that goes into a style attribute, or the parts that go inside curly braces in\n#' a full stylesheet).\n#'\n#' CSS uses \\code{'-'} (minus) as a separator character in property names, but\n#' this is an inconvenient character to use in an R function argument name.\n#' Instead, you can use \\code{'.'} (period) and/or \\code{'_'} (underscore) as\n#' separator characters. For example, \\code{css(font.size = \"12px\")} yields\n#' \\code{\"font-size:12px;\"}.\n#'\n#' To mark a property as \\code{!important}, add a \\code{'!'} character to the end\n#' of the property name. (Since \\code{'!'} is not normally a character that can be\n#' used in an identifier in R, you'll need to put the name in double quotes or\n#' backticks.)\n#'\n#' Argument values will be converted to strings using\n#' \\code{paste(collapse = \" \")}. Any property with a value of \\code{NULL} or\n#' \\code{\"\"} (after paste) will be dropped.\n#'\n#' @param ... Named style properties, where the name is the property name and\n#'   the argument is the property value. See Details for conversion rules.\n#' @param collapse_ (Note that the parameter name has a trailing underscore\n#'   character.) Character to use to collapse properties into a single string;\n#'   likely \\code{\"\"} (the default) for style attributes, and either \\code{\"\\n\"}\n#'   or \\code{NULL} for style blocks.\n#'\n#' @examples\n#' padding <- 6\n#' css(\n#'   font.family = \"Helvetica, sans-serif\",\n#'   margin = paste0(c(10, 20, 10, 20), \"px\"),\n#'   \"padding!\" = if (!is.null(padding)) padding\n#' )\n#'\n#' @export\ncss <- function(..., collapse_ = \"\") {\n  props <- list(...)\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  if (is.null(names(props)) || any(names(props) == \"\")) {\n    stop(\"cssList expects all arguments to be named\")\n  }\n\n  # Necessary to make factors show up as level names, not numbers\n  props[] <- lapply(props, paste, collapse = \" \")\n\n  # Drop null args\n  props <- props[!sapply(props, empty)]\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  # Replace all '.' and '_' in property names to '-'\n  names(props) <- gsub(\"[._]\", \"-\", tolower(gsub(\"([A-Z])\", \"-\\\\1\", names(props))))\n\n  # Create \"!important\" suffix for each property whose name ends with !, then\n  # remove the ! from the property name\n  important <- ifelse(grepl(\"!$\", names(props), perl = TRUE), \" !important\", \"\")\n  names(props) <- sub(\"!$\", \"\", names(props), perl = TRUE)\n\n  paste0(names(props), \":\", props, important, \";\", collapse = collapse_)\n}\n\nempty <- function(x) {\n  length(x) == 0 || (is.character(x) && !any(nzchar(x)))\n}\n#' @import utils digest\nNULL\n\n# Like base::paste, but converts all string args to UTF-8 first.\npaste8 <- function(..., sep = \" \", collapse = NULL) {\n  args <- c(\n    lapply(list(...), enc2utf8),\n    list(\n      sep = if (is.null(sep)) sep else enc2utf8(sep),\n      collapse = if (is.null(collapse)) collapse else enc2utf8(collapse)\n    )\n  )\n\n  do.call(paste, args)\n}\n\n# Reusable function for registering a set of methods with S3 manually. The\n# methods argument is a list of character vectors, each of which has the form\n# c(package, genname, class).\nregisterMethods <- function(methods) {\n  lapply(methods, function(method) {\n    pkg <- method[[1]]\n    generic <- method[[2]]\n    class <- method[[3]]\n    func <- get(paste(generic, class, sep=\".\"))\n    if (pkg %in% loadedNamespaces()) {\n      registerS3method(generic, class, func, envir = asNamespace(pkg))\n    }\n    setHook(\n      packageEvent(pkg, \"onLoad\"),\n      function(...) {\n        registerS3method(generic, class, func, envir = asNamespace(pkg))\n      }\n    )\n  })\n}\n\n.onLoad <- function(...) {\n  # htmltools provides methods for knitr::knit_print, but knitr isn't a Depends or\n  # Imports of htmltools, only an Enhances. Therefore, the NAMESPACE file has to\n  # declare it as an export, not an S3method. That means that R will only know to\n  # use our methods if htmltools is actually attached, i.e., you have to use\n  # library(htmltools) in a knitr document or else you'll get escaped HTML in your\n  # document. This code snippet manually registers our methods with S3 once both\n  # htmltools and knitr are loaded.\n  registerMethods(list(\n    # c(package, genname, class)\n    c(\"knitr\", \"knit_print\", \"html\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag\"),\n    c(\"knitr\", \"knit_print\", \"shiny.tag.list\")\n  ))\n}\n\ndepListToNamedDepList <- function(dependencies) {\n  if (inherits(dependencies, \"html_dependency\"))\n    dependencies <- list(dependencies)\n\n  if (is.null(names(dependencies))) {\n    names(dependencies) <- sapply(dependencies, `[[`, \"name\")\n  }\n  return(dependencies)\n}\n\n#' Resolve a list of dependencies\n#'\n#' Given a list of dependencies, removes any redundant dependencies (based on\n#' name equality). If multiple versions of a dependency are found, the copy with\n#' the latest version number is used.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects.\n#' @return dependencies A list of \\code{\\link{htmlDependency}} objects with\n#'   redundancies removed.\n#'\n#' @export\nresolveDependencies <- function(dependencies) {\n  # Remove nulls\n  deps <- dependencies[!sapply(dependencies, is.null)]\n\n  # Get names and numeric versions in vector/list form\n  depnames <- sapply(deps, `[[`, \"name\")\n  depvers <- numeric_version(sapply(deps, `[[`, \"version\"))\n\n  # Get latest version of each dependency. `unique` uses the first occurrence of\n  # each dependency name, which is important for inter-dependent libraries.\n  return(lapply(unique(depnames), function(depname) {\n    # Sort by depname equality, then by version. Since na.last=NA, all elements\n    # whose names do not match will not be included in the sorted vector.\n    sorted <- order(ifelse(depnames == depname, TRUE, NA), depvers,\n      na.last = NA, decreasing = TRUE)\n    # The first element in the list is the one with the largest version.\n    deps[[sorted[[1]]]]\n  }))\n}\n\n# Remove `remove` from `dependencies` if the name matches.\n# dependencies is a named list of dependencies.\n# remove is a named list of dependencies that take priority.\n# If warnOnConflict, then warn when a dependency is being removed because of an\n# older version already being loaded.\n\n#' Subtract dependencies\n#'\n#' Remove a set of dependencies from another list of dependencies. The set of\n#' dependencies to remove can be expressed as either a character vector or a\n#' list; if the latter, a warning can be emitted if the version of the\n#' dependency being removed is later than the version of the dependency object\n#' that is causing the removal.\n#'\n#' @param dependencies A list of \\code{\\link{htmlDependency}} objects from which\n#'   dependencies should be removed.\n#' @param remove A list of \\code{\\link{htmlDependency}} objects indicating which\n#'   dependencies should be removed, or a character vector indicating dependency\n#'   names.\n#' @param warnOnConflict If \\code{TRUE}, a warning is emitted for each\n#'   dependency that is removed if the corresponding dependency in \\code{remove}\n#'   has a lower version number. Has no effect if \\code{remove} is provided as a\n#'   character vector.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects that don't intersect\n#'   with \\code{remove}.\n#'\n#' @export\nsubtractDependencies <- function(dependencies, remove, warnOnConflict = TRUE) {\n  depnames <- sapply(dependencies, `[[`, \"name\")\n  rmnames <- if (is.character(remove))\n    remove\n  else\n    sapply(remove, `[[`, \"name\")\n\n  matches <- depnames %in% rmnames\n  if (warnOnConflict && !is.character(remove)) {\n    for (loser in dependencies[matches]) {\n      winner <- remove[[head(rmnames == loser$name, 1)]]\n      if (compareVersion(loser$version, winner$version) > 0) {\n        warning(sprintf(paste(\"The dependency %s %s conflicts with\",\n          \"version %s\"), loser$name, loser$version, winner$version\n        ))\n      }\n    }\n  }\n\n  # Return only deps that weren't in remove\n  return(dependencies[!matches])\n}\n\n\n# Given a vector or list, drop all the NULL items in it\ndropNulls <- function(x) {\n  x[!vapply(x, is.null, FUN.VALUE=logical(1))]\n}\n\nnullOrEmpty <- function(x) {\n  is.null(x) || length(x) == 0\n}\n# Given a vector or list, drop all the NULL items in it\ndropNullsOrEmpty <- function(x) {\n  x[!vapply(x, nullOrEmpty, FUN.VALUE=logical(1))]\n}\n\nisTag <- function(x) {\n  inherits(x, \"shiny.tag\")\n}\n\n#' @rdname print.html\n#' @export\nprint.shiny.tag <- function(x, browse = is.browsable(x), ...) {\n  if (browse)\n    html_print(x)\n  else\n    print(as.character(x), ...)\n  invisible(x)\n}\n\n# indent can be numeric to indicate an initial indent level,\n# or FALSE to suppress\n#' @export\nformat.shiny.tag <- function(x, ..., singletons = character(0), indent = 0) {\n  as.character(renderTags(x, singletons = singletons, indent = indent)$html)\n}\n\n#' @export\nas.character.shiny.tag <- function(x, ...) {\n  as.character(renderTags(x)$html)\n}\n\n#' @export\nas.character.html <- function(x, ...) {\n  as.vector(enc2utf8(x))\n}\n\n#' @export\nprint.shiny.tag.list <- print.shiny.tag\n\n#' @export\nformat.shiny.tag.list <- format.shiny.tag\n\n#' @export\nas.character.shiny.tag.list <- as.character.shiny.tag\n\n#' Print method for HTML/tags\n#'\n#' S3 method for printing HTML that prints markup or renders HTML in a web\n#' browser.\n#'\n#' @param x The value to print.\n#' @param browse If \\code{TRUE}, the HTML will be rendered and displayed in a\n#'   browser (or possibly another HTML viewer supplied by the environment via\n#'   the \\code{viewer} option). If \\code{FALSE} then the HTML object's markup\n#'   will be rendered at the console.\n#' @param ... Additional arguments passed to print.\n#'\n#' @export\nprint.html <- function(x, ..., browse = is.browsable(x)) {\n  if (browse)\n    html_print(HTML(x))\n  else\n    cat(x, \"\\n\")\n  invisible(x)\n}\n\n#' @export\nformat.html <- function(x, ...) {\n  as.character(x)\n}\n\nnormalizeText <- function(text) {\n  if (!is.null(attr(text, \"html\", TRUE)))\n    text\n  else\n    htmlEscape(text, attribute=FALSE)\n\n}\n\n#' @name tag\n#' @rdname tag\n#' @export\ntagList <- function(...) {\n  lst <- list(...)\n  class(lst) <- c(\"shiny.tag.list\", \"list\")\n  return(lst)\n}\n\n#' @rdname tag\n#' @export\ntagAppendAttributes <- function(tag, ...) {\n  tag$attribs <- c(tag$attribs, list(...))\n  tag\n}\n\n#' @param attr The name of an attribute.\n#' @rdname tag\n#' @export\ntagHasAttribute <- function(tag, attr) {\n  result <- attr %in% names(tag$attribs)\n  result\n}\n\n#' @rdname tag\n#' @export\ntagGetAttribute <- function(tag, attr) {\n  # Find out which positions in the attributes list correspond to the given attr\n  attribs <- tag$attribs\n  attrIdx <- which(attr == names(attribs))\n\n  if (length(attrIdx) == 0) {\n    return (NULL)\n  }\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  result <- lapply(attribs[attrIdx], as.character)\n  # Separate multiple attributes with the same name\n  result <- paste(result, collapse  = \" \")\n  result\n}\n\n#' @rdname tag\n#' @export\ntagAppendChild <- function(tag, child) {\n  tag$children[[length(tag$children)+1]] <- child\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagAppendChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(tag$children, c(list(...), list))\n  tag\n}\n\n#' @rdname tag\n#' @export\ntagSetChildren <- function(tag, ..., list = NULL) {\n  tag$children <- c(list(...), list)\n  tag\n}\n\n#' HTML Tag Object\n#'\n#' \\code{tag()} creates an HTML tag definition. Note that all of the valid HTML5\n#' tags are already defined in the \\code{\\link{tags}} environment so these\n#' functions should only be used to generate additional tags.\n#' \\code{tagAppendChild()} and \\code{tagList()} are for supporting package\n#' authors who wish to create their own sets of tags; see the contents of\n#' bootstrap.R for examples.\n#' @param _tag_name HTML tag name\n#' @param varArgs List of attributes and children of the element. Named list\n#'   items become attributes, and unnamed list items become children. Valid\n#'   children are tags, single-character character vectors (which become text\n#'   nodes), and raw HTML (see \\code{\\link{HTML}}). You can also pass lists that\n#'   contain tags, text nodes, and HTML.\n#' @param tag A tag to append child elements to.\n#' @param child A child element to append to a parent tag.\n#' @param ...  Unnamed items that comprise this list of tags.\n#' @param list An optional list of elements. Can be used with or instead of the\n#'   \\code{...} items.\n#' @return An HTML tag object that can be rendered as HTML using\n#'   \\code{\\link{as.character}()}.\n#' @export\n#' @examples\n#' tagList(tags$h1(\"Title\"),\n#'         tags$h2(\"Header text\"),\n#'         tags$p(\"Text here\"))\n#'\n#' # Can also convert a regular list to a tagList (internal data structure isn't\n#' # exactly the same, but when rendered to HTML, the output is the same).\n#' x <- list(tags$h1(\"Title\"),\n#'           tags$h2(\"Header text\"),\n#'           tags$p(\"Text here\"))\n#' tagList(x)\ntag <- function(`_tag_name`, varArgs) {\n  # Get arg names; if not a named list, use vector of empty strings\n  varArgsNames <- names(varArgs)\n  if (is.null(varArgsNames))\n    varArgsNames <- character(length=length(varArgs))\n\n  # Named arguments become attribs, dropping NULL values\n  named_idx <- nzchar(varArgsNames)\n  attribs <- dropNulls(varArgs[named_idx])\n\n  # Unnamed arguments are flattened and added as children.\n  # Use unname() to remove the names attribute from the list, which would\n  # consist of empty strings anyway.\n  children <- unname(varArgs[!named_idx])\n\n  # Return tag data structure\n  structure(\n    list(name = `_tag_name`,\n      attribs = attribs,\n      children = children),\n    class = \"shiny.tag\"\n  )\n}\n\nisTagList <- function(x) {\n  is.list(x) && (inherits(x, \"shiny.tag.list\") || identical(class(x), \"list\"))\n}\n\ntagWrite <- function(tag, textWriter, indent=0, eol = \"\\n\") {\n\n  if (length(tag) == 0)\n    return (NULL)\n\n  # optionally process a list of tags\n  if (!isTag(tag) && isTagList(tag)) {\n    tag <- dropNullsOrEmpty(flattenTags(tag))\n    lapply(tag, tagWrite, textWriter, indent)\n    return (NULL)\n  }\n\n  nextIndent <- if (is.numeric(indent)) indent + 1 else indent\n  indent <- if (is.numeric(indent)) indent else 0\n\n  # compute indent text\n  indentText <- paste(rep(\" \", indent*2), collapse=\"\")\n\n  # Check if it's just text (may either be plain-text or HTML)\n  if (is.character(tag)) {\n    textWriter(indentText)\n    textWriter(normalizeText(tag))\n    textWriter(eol)\n    return (NULL)\n  }\n\n  # write tag name\n  textWriter(paste8(indentText, \"<\", tag$name, sep=\"\"))\n\n  # Convert all attribs to chars explicitly; prevents us from messing up factors\n  attribs <- lapply(tag$attribs, as.character)\n  # concatenate attributes\n  # split() is very slow, so avoid it if possible\n  if (anyDuplicated(names(attribs)))\n    attribs <- lapply(split(attribs, names(attribs)), paste, collapse = \" \")\n\n  # write attributes\n  for (attrib in names(attribs)) {\n    attribValue <- attribs[[attrib]]\n    if (!is.na(attribValue)) {\n      if (is.logical(attribValue))\n        attribValue <- tolower(attribValue)\n      text <- htmlEscape(attribValue, attribute=TRUE)\n      textWriter(paste8(\" \", attrib,\"=\\\"\", text, \"\\\"\", sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\" \", attrib, sep=\"\"))\n    }\n  }\n\n  # write any children\n  children <- dropNullsOrEmpty(flattenTags(tag$children))\n  if (length(children) > 0) {\n    textWriter(\">\")\n\n    # special case for a single child text node (skip newlines and indentation)\n    if ((length(children) == 1) && is.character(children[[1]]) ) {\n      textWriter(paste8(normalizeText(children[[1]]), \"\u003c/\", tag$name, \">\", eol,\n        sep=\"\"))\n    }\n    else {\n      textWriter(\"\\n\")\n      for (child in children)\n        tagWrite(child, textWriter, nextIndent)\n      textWriter(paste8(indentText, \"\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n  else {\n    # only self-close void elements\n    # (see: http://dev.w3.org/html5/spec/single-page.html#void-elements)\n    if (tag$name %in% c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\",\n      \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n      \"source\", \"track\", \"wbr\")) {\n      textWriter(paste8(\"/>\", eol, sep=\"\"))\n    }\n    else {\n      textWriter(paste8(\">\u003c/\", tag$name, \">\", eol, sep=\"\"))\n    }\n  }\n}\n\n#' Render tags into HTML\n#'\n#' Renders tags (and objects that can be converted into tags using\n#' \\code{\\link{as.tags}}) into HTML. (Generally intended to be called from web\n#' framework libraries, not directly by most users--see\n#' \\code{\\link{print.html}(browse=TRUE)} for higher level rendering.)\n#'\n#' @param x Tag object(s) to render\n#' @param singletons A list of \\link{singleton} signatures to consider already\n#'   rendered; any matching singletons will be dropped instead of rendered.\n#'   (This is useful (only?) for incremental rendering.)\n#' @param indent Initial indent level, or \\code{FALSE} if no indentation should\n#'   be used.\n#'\n#' @return \\code{renderTags} returns a list with the following variables:\n#' \\describe{\n#'   \\item{\\code{head}}{An \\code{\\link{HTML}} string that should be included in\n#'     \\code{<head>}.\n#'   }\n#'   \\item{\\code{singletons}}{Character vector of singleton signatures that are\n#'     known after rendering.\n#'   }\n#'   \\item{\\code{dependencies}}{A list of \\link[=resolveDependencies]{resolved}\n#'     \\code{\\link{htmlDependency}} objects.\n#'   }\n#'   \\item{\\code{html}}{An \\code{\\link{HTML}} string that represents the main\n#'     HTML that was rendered.\n#'   }\n#' }\n#'\n#' @export\nrenderTags <- function(x, singletons = character(0), indent = 0) {\n  x <- tagify(x)\n  # Do singleton and head processing before rendering\n  singletonInfo <- takeSingletons(x, singletons)\n  headInfo <- takeHeads(singletonInfo$ui)\n  deps <- resolveDependencies(findDependencies(singletonInfo$ui))\n\n  headIndent <- if (is.numeric(indent)) indent + 1 else indent\n  headHtml <- doRenderTags(headInfo$head, indent = headIndent)\n  bodyHtml <- doRenderTags(headInfo$ui, indent = indent)\n\n  return(list(head = headHtml,\n    singletons = singletonInfo$singletons,\n    dependencies = deps,\n    html = bodyHtml))\n}\n\n#' @details \\code{doRenderTags} is intended for very low-level use; it ignores\n#'   singleton, head, and dependency handling, and simply renders the given tag\n#'   objects as HTML.\n#' @return \\code{doRenderTags} returns a simple \\code{\\link{HTML}} string.\n#' @rdname renderTags\n#' @export\ndoRenderTags <- function(x, indent = 0) {\n  # The text that is written to this connWriter will be converted to\n  # UTF-8 using enc2utf8. The rendered output will always be UTF-8\n  # encoded.\n  #\n  # We use a file() here instead of textConnection() or paste/c to\n  # avoid the overhead of copying, which is huge for moderately\n  # large numbers of calls to connWriter(). Generally when you want\n  # to incrementally build up a long string out of immutable ones,\n  # you want to use a mutable/growable string buffer of some kind;\n  # since R doesn't have something like that (that I know of),\n  # file() is the next best thing.\n  conn <- file(open=\"w+b\", encoding = \"UTF-8\")\n  connWriter <- function(text) {\n    text <- enc2utf8(text)\n    # This is actually writing UTF-8 bytes, not chars\n    writeBin(charToRaw(text), conn)\n  }\n  htmlResult <- tryCatch({\n    tagWrite(x, connWriter, indent)\n    flush(conn)\n    readLines(conn, encoding = \"UTF-8\")\n  },\n    finally = close(conn)\n  )\n  return(HTML(paste(htmlResult, collapse = \"\\n\")))\n}\n\n# Walk a tree of tag objects, rewriting objects according to func.\n# preorder=TRUE means preorder tree traversal, that is, an object\n# should be rewritten before its children.\nrewriteTags <- function(ui, func, preorder) {\n  if (preorder)\n    ui <- func(ui)\n\n  if (isTag(ui)) {\n    ui$children[] <- lapply(ui$children, rewriteTags, func, preorder)\n  } else if (isTagList(ui)) {\n    ui[] <- lapply(ui, rewriteTags, func, preorder)\n  }\n\n  if (!preorder)\n    ui <- func(ui)\n\n  return(ui)\n}\n\n#' Singleton manipulation functions\n#'\n#' Functions for manipulating \\code{\\link{singleton}} objects in tag\n#' hierarchies. Intended for framework authors.\n#'\n#' @rdname singleton_tools\n#' @name singleton_tools\nNULL\n\n#' @param ui Tag object or lists of tag objects. See \\link{builder} topic.\n#' @return \\code{surroundSingletons} preprocesses a tag object by changing any\n#'   singleton X into <!--SHINY.SINGLETON[sig]-->X'<!--/SHINY.SINGLETON[sig]-->\n#'   where sig is the sha1 of X, and X' is X minus the singleton attribute.\n#' @rdname singleton_tools\n#' @export\nsurroundSingletons <- local({\n  # In the case of nested singletons, outer singletons are processed\n  # before inner singletons (otherwise the processing of inner\n  # singletons would cause the sha1 of the outer singletons to be\n  # different).\n  surroundSingleton <- function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      uiObj <- singleton(uiObj, FALSE)\n      return(tagList(\n        HTML(sprintf(\"<!--SHINY.SINGLETON[%s]-->\", sig)),\n        uiObj,\n        HTML(sprintf(\"<!--/SHINY.SINGLETON[%s]-->\", sig))\n      ))\n    } else {\n      uiObj\n    }\n  }\n\n  function(ui) {\n    rewriteTags(ui, surroundSingleton, TRUE)\n  }\n})\n\n#' @param singletons Character vector of singleton signatures that have already\n#'   been encountered (i.e. returned from previous calls to\n#'   \\code{takeSingletons}).\n#' @param desingleton Logical value indicating whether singletons that are\n#'   encountered should have the singleton attribute removed.\n#' @return \\code{takeSingletons} returns a list with the elements \\code{ui} (the\n#'   processed tag objects with any duplicate singleton objects removed) and\n#'   \\code{singletons} (the list of known singleton signatures).\n#' @rdname singleton_tools\n#' @export\ntakeSingletons <- function(ui, singletons=character(0), desingleton=TRUE) {\n  result <- rewriteTags(ui, function(uiObj) {\n    if (is.singleton(uiObj)) {\n      sig <- digest(uiObj, \"sha1\")\n      if (sig %in% singletons)\n        return(NULL)\n      singletons <<- append(singletons, sig)\n      if (desingleton)\n        uiObj <- singleton(uiObj, FALSE)\n      return(uiObj)\n    } else {\n      return(uiObj)\n    }\n  }, TRUE)\n\n  return(list(ui=result, singletons=singletons))\n}\n\n# Given a tag object, extract out any children of tags$head\n# and return them separate from the body.\ntakeHeads <- function(ui) {\n  headItems <- list()\n  result <- rewriteTags(ui, function(uiObj) {\n    if (isTag(uiObj) && tolower(uiObj$name) == \"head\") {\n      headItems <<- append(headItems, uiObj$children)\n      return(NULL)\n    }\n    return(uiObj)\n  }, FALSE)\n\n  return(list(ui=result, head=headItems))\n}\n\n#' Collect attached dependencies from HTML tag object\n#'\n#' Walks a hierarchy of tags looking for attached dependencies.\n#'\n#' @param tags A tag-like object to search for dependencies.\n#'\n#' @return A list of \\code{\\link{htmlDependency}} objects.\n#'\n#' @export\nfindDependencies <- function(tags) {\n  dep <- htmlDependencies(tags)\n  if (!is.null(dep) && inherits(dep, \"html_dependency\"))\n    dep <- list(dep)\n  children <- if (is.list(tags)) {\n    if (isTag(tags)) {\n      tags$children\n    } else {\n      tags\n    }\n  }\n  childDeps <- unlist(lapply(children, findDependencies), recursive = FALSE)\n  c(childDeps, if (!is.null(dep)) dep)\n}\n\n#' HTML Builder Functions\n#'\n#' Simple functions for constructing HTML documents.\n#'\n#' The \\code{tags} environment contains convenience functions for all valid\n#' HTML5 tags. To generate tags that are not part of the HTML5 specification,\n#' you can use the \\code{\\link{tag}()} function.\n#'\n#' Dedicated functions are available for the most common HTML tags that do not\n#' conflict with common R functions.\n#'\n#' The result from these functions is a tag object, which can be converted using\n#' \\code{\\link{as.character}()}.\n#'\n#' @name builder\n#' @param ... Attributes and children of the element. Named arguments become\n#'   attributes, and positional arguments become children. Valid children are\n#'   tags, single-character character vectors (which become text nodes), and raw\n#'   HTML (see \\code{\\link{HTML}}). You can also pass lists that contain tags,\n#'   text nodes, and HTML.\n#' @export tags\n#' @examples\n#' doc <- tags$html(\n#'   tags$head(\n#'     tags$title('My first page')\n#'   ),\n#'   tags$body(\n#'     h1('My first heading'),\n#'     p('My first paragraph, with some ',\n#'       strong('bold'),\n#'       ' text.'),\n#'     div(id='myDiv', class='simpleDiv',\n#'         'Here is a div with some attributes.')\n#'   )\n#' )\n#' cat(as.character(doc))\nNULL\n\n#' @rdname builder\n#' @format NULL\n#' @docType NULL\n#' @keywords NULL\ntags <- list(\n  a = function(...) tag(\"a\", list(...)),\n  abbr = function(...) tag(\"abbr\", list(...)),\n  address = function(...) tag(\"address\", list(...)),\n  area = function(...) tag(\"area\", list(...)),\n  article = function(...) tag(\"article\", list(...)),\n  aside = function(...) tag(\"aside\", list(...)),\n  audio = function(...) tag(\"audio\", list(...)),\n  b = function(...) tag(\"b\", list(...)),\n  base = function(...) tag(\"base\", list(...)),\n  bdi = function(...) tag(\"bdi\", list(...)),\n  bdo = function(...) tag(\"bdo\", list(...)),\n  blockquote = function(...) tag(\"blockquote\", list(...)),\n  body = function(...) tag(\"body\", list(...)),\n  br = function(...) tag(\"br\", list(...)),\n  button = function(...) tag(\"button\", list(...)),\n  canvas = function(...) tag(\"canvas\", list(...)),\n  caption = function(...) tag(\"caption\", list(...)),\n  cite = function(...) tag(\"cite\", list(...)),\n  code = function(...) tag(\"code\", list(...)),\n  col = function(...) tag(\"col\", list(...)),\n  colgroup = function(...) tag(\"colgroup\", list(...)),\n  command = function(...) tag(\"command\", list(...)),\n  data = function(...) tag(\"data\", list(...)),\n  datalist = function(...) tag(\"datalist\", list(...)),\n  dd = function(...) tag(\"dd\", list(...)),\n  del = function(...) tag(\"del\", list(...)),\n  details = function(...) tag(\"details\", list(...)),\n  dfn = function(...) tag(\"dfn\", list(...)),\n  div = function(...) tag(\"div\", list(...)),\n  dl = function(...) tag(\"dl\", list(...)),\n  dt = function(...) tag(\"dt\", list(...)),\n  em = function(...) tag(\"em\", list(...)),\n  embed = function(...) tag(\"embed\", list(...)),\n  eventsource = function(...) tag(\"eventsource\", list(...)),\n  fieldset = function(...) tag(\"fieldset\", list(...)),\n  figcaption = function(...) tag(\"figcaption\", list(...)),\n  figure = function(...) tag(\"figure\", list(...)),\n  footer = function(...) tag(\"footer\", list(...)),\n  form = function(...) tag(\"form\", list(...)),\n  h1 = function(...) tag(\"h1\", list(...)),\n  h2 = function(...) tag(\"h2\", list(...)),\n  h3 = function(...) tag(\"h3\", list(...)),\n  h4 = function(...) tag(\"h4\", list(...)),\n  h5 = function(...) tag(\"h5\", list(...)),\n  h6 = function(...) tag(\"h6\", list(...)),\n  head = function(...) tag(\"head\", list(...)),\n  header = function(...) tag(\"header\", list(...)),\n  hgroup = function(...) tag(\"hgroup\", list(...)),\n  hr = function(...) tag(\"hr\", list(...)),\n  html = function(...) tag(\"html\", list(...)),\n  i = function(...) tag(\"i\", list(...)),\n  iframe = function(...) tag(\"iframe\", list(...)),\n  img = function(...) tag(\"img\", list(...)),\n  input = function(...) tag(\"input\", list(...)),\n  ins = function(...) tag(\"ins\", list(...)),\n  kbd = function(...) tag(\"kbd\", list(...)),\n  keygen = function(...) tag(\"keygen\", list(...)),\n  label = function(...) tag(\"label\", list(...)),\n  legend = function(...) tag(\"legend\", list(...)),\n  li = function(...) tag(\"li\", list(...)),\n  link = function(...) tag(\"link\", list(...)),\n  mark = function(...) tag(\"mark\", list(...)),\n  map = function(...) tag(\"map\", list(...)),\n  menu = function(...) tag(\"menu\", list(...)),\n  meta = function(...) tag(\"meta\", list(...)),\n  meter = function(...) tag(\"meter\", list(...)),\n  nav = function(...) tag(\"nav\", list(...)),\n  noscript = function(...) tag(\"noscript\", list(...)),\n  object = function(...) tag(\"object\", list(...)),\n  ol = function(...) tag(\"ol\", list(...)),\n  optgroup = function(...) tag(\"optgroup\", list(...)),\n  option = function(...) tag(\"option\", list(...)),\n  output = function(...) tag(\"output\", list(...)),\n  p = function(...) tag(\"p\", list(...)),\n  param = function(...) tag(\"param\", list(...)),\n  pre = function(...) tag(\"pre\", list(...)),\n  progress = function(...) tag(\"progress\", list(...)),\n  q = function(...) tag(\"q\", list(...)),\n  ruby = function(...) tag(\"ruby\", list(...)),\n  rp = function(...) tag(\"rp\", list(...)),\n  rt = function(...) tag(\"rt\", list(...)),\n  s = function(...) tag(\"s\", list(...)),\n  samp = function(...) tag(\"samp\", list(...)),\n  script = function(...) tag(\"script\", list(...)),\n  section = function(...) tag(\"section\", list(...)),\n  select = function(...) tag(\"select\", list(...)),\n  small = function(...) tag(\"small\", list(...)),\n  source = function(...) tag(\"source\", list(...)),\n  span = function(...) tag(\"span\", list(...)),\n  strong = function(...) tag(\"strong\", list(...)),\n  style = function(...) tag(\"style\", list(...)),\n  sub = function(...) tag(\"sub\", list(...)),\n  summary = function(...) tag(\"summary\", list(...)),\n  sup = function(...) tag(\"sup\", list(...)),\n  table = function(...) tag(\"table\", list(...)),\n  tbody = function(...) tag(\"tbody\", list(...)),\n  td = function(...) tag(\"td\", list(...)),\n  textarea = function(...) tag(\"textarea\", list(...)),\n  tfoot = function(...) tag(\"tfoot\", list(...)),\n  th = function(...) tag(\"th\", list(...)),\n  thead = function(...) tag(\"thead\", list(...)),\n  time = function(...) tag(\"time\", list(...)),\n  title = function(...) tag(\"title\", list(...)),\n  tr = function(...) tag(\"tr\", list(...)),\n  track = function(...) tag(\"track\", list(...)),\n  u = function(...) tag(\"u\", list(...)),\n  ul = function(...) tag(\"ul\", list(...)),\n  var = function(...) tag(\"var\", list(...)),\n  video = function(...) tag(\"video\", list(...)),\n  wbr = function(...) tag(\"wbr\", list(...))\n)\n\n#' Mark Characters as HTML\n#'\n#' Marks the given text as HTML, which means the \\link{tag} functions will know\n#' not to perform HTML escaping on it.\n#'\n#' @param text The text value to mark with HTML\n#' @param ... Any additional values to be converted to character and\n#'   concatenated together\n#' @return The same value, but marked as HTML.\n#'\n#' @examples\n#' el <- div(HTML(\"I like <u>turtles\u003c/u>\"))\n#' cat(as.character(el))\n#'\n#' @export\nHTML <- function(text, ...) {\n  htmlText <- c(text, as.character(list(...)))\n  htmlText <- paste8(htmlText, collapse=\" \")\n  attr(htmlText, \"html\") <- TRUE\n  class(htmlText) <- c(\"html\", \"character\")\n  htmlText\n}\n\n#' Evaluate an expression using \\code{tags}\n#'\n#' This function makes it simpler to write HTML-generating code. Instead of\n#' needing to specify \\code{tags} each time a tag function is used, as in\n#' \\code{tags$div()} and \\code{tags$p()}, code inside \\code{withTags} is\n#' evaluated with \\code{tags} searched first, so you can simply use\n#' \\code{div()} and \\code{p()}.\n#'\n#' If your code uses an object which happens to have the same name as an\n#' HTML tag function, such as \\code{source()} or \\code{summary()}, it will call\n#' the tag function. To call the intended (non-tags function), specify the\n#' namespace, as in \\code{base::source()} or \\code{base::summary()}.\n#'\n#' @param code A set of tags.\n#'\n#' @examples\n#' # Using tags$ each time\n#' tags$div(class = \"myclass\",\n#'   tags$h3(\"header\"),\n#'   tags$p(\"text\")\n#' )\n#'\n#' # Equivalent to above, but using withTags\n#' withTags(\n#'   div(class = \"myclass\",\n#'     h3(\"header\"),\n#'     p(\"text\")\n#'   )\n#' )\n#'\n#'\n#' @export\nwithTags <- function(code) {\n  eval(substitute(code), envir = as.list(tags), enclos = parent.frame())\n}\n\n# Make sure any objects in the tree that can be converted to tags, have been\ntagify <- function(x) {\n  rewriteTags(x, function(uiObj) {\n    if (isTag(uiObj) || isTagList(uiObj) || is.character(uiObj))\n      return(uiObj)\n    else\n      return(tagify(as.tags(uiObj)))\n  }, FALSE)\n}\n\n# Given a list of tags, lists, and other items, return a flat list, where the\n# items from the inner, nested lists are pulled to the top level, recursively.\nflattenTags <- function(x) {\n  if (isTag(x)) {\n    # For tags, wrap them into a list (which will be unwrapped by caller)\n    list(x)\n  } else if (isTagList(x)) {\n    if (length(x) == 0) {\n      # Empty lists are simply returned\n      x\n    } else {\n      # For items that are lists (but not tags), recurse\n      unlist(lapply(x, flattenTags), recursive = FALSE)\n    }\n\n  } else if (is.character(x)){\n    # This will preserve attributes if x is a character with attribute,\n    # like what HTML() produces\n    list(x)\n\n  } else {\n    # For other items, coerce to character and wrap them into a list (which\n    # will be unwrapped by caller). Note that this will strip attributes.\n    flattenTags(as.tags(x))\n  }\n}\n\n#' Convert a value to tags\n#'\n#' An S3 method for converting arbitrary values to a value that can be used as\n#' the child of a tag or \\code{tagList}. The default implementation simply calls\n#' \\code{\\link[base]{as.character}}.\n#'\n#' @param x Object to be converted.\n#' @param ... Any additional parameters.\n#'\n#' @export\nas.tags <- function(x, ...) {\n  UseMethod(\"as.tags\")\n}\n\n#' @export\nas.tags.default <- function(x, ...) {\n  if (is.list(x) && !isTagList(x))\n    unclass(x)\n  else\n    tagList(as.character(x))\n}\n\n#' @export\nas.tags.html <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.shiny.tag.list <- function(x, ...) {\n  x\n}\n\n#' @export\nas.tags.character <- function(x, ...) {\n  # For printing as.tags(\"<strong>\") directly at console, without dropping any\n  # attached dependencies\n  tagList(x)\n}\n\n#' Preserve HTML regions\n#'\n#' Use \"magic\" HTML comments to protect regions of HTML from being modified by\n#' text processing tools.\n#'\n#' Text processing tools like markdown and pandoc are designed to turn\n#' human-friendly markup into common output formats like HTML. This works well\n#' for most prose, but components that generate their own HTML may break if\n#' their markup is interpreted as the input language. The \\code{htmlPreserve}\n#' function is used to mark regions of an input document as containing pure HTML\n#' that must not be modified. This is achieved by substituting each such region\n#' with a benign but unique string before processing, and undoing those\n#' substitutions after processing.\n#'\n#' @param x A character vector of HTML to be preserved.\n#'\n#' @return \\code{htmlPreserve} returns a single-element character vector with\n#'   \"magic\" HTML comments surrounding the original text (unless the original\n#'   text was empty, in which case an empty string is returned).\n#'\n#' @examples\n#' # htmlPreserve will prevent \"<script>alert(10*2*3);\u003c/script>\"\n#' # from getting an <em> tag inserted in the middle\n#' markup <- paste(sep = \"\\n\",\n#'   \"This is *emphasized* text in markdown.\",\n#'   htmlPreserve(\"<script>alert(10*2*3);\u003c/script>\"),\n#'   \"Here is some more *emphasized text*.\"\n#' )\n#' extracted <- extractPreserveChunks(markup)\n#' markup <- extracted$value\n#' # Just think of this next line as Markdown processing\n#' output <- gsub(\"\\\\*(.*?)\\\\*\", \"<em>\\\\1\u003c/em>\", markup)\n#' output <- restorePreserveChunks(output, extracted$chunks)\n#' output\n#'\n#' @export\nhtmlPreserve <- function(x) {\n  x <- paste(x, collapse = \"\\r\\n\")\n  if (nzchar(x))\n    sprintf(\"<!--html_preserve-->%s<!--/html_preserve-->\", x)\n  else\n    x\n}\n\n# Temporarily set x in env to value, evaluate expr, and\n# then restore x to its original state\nwithTemporary <- function(env, x, value, expr, unset = FALSE) {\n\n  if (exists(x, envir = env, inherits = FALSE)) {\n    oldValue <- get(x, envir = env, inherits = FALSE)\n    on.exit(\n      assign(x, oldValue, envir = env, inherits = FALSE),\n      add = TRUE)\n  } else {\n    on.exit(\n      rm(list = x, envir = env, inherits = FALSE),\n      add = TRUE\n    )\n  }\n\n  if (!missing(value) && !isTRUE(unset))\n    assign(x, value, envir = env, inherits = FALSE)\n  else {\n    if (exists(x, envir = env, inherits = FALSE))\n      rm(list = x, envir = env, inherits = FALSE)\n  }\n  force(expr)\n}\n\n# Evaluate an expression using Shiny's own private stream of\n# randomness (not affected by set.seed).\nwithPrivateSeed <- local({\n  ownSeed <- NULL\n  function(expr) {\n    withTemporary(.GlobalEnv, \".Random.seed\",\n      ownSeed, unset=is.null(ownSeed), {\n        tryCatch({\n          expr\n        }, finally = {ownSeed <<- .Random.seed})\n      }\n    )\n  }\n})\n\n# extract_preserve_chunks looks for regions in strval marked by\n# <!--html_preserve-->...<!--/html_preserve--> and replaces each such region\n# with a long unique ID. The return value is a list with $value as the string\n# with the regions replaced, and $chunks as a named character vector where the\n# names are the IDs and the values are the regions that were extracted.\n#\n# Nested regions are handled appropriately; the outermost region is what's used\n# and any inner regions simply have their boundaries removed before the values\n# are stashed in $chunks.\n\n#' @return \\code{extractPreserveChunks} returns a list with two named elements:\n#'   \\code{value} is the string with the regions replaced, and \\code{chunks} is\n#'   a named character vector where the names are the IDs and the values are the\n#'   regions that were extracted.\n#' @rdname htmlPreserve\n#' @export\nextractPreserveChunks <- function(strval) {\n\n  # Literal start/end marker text. Case sensitive.\n  startmarker <- \"<!--html_preserve-->\"\n  endmarker <- \"<!--/html_preserve-->\"\n  # Start and end marker length MUST be different, it's how we tell them apart\n  startmarker_len <- nchar(startmarker)\n  endmarker_len <- nchar(endmarker)\n  # Pattern must match both start and end markers\n  pattern <- \"<!--/?html_preserve-->\"\n\n  # It simplifies string handling greatly to collapse multiple char elements\n  if (length(strval) != 1)\n    strval <- paste(strval, collapse = \"\\n\")\n\n  # matches contains the index of all the start and end markers\n  matches <- gregexpr(pattern, strval)[[1]]\n  lengths <- attr(matches, \"match.length\", TRUE)\n\n  # No markers? Just return.\n  if (matches[[1]] == -1)\n    return(list(value = strval, chunks = character(0)))\n\n  # If TRUE, it's a start; if FALSE, it's an end\n  boundary_type <- lengths == startmarker_len\n\n  # Positive number means we're inside a region, zero means we just exited to\n  # the top-level, negative number means error (an end without matching start).\n  # For example:\n  # boundary_type - TRUE TRUE FALSE FALSE TRUE FALSE\n  # preserve_level - 1 2 1 0 1 0\n  preserve_level <- cumsum(ifelse(boundary_type, 1, -1))\n\n  # Sanity check.\n  if (any(preserve_level < 0) || tail(preserve_level, 1) != 0) {\n    stop(\"Invalid nesting of html_preserve directives\")\n  }\n\n  # Identify all the top-level boundary markers. We want to find all of the\n  # elements of preserve_level whose value is 0 and preceding value is 1, or\n  # whose value is 1 and preceding value is 0. Since we know that preserve_level\n  # values can only go up or down by 1, we can simply shift preserve_level by\n  # one element and add it to preserve_level; in the result, any value of 1 is a\n  # match.\n  is_top_level <- 1 == (preserve_level + c(0, preserve_level[-length(preserve_level)]))\n\n  preserved <- character(0)\n\n  top_level_matches <- matches[is_top_level]\n  # Iterate backwards so string mutation doesn't screw up positions for future\n  # iterations\n  for (i in seq.int(length(top_level_matches) - 1, 1, by = -2)) {\n    start_outer <- top_level_matches[[i]]\n    start_inner <- start_outer + startmarker_len\n    end_inner <- top_level_matches[[i+1]]\n    end_outer <- end_inner + endmarker_len\n\n    id <- withPrivateSeed(\n      paste(\"preserve\", paste(\n        format(as.hexmode(sample(256, 8, replace = TRUE)-1), width=2),\n        collapse = \"\"),\n        sep = \"\")\n    )\n\n    preserved[id] <- gsub(pattern, \"\", substr(strval, start_inner, end_inner-1))\n\n    strval <- paste(\n      substr(strval, 1, start_outer - 1),\n      id,\n      substr(strval, end_outer, nchar(strval)),\n      sep=\"\")\n    substr(strval, start_outer, end_outer-1) <- id\n  }\n\n  list(value = strval, chunks = preserved)\n}\n\n#' @param strval Input string from which to extract/restore chunks.\n#' @param chunks The \\code{chunks} element of the return value of\n#'   \\code{extractPreserveChunks}.\n#' @return \\code{restorePreserveChunks} returns a character vector with the\n#'   chunk IDs replaced with their original values.\n#' @rdname htmlPreserve\n#' @export\nrestorePreserveChunks <- function(strval, chunks) {\n  for (id in names(chunks))\n    strval <- gsub(id, chunks[[id]], strval, fixed = TRUE, useBytes = TRUE)\n  strval\n}\n\n#' Knitr S3 methods\n#'\n#' These S3 methods are necessary to allow HTML tags to print themselves in\n#' knitr/rmarkdown documents.\n#'\n#' @name knitr_methods\n#' @param x Object to knit_print\n#' @param ... Additional knit_print arguments\nNULL\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag <- function(x, ...) {\n  x <- tagify(x)\n  output <- surroundSingletons(x)\n  deps <- resolveDependencies(findDependencies(x))\n  content <- takeHeads(output)\n  head_content <- doRenderTags(tagList(content$head))\n\n  meta <- if (length(head_content) > 1 || head_content != \"\") {\n    list(structure(head_content, class = \"shiny_head\"))\n  }\n  meta <- c(meta, deps)\n\n  knitr::asis_output(\n    htmlPreserve(format(content$ui, indent=FALSE)),\n    meta = meta)\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.html <- function(x, ...) {\n  deps <- resolveDependencies(findDependencies(x))\n  knitr::asis_output(htmlPreserve(as.character(x)),\n    meta = if (length(deps)) list(deps))\n}\n\n#' @rdname knitr_methods\n#' @export\nknit_print.shiny.tag.list <- knit_print.shiny.tag\n\n\n\n#' @rdname builder\n#' @export\np <- function(...) tags$p(...)\n\n#' @rdname builder\n#' @export\nh1 <- function(...) tags$h1(...)\n\n#' @rdname builder\n#' @export\nh2 <- function(...) tags$h2(...)\n\n#' @rdname builder\n#' @export\nh3 <- function(...) tags$h3(...)\n\n#' @rdname builder\n#' @export\nh4 <- function(...) tags$h4(...)\n\n#' @rdname builder\n#' @export\nh5 <- function(...) tags$h5(...)\n\n#' @rdname builder\n#' @export\nh6 <- function(...) tags$h6(...)\n\n#' @rdname builder\n#' @export\na <- function(...) tags$a(...)\n\n#' @rdname builder\n#' @export\nbr <- function(...) tags$br(...)\n\n#' @rdname builder\n#' @export\ndiv <- function(...) tags$div(...)\n\n#' @rdname builder\n#' @export\nspan <- function(...) tags$span(...)\n\n#' @rdname builder\n#' @export\npre <- function(...) tags$pre(...)\n\n#' @rdname builder\n#' @export\ncode <- function(...) tags$code(...)\n\n#' @rdname builder\n#' @export\nimg <- function(...) tags$img(...)\n\n#' @rdname builder\n#' @export\nstrong <- function(...) tags$strong(...)\n\n#' @rdname builder\n#' @export\nem <- function(...) tags$em(...)\n\n#' @rdname builder\n#' @export\nhr <- function(...) tags$hr(...)\n\n#' Include Content From a File\n#'\n#' Load HTML, text, or rendered Markdown from a file and turn into HTML.\n#'\n#' These functions provide a convenient way to include an extensive amount of\n#' HTML, textual, Markdown, CSS, or JavaScript content, rather than using a\n#' large literal R string.\n#'\n#' @param path The path of the file to be included. It is highly recommended to\n#'   use a relative path (the base path being the Shiny application directory),\n#'   not an absolute path.\n#'\n#' @rdname include\n#' @name include\n#' @aliases includeHTML\n#' @export\nincludeHTML <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(HTML(paste8(lines, collapse='\\r\\n')))\n}\n\n#' @note \\code{includeText} escapes its contents, but does no other processing.\n#'   This means that hard breaks and multiple spaces will be rendered as they\n#'   usually are in HTML: as a single space character. If you are looking for\n#'   preformatted text, wrap the call with \\code{\\link{pre}}, or consider using\n#'   \\code{includeMarkdown} instead.\n#'\n#' @rdname include\n#' @export\nincludeText <- function(path) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(paste8(lines, collapse='\\r\\n'))\n}\n\n#' @note The \\code{includeMarkdown} function requires the \\code{markdown}\n#'   package.\n#' @rdname include\n#' @export\nincludeMarkdown <- function(path) {\n  html <- markdown::markdownToHTML(path, fragment.only=TRUE)\n  Encoding(html) <- 'UTF-8'\n  return(HTML(html))\n}\n\n#' @param ... Any additional attributes to be applied to the generated tag.\n#' @rdname include\n#' @export\nincludeCSS <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  args <- list(...)\n  if (is.null(args$type))\n    args$type <- 'text/css'\n  return(do.call(tags$style,\n    c(list(HTML(paste8(lines, collapse='\\r\\n'))), args)))\n}\n\n#' @rdname include\n#' @export\nincludeScript <- function(path, ...) {\n  lines <- readLines(path, warn=FALSE, encoding='UTF-8')\n  return(tags$script(HTML(paste8(lines, collapse='\\r\\n')), ...))\n}\n\n#' Include content only once\n#'\n#' Use \\code{singleton} to wrap contents (tag, text, HTML, or lists) that should\n#' be included in the generated document only once, yet may appear in the\n#' document-generating code more than once. Only the first appearance of the\n#' content (in document order) will be used.\n#'\n#' @param x A \\code{\\link{tag}}, text, \\code{\\link{HTML}}, or list.\n#' @param value Whether the object should be a singleton.\n#'\n#' @export\nsingleton <- function(x, value = TRUE) {\n  attr(x, \"htmltools.singleton\") <- if (isTRUE(value)) TRUE else NULL\n  return(x)\n}\n\n#' @rdname singleton\n#' @export\nis.singleton <- function(x) {\n  isTRUE(attr(x, \"htmltools.singleton\"))\n}\n\n\n#' Validate proper CSS formatting of a unit\n#'\n#' Checks that the argument is valid for use as a CSS unit of length.\n#'\n#' \\code{NULL} and \\code{NA} are returned unchanged.\n#'\n#' Single element numeric vectors are returned as a character vector with the\n#' number plus a suffix of \\code{\"px\"}.\n#'\n#' Single element character vectors must be \\code{\"auto\"} or \\code{\"inherit\"},\n#' or a number. If the number has a suffix, it must be valid: \\code{px},\n#' \\code{\\%}, \\code{em}, \\code{pt}, \\code{in}, \\code{cm}, \\code{mm}, \\code{ex},\n#' or \\code{pc}. If the number has no suffix, the suffix \\code{\"px\"} is\n#' appended.\n#'\n#' Any other value will cause an error to be thrown.\n#'\n#' @param x The unit to validate. Will be treated as a number of pixels if a\n#'   unit is not specified.\n#' @return A properly formatted CSS unit of length, if possible. Otherwise, will\n#'   throw an error.\n#' @examples\n#' validateCssUnit(\"10%\")\n#' validateCssUnit(400)  #treated as '400px'\n#' @export\nvalidateCssUnit <- function(x) {\n  if (is.null(x) || is.na(x))\n    return(x)\n\n  if (length(x) > 1 || (!is.character(x) && !is.numeric(x)))\n    stop('CSS units must be a single-element numeric or character vector')\n\n  # if the input is a character vector consisting only of digits (e.g. \"960\"),\n  # coerce it to a numeric value\n  if (is.character(x) && nchar(x) > 0 && gsub(\"\\\\d*\", \"\", x) == \"\")\n    x <- as.numeric(x)\n\n  pattern <-\n    \"^(auto|inherit|((\\\\.\\\\d+)|(\\\\d+(\\\\.\\\\d+)?))(%|in|cm|mm|em|ex|pt|pc|px))$\"\n\n  if (is.character(x) &&\n      !grepl(pattern, x)) {\n    stop('\"', x, '\" is not a valid CSS unit (e.g., \"100%\", \"400px\", \"auto\")')\n  } else if (is.numeric(x)) {\n    x <- paste(x, \"px\", sep = \"\")\n  }\n  x\n}\n\n#' CSS string helper\n#'\n#' Convenience function for building CSS style declarations (i.e. the string\n#' that goes into a style attribute, or the parts that go inside curly braces in\n#' a full stylesheet).\n#'\n#' CSS uses \\code{'-'} (minus) as a separator character in property names, but\n#' this is an inconvenient character to use in an R function argument name.\n#' Instead, you can use \\code{'.'} (period) and/or \\code{'_'} (underscore) as\n#' separator characters. For example, \\code{css(font.size = \"12px\")} yields\n#' \\code{\"font-size:12px;\"}.\n#'\n#' To mark a property as \\code{!important}, add a \\code{'!'} character to the end\n#' of the property name. (Since \\code{'!'} is not normally a character that can be\n#' used in an identifier in R, you'll need to put the name in double quotes or\n#' backticks.)\n#'\n#' Argument values will be converted to strings using\n#' \\code{paste(collapse = \" \")}. Any property with a value of \\code{NULL} or\n#' \\code{\"\"} (after paste) will be dropped.\n#'\n#' @param ... Named style properties, where the name is the property name and\n#'   the argument is the property value. See Details for conversion rules.\n#' @param collapse_ (Note that the parameter name has a trailing underscore\n#'   character.) Character to use to collapse properties into a single string;\n#'   likely \\code{\"\"} (the default) for style attributes, and either \\code{\"\\n\"}\n#'   or \\code{NULL} for style blocks.\n#'\n#' @examples\n#' padding <- 6\n#' css(\n#'   font.family = \"Helvetica, sans-serif\",\n#'   margin = paste0(c(10, 20, 10, 20), \"px\"),\n#'   \"padding!\" = if (!is.null(padding)) padding\n#' )\n#'\n#' @export\ncss <- function(..., collapse_ = \"\") {\n  props <- list(...)\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  if (is.null(names(props)) || any(names(props) == \"\")) {\n    stop(\"cssList expects all arguments to be named\")\n  }\n\n  # Necessary to make factors show up as level names, not numbers\n  props[] <- lapply(props, paste, collapse = \" \")\n\n  # Drop null args\n  props <- props[!sapply(props, empty)]\n  if (length(props) == 0) {\n    return(\"\")\n  }\n\n  # Replace all '.' and '_' in property names to '-'\n  names(props) <- gsub(\"[._]\", \"-\", tolower(gsub(\"([A-Z])\", \"-\\\\1\", names(props))))\n\n  # Create \"!important\" suffix for each property whose name ends with !, then\n  # remove the ! from the property name\n  important <- ifelse(grepl(\"!$\", names(props), perl = TRUE), \" !important\", \"\")\n  names(props) <- sub(\"!$\", \"\", names(props), perl = TRUE)\n\n  paste0(names(props), \":\", props, important, \";\", collapse = collapse_)\n}\n\nempty <- function(x) {\n  length(x) == 0 || (is.character(x) && !any(nzchar(x)))\n}\n"}</script>
</body>
</html>
